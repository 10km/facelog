// ______________________________________________________
// Generated by sql2java - https://github.com/10km/sql2java-2-6-7 (custom branch) 
// modified by guyadong from
// sql2java original version https://sourceforge.net/projects/sql2java/ 
// JDBC driver used at code generation time: com.mysql.jdbc.Driver
// template: table.loadcaching.java.vm
// ______________________________________________________
package net.gdface.facelog.db;

import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;

import com.google.common.base.Function;
import com.google.common.base.Objects;
import com.google.common.base.Predicate;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.Collections2;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Iterators;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;
import com.google.common.util.concurrent.UncheckedExecutionException;

import net.gdface.facelog.db.ITableCache.UpdateStrategy;
import net.gdface.facelog.db.exception.ObjectRetrievalException;

/**
 * 
 * 基于 {@link LoadingCache}实现MANY-TO-MANY 联接表(junction table)数据缓存,并可以通过{@link TableListener}实现缓存数据自动更新<br>
 * 联接表(junction table)定义:主键为两个字段K1,K2,并且两个字段又各是联接另外两张表的外键
 * @author guyadong
 *
 * @param <K1> 外键1类型(Foreign Key)
 * @param <K2> 外键2类型(Foreign Key)
 * @param <B> 数据库记录对象类型(Java Bean)
 */
public abstract class JunctionTableLoadCaching<K1 ,K2,B extends BaseBean<B>> {
	private class Key{
		K1 k1;
		K2 k2;
		Key(K1 k1, K2 k2) {
			this.k1 = k1;
			this.k2 = k2;
		}
		@Override
		public int hashCode() {			
			return new HashCodeBuilder(-82280557, -700257973)
					.append(k1)
					.append(k2)
					.hashCode();
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			@SuppressWarnings("unchecked")
			Key other = (Key) obj;
			return new EqualsBuilder()
					.append(k1, other.k1)
					.append(k2, other.k2)
					.isEquals();
		}

	}
    private final LoadingCache<Key, B> cache1;
    private final ConcurrentMap<Key, B> cacheMap1;
	protected final  TableListener.Adapter<B> tableListener;
    /** 当前更新策略 */
    private final UpdateStrategy updateStragey;
	private final Function<B, K1> funReturnK1 =new Function<B,K1>(){
		@Override
		public K1 apply(B input) {
			return returnK1(input);
		}};
	private final Function<B, K2> funReturnK2 = new Function<B,K2>(){
		@Override
		public K2 apply(B input) {
			return returnK2(input);
		}};
    /** 返回bean中外键K1值 */
    protected abstract K1 returnK1(B bean);
    /** 返回bean中外键K2值 */
    protected abstract K2 returnK2(B bean);
    /** 从数据库中加载外键(K1)指定的记录,没有找到指定的记录则抛出异常 */
    protected abstract Collection<B> loadfromDatabaseByK1(K1 key)throws Exception;

    /** 注册侦听器 */
    public abstract void registerListener();
    /** 注销侦听器 */
    public abstract void unregisterListener();
    public JunctionTableLoadCaching(){
        this(ITableCache.DEFAULT_CACHE_MAXIMUMSIZE,
        		ITableCache.DEFAULT_DURATION,
        		ITableCache.DEFAULT_TIME_UNIT);
    }
    public JunctionTableLoadCaching(long maximumSize){
        this(maximumSize,
        		ITableCache.DEFAULT_DURATION,
        		ITableCache.DEFAULT_TIME_UNIT);
    }
    public JunctionTableLoadCaching(long maximumSize,long durationMinutes){
        this(maximumSize,durationMinutes,ITableCache.DEFAULT_TIME_UNIT);
    }
    public JunctionTableLoadCaching(long maximumSize,long duration, TimeUnit unit) {
        this(ITableCache.DEFAULT_STRATEGY,maximumSize,duration,unit);
    }
    /**
     * 构造函数
     * @param updateStragey 缓存更新策略
     * @param maximumSize 最大缓存容量,参见 {@link CacheBuilder#maximumSize(long)}
     * @param duration 失效时间,参见 {@link CacheBuilder#expireAfterWrite(long, TimeUnit)}
     * @param unit {@code duration}的时间单位
     */
    public JunctionTableLoadCaching(UpdateStrategy updateStragey,long maximumSize,long duration, TimeUnit unit) {        
        if(null == updateStragey ) updateStragey = ITableCache.DEFAULT_STRATEGY;
        if(0 >= maximumSize) maximumSize = ITableCache.DEFAULT_CACHE_MAXIMUMSIZE;
        if(0 >= duration) maximumSize = ITableCache.DEFAULT_DURATION;
        if(null == unit) unit = ITableCache.DEFAULT_TIME_UNIT;
        this.updateStragey = updateStragey;
        cache1 = CacheBuilder.newBuilder()
            .maximumSize(maximumSize)
            .expireAfterWrite(duration, unit)
            .build(
                new CacheLoader<Key,B>() {
                    @Override
                    public B load(Key key) throws Exception {
						return null;

                    }});
        cacheMap1 = cache1.asMap();
        
        // 初始化侦听器,当表数据改变时自动更新缓存
        tableListener = new TableListener.Adapter<B>(){
            @Override
            public void afterUpdate(B bean) {
                update(bean);
            }
            
            @Override
            public void afterInsert(B bean) {
                update(bean);
            }
            
            @Override
            public void afterDelete(B bean) {
                remove(bean);
            }};
    }   
    public Collection<B> getBeansByK1(final K1 key)throws ExecutionException{
        return Collections2.filter(cacheMap1.values(), new Predicate<B>(){
			@Override
			public boolean apply(B input) {
				return Objects.equal(key, returnK1(input));
			}});
    }
    public B getBeansByK1IfPresent(K1 key){
        return null == key ? null : cache1.getIfPresent(key);
    }
    public B getBeansByK1Unchecked(K1 k1){
        try{
            return cache1.getUnchecked(new Key(k1,null));
        }catch(UncheckedExecutionException e){
            if(e.getCause() instanceof ObjectRetrievalException){
                return null;
            }
            throw e;
        } 
    }
    public B getBean(K1 k1,K2 k2) throws ExecutionException{
    	return null ==k1 || null == k2? null : cache1.get(new Key(k1,k2));
    }
    public B getBeanIfPresent(K1 k1,K2 k2){
    	return null ==k1 || null == k2? null : cache1.getIfPresent(new Key(k1,k2));
    }
    public B getBeanUnchecked(K1 k1,K2 k2){
        try{
        	return null ==k1 || null == k2? null : cache1.getUnchecked(new Key(k1,k2));
        }catch(UncheckedExecutionException e){
            if(e.getCause() instanceof ObjectRetrievalException){
                return null;
            }
            throw e;
        } 
    }

    /** 从缓存中删除{@code bean}指定的记录 */
    public void remove(B bean){
    	K1 k1 = returnK1(bean);
    	K2 k2 = returnK2(bean);
    	if(null !=k1 && null != k2){
    		cacheMap1.remove(new Key(k1,k2));
    	}
    }
    /**
     * 更新{@code bean}到指定的缓存对象{@code cacheMap}
     * @param bean
     * @param cacheMap
     */
    protected void update(B bean){
    	K1 k1 = returnK1(bean);
    	K2 k2 = returnK2(bean);
    	if(null !=k1 && null != k2){
    		this.updateStragey.update(cacheMap1, new Key(k1,k2), bean);
    	}
    }
}

