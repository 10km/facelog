/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "i_face_log_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_TokenType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case TOKEN_TYPE_UNINITIALIZED:return "TOKEN_TYPE_UNINITIALIZED";
  case TOKEN_TYPE_DEVICE:return "TOKEN_TYPE_DEVICE";
  case TOKEN_TYPE_PERSON:return "TOKEN_TYPE_PERSON";
  case TOKEN_TYPE_ROOT:return "TOKEN_TYPE_ROOT";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_SecurityExceptionType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case SECURITY_EXCEPTION_TYPE_UNCLASSIFIED:return "SECURITY_EXCEPTION_TYPE_UNCLASSIFIED";
  case SECURITY_EXCEPTION_TYPE_INVALID_MAC:return "SECURITY_EXCEPTION_TYPE_INVALID_MAC";
  case SECURITY_EXCEPTION_TYPE_INVALID_SN:return "SECURITY_EXCEPTION_TYPE_INVALID_SN";
  case SECURITY_EXCEPTION_TYPE_OCCUPIED_SN:return "SECURITY_EXCEPTION_TYPE_OCCUPIED_SN";
  case SECURITY_EXCEPTION_TYPE_INVALID_TOKEN:return "SECURITY_EXCEPTION_TYPE_INVALID_TOKEN";
  case SECURITY_EXCEPTION_TYPE_INVALID_DEVICE_ID:return "SECURITY_EXCEPTION_TYPE_INVALID_DEVICE_ID";
  case SECURITY_EXCEPTION_TYPE_INVALID_PERSON_ID:return "SECURITY_EXCEPTION_TYPE_INVALID_PERSON_ID";
  case SECURITY_EXCEPTION_TYPE_INVALID_PASSWORD:return "SECURITY_EXCEPTION_TYPE_INVALID_PASSWORD";
  case SECURITY_EXCEPTION_TYPE_REJECT_APPLY:return "SECURITY_EXCEPTION_TYPE_REJECT_APPLY";
  case SECURITY_EXCEPTION_TYPE_ACCESS_DENIED:return "SECURITY_EXCEPTION_TYPE_ACCESS_DENIED";
  case SECURITY_EXCEPTION_TYPE_TABLE_INSERT_DENIED:return "SECURITY_EXCEPTION_TYPE_TABLE_INSERT_DENIED";
  case SECURITY_EXCEPTION_TYPE_TABLE_UPDATE_DENIED:return "SECURITY_EXCEPTION_TYPE_TABLE_UPDATE_DENIED";
  case SECURITY_EXCEPTION_TYPE_TABLE_DELETE_DENIED:return "SECURITY_EXCEPTION_TYPE_TABLE_DELETE_DENIED";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_MQParam(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case M_Q_PARAM_REDIS_URI:return "M_Q_PARAM_REDIS_URI";
  case M_Q_PARAM_WEBREDIS_URL:return "M_Q_PARAM_WEBREDIS_URL";
  case M_Q_PARAM_CMD_CHANNEL:return "M_Q_PARAM_CMD_CHANNEL";
  case M_Q_PARAM_LOG_MONITOR_CHANNEL:return "M_Q_PARAM_LOG_MONITOR_CHANNEL";
  case M_Q_PARAM_HB_MONITOR_CHANNEL:return "M_Q_PARAM_HB_MONITOR_CHANNEL";
  case M_Q_PARAM_HB_INTERVAL:return "M_Q_PARAM_HB_INTERVAL";
  case M_Q_PARAM_HB_EXPIRE:return "M_Q_PARAM_HB_EXPIRE";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _FaceBeanProperties
{
  PROP_FACE_BEAN_0,
  PROP_FACE_BEAN__NEW,
  PROP_FACE_BEAN_MODIFIED,
  PROP_FACE_BEAN_INITIALIZED,
  PROP_FACE_BEAN_ID,
  PROP_FACE_BEAN_IMAGE_MD5,
  PROP_FACE_BEAN_FACE_LEFT,
  PROP_FACE_BEAN_FACE_TOP,
  PROP_FACE_BEAN_FACE_WIDTH,
  PROP_FACE_BEAN_FACE_HEIGHT,
  PROP_FACE_BEAN_EYE_LEFTX,
  PROP_FACE_BEAN_EYE_LEFTY,
  PROP_FACE_BEAN_EYE_RIGHTX,
  PROP_FACE_BEAN_EYE_RIGHTY,
  PROP_FACE_BEAN_MOUTH_X,
  PROP_FACE_BEAN_MOUTH_Y,
  PROP_FACE_BEAN_NOSE_X,
  PROP_FACE_BEAN_NOSE_Y,
  PROP_FACE_BEAN_ANGLE_YAW,
  PROP_FACE_BEAN_ANGLE_PITCH,
  PROP_FACE_BEAN_ANGLE_ROLL,
  PROP_FACE_BEAN_EXT_INFO,
  PROP_FACE_BEAN_FEATURE_MD5
};

/* reads a face_bean object */
static gint32
face_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  FaceBean * this_object = FACE_BEAN(object);
  gboolean isset__new = FALSE;
  gboolean isset_modified = FALSE;
  gboolean isset_initialized = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->_new, error)) < 0)
            return -1;
          xfer += ret;
          isset__new = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->modified, error)) < 0)
            return -1;
          xfer += ret;
          isset_modified = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->initialized, error)) < 0)
            return -1;
          xfer += ret;
          isset_initialized = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->imageMd5 != NULL)
          {
            g_free(this_object->imageMd5);
            this_object->imageMd5 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->imageMd5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_imageMd5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->faceLeft, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_faceLeft = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->faceTop, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_faceTop = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->faceWidth, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_faceWidth = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->faceHeight, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_faceHeight = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->eyeLeftx, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_eyeLeftx = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->eyeLefty, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_eyeLefty = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->eyeRightx, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_eyeRightx = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->eyeRighty, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_eyeRighty = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 14:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->mouthX, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_mouthX = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 15:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->mouthY, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_mouthY = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 16:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->noseX, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_noseX = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 17:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->noseY, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_noseY = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 18:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->angleYaw, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_angleYaw = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 19:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->anglePitch, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_anglePitch = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 20:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->angleRoll, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_angleRoll = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 21:
        if (ftype == T_STRING)
        {
          if (this_object->extInfo != NULL)
          {
            g_free(this_object->extInfo);
            this_object->extInfo = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->extInfo = g_byte_array_new();
          g_byte_array_append (this_object->extInfo, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_extInfo = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 22:
        if (ftype == T_STRING)
        {
          if (this_object->featureMd5 != NULL)
          {
            g_free(this_object->featureMd5);
            this_object->featureMd5 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->featureMd5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_featureMd5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset__new)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_modified)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_initialized)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
face_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  FaceBean * this_object = FACE_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FaceBean", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "_new", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->_new, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "modified", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->modified, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "initialized", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->initialized, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_id == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->id, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_imageMd5 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "imageMd5", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->imageMd5, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_faceLeft == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "faceLeft", T_I32, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->faceLeft, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_faceTop == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "faceTop", T_I32, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->faceTop, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_faceWidth == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "faceWidth", T_I32, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->faceWidth, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_faceHeight == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "faceHeight", T_I32, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->faceHeight, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_eyeLeftx == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "eyeLeftx", T_I32, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->eyeLeftx, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_eyeLefty == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "eyeLefty", T_I32, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->eyeLefty, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_eyeRightx == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "eyeRightx", T_I32, 12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->eyeRightx, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_eyeRighty == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "eyeRighty", T_I32, 13, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->eyeRighty, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_mouthX == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "mouthX", T_I32, 14, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->mouthX, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_mouthY == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "mouthY", T_I32, 15, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->mouthY, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_noseX == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "noseX", T_I32, 16, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->noseX, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_noseY == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "noseY", T_I32, 17, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->noseY, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_angleYaw == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "angleYaw", T_I32, 18, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->angleYaw, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_anglePitch == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "anglePitch", T_I32, 19, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->anglePitch, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_angleRoll == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "angleRoll", T_I32, 20, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->angleRoll, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extInfo == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extInfo", T_STRING, 21, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->extInfo ? ((GByteArray *) this_object->extInfo)->data : NULL, this_object->extInfo ? ((GByteArray *) this_object->extInfo)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_featureMd5 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "featureMd5", T_STRING, 22, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->featureMd5, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
face_bean_set_property (GObject *object,
                        guint property_id,
                        const GValue *value,
                        GParamSpec *pspec)
{
  FaceBean *self = FACE_BEAN (object);

  switch (property_id)
  {
    case PROP_FACE_BEAN__NEW:
      self->_new = g_value_get_boolean (value);
      break;

    case PROP_FACE_BEAN_MODIFIED:
      self->modified = g_value_get_int (value);
      break;

    case PROP_FACE_BEAN_INITIALIZED:
      self->initialized = g_value_get_int (value);
      break;

    case PROP_FACE_BEAN_ID:
      self->id = g_value_get_int (value);
      self->__isset_id = TRUE;
      break;

    case PROP_FACE_BEAN_IMAGE_MD5:
      if (self->imageMd5 != NULL)
        g_free (self->imageMd5);
      self->imageMd5 = g_value_dup_string (value);
      self->__isset_imageMd5 = TRUE;
      break;

    case PROP_FACE_BEAN_FACE_LEFT:
      self->faceLeft = g_value_get_int (value);
      self->__isset_faceLeft = TRUE;
      break;

    case PROP_FACE_BEAN_FACE_TOP:
      self->faceTop = g_value_get_int (value);
      self->__isset_faceTop = TRUE;
      break;

    case PROP_FACE_BEAN_FACE_WIDTH:
      self->faceWidth = g_value_get_int (value);
      self->__isset_faceWidth = TRUE;
      break;

    case PROP_FACE_BEAN_FACE_HEIGHT:
      self->faceHeight = g_value_get_int (value);
      self->__isset_faceHeight = TRUE;
      break;

    case PROP_FACE_BEAN_EYE_LEFTX:
      self->eyeLeftx = g_value_get_int (value);
      self->__isset_eyeLeftx = TRUE;
      break;

    case PROP_FACE_BEAN_EYE_LEFTY:
      self->eyeLefty = g_value_get_int (value);
      self->__isset_eyeLefty = TRUE;
      break;

    case PROP_FACE_BEAN_EYE_RIGHTX:
      self->eyeRightx = g_value_get_int (value);
      self->__isset_eyeRightx = TRUE;
      break;

    case PROP_FACE_BEAN_EYE_RIGHTY:
      self->eyeRighty = g_value_get_int (value);
      self->__isset_eyeRighty = TRUE;
      break;

    case PROP_FACE_BEAN_MOUTH_X:
      self->mouthX = g_value_get_int (value);
      self->__isset_mouthX = TRUE;
      break;

    case PROP_FACE_BEAN_MOUTH_Y:
      self->mouthY = g_value_get_int (value);
      self->__isset_mouthY = TRUE;
      break;

    case PROP_FACE_BEAN_NOSE_X:
      self->noseX = g_value_get_int (value);
      self->__isset_noseX = TRUE;
      break;

    case PROP_FACE_BEAN_NOSE_Y:
      self->noseY = g_value_get_int (value);
      self->__isset_noseY = TRUE;
      break;

    case PROP_FACE_BEAN_ANGLE_YAW:
      self->angleYaw = g_value_get_int (value);
      self->__isset_angleYaw = TRUE;
      break;

    case PROP_FACE_BEAN_ANGLE_PITCH:
      self->anglePitch = g_value_get_int (value);
      self->__isset_anglePitch = TRUE;
      break;

    case PROP_FACE_BEAN_ANGLE_ROLL:
      self->angleRoll = g_value_get_int (value);
      self->__isset_angleRoll = TRUE;
      break;

    case PROP_FACE_BEAN_EXT_INFO:
      if (self->extInfo != NULL)
        g_byte_array_unref (self->extInfo);
      self->extInfo = g_value_dup_boxed (value);
      self->__isset_extInfo = TRUE;
      break;

    case PROP_FACE_BEAN_FEATURE_MD5:
      if (self->featureMd5 != NULL)
        g_free (self->featureMd5);
      self->featureMd5 = g_value_dup_string (value);
      self->__isset_featureMd5 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
face_bean_get_property (GObject *object,
                        guint property_id,
                        GValue *value,
                        GParamSpec *pspec)
{
  FaceBean *self = FACE_BEAN (object);

  switch (property_id)
  {
    case PROP_FACE_BEAN__NEW:
      g_value_set_boolean (value, self->_new);
      break;

    case PROP_FACE_BEAN_MODIFIED:
      g_value_set_int (value, self->modified);
      break;

    case PROP_FACE_BEAN_INITIALIZED:
      g_value_set_int (value, self->initialized);
      break;

    case PROP_FACE_BEAN_ID:
      g_value_set_int (value, self->id);
      break;

    case PROP_FACE_BEAN_IMAGE_MD5:
      g_value_set_string (value, self->imageMd5);
      break;

    case PROP_FACE_BEAN_FACE_LEFT:
      g_value_set_int (value, self->faceLeft);
      break;

    case PROP_FACE_BEAN_FACE_TOP:
      g_value_set_int (value, self->faceTop);
      break;

    case PROP_FACE_BEAN_FACE_WIDTH:
      g_value_set_int (value, self->faceWidth);
      break;

    case PROP_FACE_BEAN_FACE_HEIGHT:
      g_value_set_int (value, self->faceHeight);
      break;

    case PROP_FACE_BEAN_EYE_LEFTX:
      g_value_set_int (value, self->eyeLeftx);
      break;

    case PROP_FACE_BEAN_EYE_LEFTY:
      g_value_set_int (value, self->eyeLefty);
      break;

    case PROP_FACE_BEAN_EYE_RIGHTX:
      g_value_set_int (value, self->eyeRightx);
      break;

    case PROP_FACE_BEAN_EYE_RIGHTY:
      g_value_set_int (value, self->eyeRighty);
      break;

    case PROP_FACE_BEAN_MOUTH_X:
      g_value_set_int (value, self->mouthX);
      break;

    case PROP_FACE_BEAN_MOUTH_Y:
      g_value_set_int (value, self->mouthY);
      break;

    case PROP_FACE_BEAN_NOSE_X:
      g_value_set_int (value, self->noseX);
      break;

    case PROP_FACE_BEAN_NOSE_Y:
      g_value_set_int (value, self->noseY);
      break;

    case PROP_FACE_BEAN_ANGLE_YAW:
      g_value_set_int (value, self->angleYaw);
      break;

    case PROP_FACE_BEAN_ANGLE_PITCH:
      g_value_set_int (value, self->anglePitch);
      break;

    case PROP_FACE_BEAN_ANGLE_ROLL:
      g_value_set_int (value, self->angleRoll);
      break;

    case PROP_FACE_BEAN_EXT_INFO:
      g_value_set_boxed (value, self->extInfo);
      break;

    case PROP_FACE_BEAN_FEATURE_MD5:
      g_value_set_string (value, self->featureMd5);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
face_bean_instance_init (FaceBean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->_new = 0;
  object->modified = 0;
  object->initialized = 0;
  object->id = 0;
  object->__isset_id = FALSE;
  object->imageMd5 = NULL;
  object->__isset_imageMd5 = FALSE;
  object->faceLeft = 0;
  object->__isset_faceLeft = FALSE;
  object->faceTop = 0;
  object->__isset_faceTop = FALSE;
  object->faceWidth = 0;
  object->__isset_faceWidth = FALSE;
  object->faceHeight = 0;
  object->__isset_faceHeight = FALSE;
  object->eyeLeftx = 0;
  object->__isset_eyeLeftx = FALSE;
  object->eyeLefty = 0;
  object->__isset_eyeLefty = FALSE;
  object->eyeRightx = 0;
  object->__isset_eyeRightx = FALSE;
  object->eyeRighty = 0;
  object->__isset_eyeRighty = FALSE;
  object->mouthX = 0;
  object->__isset_mouthX = FALSE;
  object->mouthY = 0;
  object->__isset_mouthY = FALSE;
  object->noseX = 0;
  object->__isset_noseX = FALSE;
  object->noseY = 0;
  object->__isset_noseY = FALSE;
  object->angleYaw = 0;
  object->__isset_angleYaw = FALSE;
  object->anglePitch = 0;
  object->__isset_anglePitch = FALSE;
  object->angleRoll = 0;
  object->__isset_angleRoll = FALSE;
  object->extInfo = NULL;
  object->__isset_extInfo = FALSE;
  object->featureMd5 = NULL;
  object->__isset_featureMd5 = FALSE;
}

static void 
face_bean_finalize (GObject *object)
{
  FaceBean *tobject = FACE_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->imageMd5 != NULL)
  {
    g_free(tobject->imageMd5);
    tobject->imageMd5 = NULL;
  }
  if (tobject->extInfo != NULL)
  {
    thrift_string_free(tobject->extInfo);
    tobject->extInfo = NULL;
  }
  if (tobject->featureMd5 != NULL)
  {
    g_free(tobject->featureMd5);
    tobject->featureMd5 = NULL;
  }
}

static void
face_bean_class_init (FaceBeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = face_bean_read;
  struct_class->write = face_bean_write;

  gobject_class->finalize = face_bean_finalize;
  gobject_class->get_property = face_bean_get_property;
  gobject_class->set_property = face_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN__NEW,
     g_param_spec_boolean ("_new",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN_MODIFIED,
     g_param_spec_int ("modified",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN_INITIALIZED,
     g_param_spec_int ("initialized",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN_ID,
     g_param_spec_int ("id",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN_IMAGE_MD5,
     g_param_spec_string ("imageMd5",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN_FACE_LEFT,
     g_param_spec_int ("faceLeft",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN_FACE_TOP,
     g_param_spec_int ("faceTop",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN_FACE_WIDTH,
     g_param_spec_int ("faceWidth",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN_FACE_HEIGHT,
     g_param_spec_int ("faceHeight",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN_EYE_LEFTX,
     g_param_spec_int ("eyeLeftx",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN_EYE_LEFTY,
     g_param_spec_int ("eyeLefty",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN_EYE_RIGHTX,
     g_param_spec_int ("eyeRightx",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN_EYE_RIGHTY,
     g_param_spec_int ("eyeRighty",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN_MOUTH_X,
     g_param_spec_int ("mouthX",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN_MOUTH_Y,
     g_param_spec_int ("mouthY",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN_NOSE_X,
     g_param_spec_int ("noseX",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN_NOSE_Y,
     g_param_spec_int ("noseY",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN_ANGLE_YAW,
     g_param_spec_int ("angleYaw",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN_ANGLE_PITCH,
     g_param_spec_int ("anglePitch",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN_ANGLE_ROLL,
     g_param_spec_int ("angleRoll",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN_EXT_INFO,
     g_param_spec_boxed ("extInfo",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FACE_BEAN_FEATURE_MD5,
     g_param_spec_string ("featureMd5",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
face_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (FaceBeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) face_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (FaceBean),
      0, /* n_preallocs */
      (GInstanceInitFunc) face_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "FaceBeanType",
                                   &type_info, 0);
  }

  return type;
}

enum _DuplicateRecordExceptionProperties
{
  PROP_DUPLICATE_RECORD_EXCEPTION_0,
  PROP_DUPLICATE_RECORD_EXCEPTION_MESSAGE,
  PROP_DUPLICATE_RECORD_EXCEPTION_CAUSE_CLASS,
  PROP_DUPLICATE_RECORD_EXCEPTION_SERVICE_STACK_TRACE_MESSAGE,
  PROP_DUPLICATE_RECORD_EXCEPTION_CAUSE_FIELDS
};

/* reads a duplicate_record_exception object */
static gint32
duplicate_record_exception_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DuplicateRecordException * this_object = DUPLICATE_RECORD_EXCEPTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->causeClass != NULL)
          {
            g_free(this_object->causeClass);
            this_object->causeClass = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->causeClass, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_causeClass = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->serviceStackTraceMessage != NULL)
          {
            g_free(this_object->serviceStackTraceMessage);
            this_object->serviceStackTraceMessage = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->serviceStackTraceMessage, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_serviceStackTraceMessage = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->causeFields != NULL)
          {
            g_free(this_object->causeFields);
            this_object->causeFields = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->causeFields, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_causeFields = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
duplicate_record_exception_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DuplicateRecordException * this_object = DUPLICATE_RECORD_EXCEPTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DuplicateRecordException", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_message == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_causeClass == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "causeClass", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->causeClass, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_serviceStackTraceMessage == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "serviceStackTraceMessage", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->serviceStackTraceMessage, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_causeFields == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "causeFields", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->causeFields, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
duplicate_record_exception_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  DuplicateRecordException *self = DUPLICATE_RECORD_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_DUPLICATE_RECORD_EXCEPTION_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    case PROP_DUPLICATE_RECORD_EXCEPTION_CAUSE_CLASS:
      if (self->causeClass != NULL)
        g_free (self->causeClass);
      self->causeClass = g_value_dup_string (value);
      self->__isset_causeClass = TRUE;
      break;

    case PROP_DUPLICATE_RECORD_EXCEPTION_SERVICE_STACK_TRACE_MESSAGE:
      if (self->serviceStackTraceMessage != NULL)
        g_free (self->serviceStackTraceMessage);
      self->serviceStackTraceMessage = g_value_dup_string (value);
      self->__isset_serviceStackTraceMessage = TRUE;
      break;

    case PROP_DUPLICATE_RECORD_EXCEPTION_CAUSE_FIELDS:
      if (self->causeFields != NULL)
        g_free (self->causeFields);
      self->causeFields = g_value_dup_string (value);
      self->__isset_causeFields = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
duplicate_record_exception_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  DuplicateRecordException *self = DUPLICATE_RECORD_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_DUPLICATE_RECORD_EXCEPTION_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    case PROP_DUPLICATE_RECORD_EXCEPTION_CAUSE_CLASS:
      g_value_set_string (value, self->causeClass);
      break;

    case PROP_DUPLICATE_RECORD_EXCEPTION_SERVICE_STACK_TRACE_MESSAGE:
      g_value_set_string (value, self->serviceStackTraceMessage);
      break;

    case PROP_DUPLICATE_RECORD_EXCEPTION_CAUSE_FIELDS:
      g_value_set_string (value, self->causeFields);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
duplicate_record_exception_instance_init (DuplicateRecordException * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->message = NULL;
  object->__isset_message = FALSE;
  object->causeClass = NULL;
  object->__isset_causeClass = FALSE;
  object->serviceStackTraceMessage = NULL;
  object->__isset_serviceStackTraceMessage = FALSE;
  object->causeFields = NULL;
  object->__isset_causeFields = FALSE;
}

static void 
duplicate_record_exception_finalize (GObject *object)
{
  DuplicateRecordException *tobject = DUPLICATE_RECORD_EXCEPTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
  if (tobject->causeClass != NULL)
  {
    g_free(tobject->causeClass);
    tobject->causeClass = NULL;
  }
  if (tobject->serviceStackTraceMessage != NULL)
  {
    g_free(tobject->serviceStackTraceMessage);
    tobject->serviceStackTraceMessage = NULL;
  }
  if (tobject->causeFields != NULL)
  {
    g_free(tobject->causeFields);
    tobject->causeFields = NULL;
  }
}

static void
duplicate_record_exception_class_init (DuplicateRecordExceptionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = duplicate_record_exception_read;
  struct_class->write = duplicate_record_exception_write;

  gobject_class->finalize = duplicate_record_exception_finalize;
  gobject_class->get_property = duplicate_record_exception_get_property;
  gobject_class->set_property = duplicate_record_exception_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DUPLICATE_RECORD_EXCEPTION_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DUPLICATE_RECORD_EXCEPTION_CAUSE_CLASS,
     g_param_spec_string ("causeClass",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DUPLICATE_RECORD_EXCEPTION_SERVICE_STACK_TRACE_MESSAGE,
     g_param_spec_string ("serviceStackTraceMessage",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DUPLICATE_RECORD_EXCEPTION_CAUSE_FIELDS,
     g_param_spec_string ("causeFields",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
duplicate_record_exception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DuplicateRecordExceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) duplicate_record_exception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DuplicateRecordException),
      0, /* n_preallocs */
      (GInstanceInitFunc) duplicate_record_exception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DuplicateRecordExceptionType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define DUPLICATE_RECORD_EXCEPTION_ERROR_DOMAIN "duplicate_record_exception_error_quark"
GQuark
duplicate_record_exception_error_quark (void)
{
  return g_quark_from_static_string (DUPLICATE_RECORD_EXCEPTION_ERROR_DOMAIN);
}

enum _ServiceRuntimeExceptionProperties
{
  PROP_SERVICE_RUNTIME_EXCEPTION_0,
  PROP_SERVICE_RUNTIME_EXCEPTION_MESSAGE,
  PROP_SERVICE_RUNTIME_EXCEPTION_CAUSE_CLASS,
  PROP_SERVICE_RUNTIME_EXCEPTION_SERVICE_STACK_TRACE_MESSAGE,
  PROP_SERVICE_RUNTIME_EXCEPTION_CAUSE_FIELDS,
  PROP_SERVICE_RUNTIME_EXCEPTION_TYPE
};

/* reads a service_runtime_exception object */
static gint32
service_runtime_exception_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceRuntimeException * this_object = SERVICE_RUNTIME_EXCEPTION(object);
  gboolean isset_type = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->causeClass != NULL)
          {
            g_free(this_object->causeClass);
            this_object->causeClass = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->causeClass, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_causeClass = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->serviceStackTraceMessage != NULL)
          {
            g_free(this_object->serviceStackTraceMessage);
            this_object->serviceStackTraceMessage = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->serviceStackTraceMessage, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_serviceStackTraceMessage = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->causeFields != NULL)
          {
            g_free(this_object->causeFields);
            this_object->causeFields = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->causeFields, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_causeFields = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->type, error)) < 0)
            return -1;
          xfer += ret;
          isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_type)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
service_runtime_exception_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceRuntimeException * this_object = SERVICE_RUNTIME_EXCEPTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceRuntimeException", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_message == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_causeClass == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "causeClass", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->causeClass, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_serviceStackTraceMessage == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "serviceStackTraceMessage", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->serviceStackTraceMessage, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_causeFields == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "causeFields", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->causeFields, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_runtime_exception_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  ServiceRuntimeException *self = SERVICE_RUNTIME_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_SERVICE_RUNTIME_EXCEPTION_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    case PROP_SERVICE_RUNTIME_EXCEPTION_CAUSE_CLASS:
      if (self->causeClass != NULL)
        g_free (self->causeClass);
      self->causeClass = g_value_dup_string (value);
      self->__isset_causeClass = TRUE;
      break;

    case PROP_SERVICE_RUNTIME_EXCEPTION_SERVICE_STACK_TRACE_MESSAGE:
      if (self->serviceStackTraceMessage != NULL)
        g_free (self->serviceStackTraceMessage);
      self->serviceStackTraceMessage = g_value_dup_string (value);
      self->__isset_serviceStackTraceMessage = TRUE;
      break;

    case PROP_SERVICE_RUNTIME_EXCEPTION_CAUSE_FIELDS:
      if (self->causeFields != NULL)
        g_free (self->causeFields);
      self->causeFields = g_value_dup_string (value);
      self->__isset_causeFields = TRUE;
      break;

    case PROP_SERVICE_RUNTIME_EXCEPTION_TYPE:
      self->type = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_runtime_exception_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  ServiceRuntimeException *self = SERVICE_RUNTIME_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_SERVICE_RUNTIME_EXCEPTION_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    case PROP_SERVICE_RUNTIME_EXCEPTION_CAUSE_CLASS:
      g_value_set_string (value, self->causeClass);
      break;

    case PROP_SERVICE_RUNTIME_EXCEPTION_SERVICE_STACK_TRACE_MESSAGE:
      g_value_set_string (value, self->serviceStackTraceMessage);
      break;

    case PROP_SERVICE_RUNTIME_EXCEPTION_CAUSE_FIELDS:
      g_value_set_string (value, self->causeFields);
      break;

    case PROP_SERVICE_RUNTIME_EXCEPTION_TYPE:
      g_value_set_int (value, self->type);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_runtime_exception_instance_init (ServiceRuntimeException * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->message = NULL;
  object->__isset_message = FALSE;
  object->causeClass = NULL;
  object->__isset_causeClass = FALSE;
  object->serviceStackTraceMessage = NULL;
  object->__isset_serviceStackTraceMessage = FALSE;
  object->causeFields = NULL;
  object->__isset_causeFields = FALSE;
  object->type = 0;
}

static void 
service_runtime_exception_finalize (GObject *object)
{
  ServiceRuntimeException *tobject = SERVICE_RUNTIME_EXCEPTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
  if (tobject->causeClass != NULL)
  {
    g_free(tobject->causeClass);
    tobject->causeClass = NULL;
  }
  if (tobject->serviceStackTraceMessage != NULL)
  {
    g_free(tobject->serviceStackTraceMessage);
    tobject->serviceStackTraceMessage = NULL;
  }
  if (tobject->causeFields != NULL)
  {
    g_free(tobject->causeFields);
    tobject->causeFields = NULL;
  }
}

static void
service_runtime_exception_class_init (ServiceRuntimeExceptionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_runtime_exception_read;
  struct_class->write = service_runtime_exception_write;

  gobject_class->finalize = service_runtime_exception_finalize;
  gobject_class->get_property = service_runtime_exception_get_property;
  gobject_class->set_property = service_runtime_exception_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_RUNTIME_EXCEPTION_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_RUNTIME_EXCEPTION_CAUSE_CLASS,
     g_param_spec_string ("causeClass",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_RUNTIME_EXCEPTION_SERVICE_STACK_TRACE_MESSAGE,
     g_param_spec_string ("serviceStackTraceMessage",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_RUNTIME_EXCEPTION_CAUSE_FIELDS,
     g_param_spec_string ("causeFields",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_RUNTIME_EXCEPTION_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
service_runtime_exception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceRuntimeExceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_runtime_exception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceRuntimeException),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_runtime_exception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceRuntimeExceptionType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define SERVICE_RUNTIME_EXCEPTION_ERROR_DOMAIN "service_runtime_exception_error_quark"
GQuark
service_runtime_exception_error_quark (void)
{
  return g_quark_from_static_string (SERVICE_RUNTIME_EXCEPTION_ERROR_DOMAIN);
}

enum _FeatureBeanProperties
{
  PROP_FEATURE_BEAN_0,
  PROP_FEATURE_BEAN__NEW,
  PROP_FEATURE_BEAN_MODIFIED,
  PROP_FEATURE_BEAN_INITIALIZED,
  PROP_FEATURE_BEAN_MD5,
  PROP_FEATURE_BEAN_VERSION,
  PROP_FEATURE_BEAN_PERSON_ID,
  PROP_FEATURE_BEAN_FEATURE,
  PROP_FEATURE_BEAN_UPDATE_TIME
};

/* reads a feature_bean object */
static gint32
feature_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  FeatureBean * this_object = FEATURE_BEAN(object);
  gboolean isset__new = FALSE;
  gboolean isset_modified = FALSE;
  gboolean isset_initialized = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->_new, error)) < 0)
            return -1;
          xfer += ret;
          isset__new = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->modified, error)) < 0)
            return -1;
          xfer += ret;
          isset_modified = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->initialized, error)) < 0)
            return -1;
          xfer += ret;
          isset_initialized = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->md5 != NULL)
          {
            g_free(this_object->md5);
            this_object->md5 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->md5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_md5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->version != NULL)
          {
            g_free(this_object->version);
            this_object->version = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->version, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_version = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->feature != NULL)
          {
            g_free(this_object->feature);
            this_object->feature = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->feature = g_byte_array_new();
          g_byte_array_append (this_object->feature, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_feature = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->updateTime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_updateTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset__new)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_modified)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_initialized)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
feature_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  FeatureBean * this_object = FEATURE_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FeatureBean", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "_new", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->_new, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "modified", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->modified, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "initialized", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->initialized, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_md5 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "md5", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->md5, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_version == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "version", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->version, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_personId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_feature == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "feature", T_STRING, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->feature ? ((GByteArray *) this_object->feature)->data : NULL, this_object->feature ? ((GByteArray *) this_object->feature)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_updateTime == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "updateTime", T_I64, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->updateTime, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
feature_bean_set_property (GObject *object,
                           guint property_id,
                           const GValue *value,
                           GParamSpec *pspec)
{
  FeatureBean *self = FEATURE_BEAN (object);

  switch (property_id)
  {
    case PROP_FEATURE_BEAN__NEW:
      self->_new = g_value_get_boolean (value);
      break;

    case PROP_FEATURE_BEAN_MODIFIED:
      self->modified = g_value_get_int (value);
      break;

    case PROP_FEATURE_BEAN_INITIALIZED:
      self->initialized = g_value_get_int (value);
      break;

    case PROP_FEATURE_BEAN_MD5:
      if (self->md5 != NULL)
        g_free (self->md5);
      self->md5 = g_value_dup_string (value);
      self->__isset_md5 = TRUE;
      break;

    case PROP_FEATURE_BEAN_VERSION:
      if (self->version != NULL)
        g_free (self->version);
      self->version = g_value_dup_string (value);
      self->__isset_version = TRUE;
      break;

    case PROP_FEATURE_BEAN_PERSON_ID:
      self->personId = g_value_get_int (value);
      self->__isset_personId = TRUE;
      break;

    case PROP_FEATURE_BEAN_FEATURE:
      if (self->feature != NULL)
        g_byte_array_unref (self->feature);
      self->feature = g_value_dup_boxed (value);
      self->__isset_feature = TRUE;
      break;

    case PROP_FEATURE_BEAN_UPDATE_TIME:
      self->updateTime = g_value_get_int64 (value);
      self->__isset_updateTime = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
feature_bean_get_property (GObject *object,
                           guint property_id,
                           GValue *value,
                           GParamSpec *pspec)
{
  FeatureBean *self = FEATURE_BEAN (object);

  switch (property_id)
  {
    case PROP_FEATURE_BEAN__NEW:
      g_value_set_boolean (value, self->_new);
      break;

    case PROP_FEATURE_BEAN_MODIFIED:
      g_value_set_int (value, self->modified);
      break;

    case PROP_FEATURE_BEAN_INITIALIZED:
      g_value_set_int (value, self->initialized);
      break;

    case PROP_FEATURE_BEAN_MD5:
      g_value_set_string (value, self->md5);
      break;

    case PROP_FEATURE_BEAN_VERSION:
      g_value_set_string (value, self->version);
      break;

    case PROP_FEATURE_BEAN_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    case PROP_FEATURE_BEAN_FEATURE:
      g_value_set_boxed (value, self->feature);
      break;

    case PROP_FEATURE_BEAN_UPDATE_TIME:
      g_value_set_int64 (value, self->updateTime);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
feature_bean_instance_init (FeatureBean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->_new = 0;
  object->modified = 0;
  object->initialized = 0;
  object->md5 = NULL;
  object->__isset_md5 = FALSE;
  object->version = NULL;
  object->__isset_version = FALSE;
  object->personId = 0;
  object->__isset_personId = FALSE;
  object->feature = NULL;
  object->__isset_feature = FALSE;
  object->updateTime = 0;
  object->__isset_updateTime = FALSE;
}

static void 
feature_bean_finalize (GObject *object)
{
  FeatureBean *tobject = FEATURE_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->md5 != NULL)
  {
    g_free(tobject->md5);
    tobject->md5 = NULL;
  }
  if (tobject->version != NULL)
  {
    g_free(tobject->version);
    tobject->version = NULL;
  }
  if (tobject->feature != NULL)
  {
    thrift_string_free(tobject->feature);
    tobject->feature = NULL;
  }
}

static void
feature_bean_class_init (FeatureBeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = feature_bean_read;
  struct_class->write = feature_bean_write;

  gobject_class->finalize = feature_bean_finalize;
  gobject_class->get_property = feature_bean_get_property;
  gobject_class->set_property = feature_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_FEATURE_BEAN__NEW,
     g_param_spec_boolean ("_new",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FEATURE_BEAN_MODIFIED,
     g_param_spec_int ("modified",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FEATURE_BEAN_INITIALIZED,
     g_param_spec_int ("initialized",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FEATURE_BEAN_MD5,
     g_param_spec_string ("md5",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FEATURE_BEAN_VERSION,
     g_param_spec_string ("version",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FEATURE_BEAN_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FEATURE_BEAN_FEATURE,
     g_param_spec_boxed ("feature",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_FEATURE_BEAN_UPDATE_TIME,
     g_param_spec_int64 ("updateTime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
feature_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (FeatureBeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) feature_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (FeatureBean),
      0, /* n_preallocs */
      (GInstanceInitFunc) feature_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "FeatureBeanType",
                                   &type_info, 0);
  }

  return type;
}

enum _ImageBeanProperties
{
  PROP_IMAGE_BEAN_0,
  PROP_IMAGE_BEAN__NEW,
  PROP_IMAGE_BEAN_MODIFIED,
  PROP_IMAGE_BEAN_INITIALIZED,
  PROP_IMAGE_BEAN_MD5,
  PROP_IMAGE_BEAN_FORMAT,
  PROP_IMAGE_BEAN_WIDTH,
  PROP_IMAGE_BEAN_HEIGHT,
  PROP_IMAGE_BEAN_DEPTH,
  PROP_IMAGE_BEAN_FACE_NUM,
  PROP_IMAGE_BEAN_THUMB_MD5,
  PROP_IMAGE_BEAN_DEVICE_ID
};

/* reads a image_bean object */
static gint32
image_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ImageBean * this_object = IMAGE_BEAN(object);
  gboolean isset__new = FALSE;
  gboolean isset_modified = FALSE;
  gboolean isset_initialized = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->_new, error)) < 0)
            return -1;
          xfer += ret;
          isset__new = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->modified, error)) < 0)
            return -1;
          xfer += ret;
          isset_modified = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->initialized, error)) < 0)
            return -1;
          xfer += ret;
          isset_initialized = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->md5 != NULL)
          {
            g_free(this_object->md5);
            this_object->md5 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->md5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_md5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->format != NULL)
          {
            g_free(this_object->format);
            this_object->format = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->format, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_format = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->width, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_width = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->height, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_height = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->depth, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_depth = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->faceNum, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_faceNum = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_STRING)
        {
          if (this_object->thumbMd5 != NULL)
          {
            g_free(this_object->thumbMd5);
            this_object->thumbMd5 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->thumbMd5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_thumbMd5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_deviceId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset__new)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_modified)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_initialized)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
image_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ImageBean * this_object = IMAGE_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ImageBean", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "_new", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->_new, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "modified", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->modified, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "initialized", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->initialized, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_md5 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "md5", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->md5, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_format == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "format", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->format, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_width == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "width", T_I32, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->width, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_height == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "height", T_I32, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->height, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_depth == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "depth", T_I32, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->depth, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_faceNum == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "faceNum", T_I32, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->faceNum, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_thumbMd5 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "thumbMd5", T_STRING, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->thumbMd5, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_deviceId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceId", T_I32, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
image_bean_set_property (GObject *object,
                         guint property_id,
                         const GValue *value,
                         GParamSpec *pspec)
{
  ImageBean *self = IMAGE_BEAN (object);

  switch (property_id)
  {
    case PROP_IMAGE_BEAN__NEW:
      self->_new = g_value_get_boolean (value);
      break;

    case PROP_IMAGE_BEAN_MODIFIED:
      self->modified = g_value_get_int (value);
      break;

    case PROP_IMAGE_BEAN_INITIALIZED:
      self->initialized = g_value_get_int (value);
      break;

    case PROP_IMAGE_BEAN_MD5:
      if (self->md5 != NULL)
        g_free (self->md5);
      self->md5 = g_value_dup_string (value);
      self->__isset_md5 = TRUE;
      break;

    case PROP_IMAGE_BEAN_FORMAT:
      if (self->format != NULL)
        g_free (self->format);
      self->format = g_value_dup_string (value);
      self->__isset_format = TRUE;
      break;

    case PROP_IMAGE_BEAN_WIDTH:
      self->width = g_value_get_int (value);
      self->__isset_width = TRUE;
      break;

    case PROP_IMAGE_BEAN_HEIGHT:
      self->height = g_value_get_int (value);
      self->__isset_height = TRUE;
      break;

    case PROP_IMAGE_BEAN_DEPTH:
      self->depth = g_value_get_int (value);
      self->__isset_depth = TRUE;
      break;

    case PROP_IMAGE_BEAN_FACE_NUM:
      self->faceNum = g_value_get_int (value);
      self->__isset_faceNum = TRUE;
      break;

    case PROP_IMAGE_BEAN_THUMB_MD5:
      if (self->thumbMd5 != NULL)
        g_free (self->thumbMd5);
      self->thumbMd5 = g_value_dup_string (value);
      self->__isset_thumbMd5 = TRUE;
      break;

    case PROP_IMAGE_BEAN_DEVICE_ID:
      self->deviceId = g_value_get_int (value);
      self->__isset_deviceId = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
image_bean_get_property (GObject *object,
                         guint property_id,
                         GValue *value,
                         GParamSpec *pspec)
{
  ImageBean *self = IMAGE_BEAN (object);

  switch (property_id)
  {
    case PROP_IMAGE_BEAN__NEW:
      g_value_set_boolean (value, self->_new);
      break;

    case PROP_IMAGE_BEAN_MODIFIED:
      g_value_set_int (value, self->modified);
      break;

    case PROP_IMAGE_BEAN_INITIALIZED:
      g_value_set_int (value, self->initialized);
      break;

    case PROP_IMAGE_BEAN_MD5:
      g_value_set_string (value, self->md5);
      break;

    case PROP_IMAGE_BEAN_FORMAT:
      g_value_set_string (value, self->format);
      break;

    case PROP_IMAGE_BEAN_WIDTH:
      g_value_set_int (value, self->width);
      break;

    case PROP_IMAGE_BEAN_HEIGHT:
      g_value_set_int (value, self->height);
      break;

    case PROP_IMAGE_BEAN_DEPTH:
      g_value_set_int (value, self->depth);
      break;

    case PROP_IMAGE_BEAN_FACE_NUM:
      g_value_set_int (value, self->faceNum);
      break;

    case PROP_IMAGE_BEAN_THUMB_MD5:
      g_value_set_string (value, self->thumbMd5);
      break;

    case PROP_IMAGE_BEAN_DEVICE_ID:
      g_value_set_int (value, self->deviceId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
image_bean_instance_init (ImageBean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->_new = 0;
  object->modified = 0;
  object->initialized = 0;
  object->md5 = NULL;
  object->__isset_md5 = FALSE;
  object->format = NULL;
  object->__isset_format = FALSE;
  object->width = 0;
  object->__isset_width = FALSE;
  object->height = 0;
  object->__isset_height = FALSE;
  object->depth = 0;
  object->__isset_depth = FALSE;
  object->faceNum = 0;
  object->__isset_faceNum = FALSE;
  object->thumbMd5 = NULL;
  object->__isset_thumbMd5 = FALSE;
  object->deviceId = 0;
  object->__isset_deviceId = FALSE;
}

static void 
image_bean_finalize (GObject *object)
{
  ImageBean *tobject = IMAGE_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->md5 != NULL)
  {
    g_free(tobject->md5);
    tobject->md5 = NULL;
  }
  if (tobject->format != NULL)
  {
    g_free(tobject->format);
    tobject->format = NULL;
  }
  if (tobject->thumbMd5 != NULL)
  {
    g_free(tobject->thumbMd5);
    tobject->thumbMd5 = NULL;
  }
}

static void
image_bean_class_init (ImageBeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = image_bean_read;
  struct_class->write = image_bean_write;

  gobject_class->finalize = image_bean_finalize;
  gobject_class->get_property = image_bean_get_property;
  gobject_class->set_property = image_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_IMAGE_BEAN__NEW,
     g_param_spec_boolean ("_new",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_IMAGE_BEAN_MODIFIED,
     g_param_spec_int ("modified",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_IMAGE_BEAN_INITIALIZED,
     g_param_spec_int ("initialized",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_IMAGE_BEAN_MD5,
     g_param_spec_string ("md5",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_IMAGE_BEAN_FORMAT,
     g_param_spec_string ("format",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_IMAGE_BEAN_WIDTH,
     g_param_spec_int ("width",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_IMAGE_BEAN_HEIGHT,
     g_param_spec_int ("height",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_IMAGE_BEAN_DEPTH,
     g_param_spec_int ("depth",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_IMAGE_BEAN_FACE_NUM,
     g_param_spec_int ("faceNum",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_IMAGE_BEAN_THUMB_MD5,
     g_param_spec_string ("thumbMd5",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_IMAGE_BEAN_DEVICE_ID,
     g_param_spec_int ("deviceId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
image_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ImageBeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) image_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ImageBean),
      0, /* n_preallocs */
      (GInstanceInitFunc) image_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ImageBeanType",
                                   &type_info, 0);
  }

  return type;
}

enum _LogBeanProperties
{
  PROP_LOG_BEAN_0,
  PROP_LOG_BEAN__NEW,
  PROP_LOG_BEAN_MODIFIED,
  PROP_LOG_BEAN_INITIALIZED,
  PROP_LOG_BEAN_ID,
  PROP_LOG_BEAN_PERSON_ID,
  PROP_LOG_BEAN_DEVICE_ID,
  PROP_LOG_BEAN_VERIFY_FEATURE,
  PROP_LOG_BEAN_COMPARE_FACE,
  PROP_LOG_BEAN_VERIFY_STATUS,
  PROP_LOG_BEAN_SIMILARTY,
  PROP_LOG_BEAN_VERIFY_TIME,
  PROP_LOG_BEAN_CREATE_TIME
};

/* reads a log_bean object */
static gint32
log_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  LogBean * this_object = LOG_BEAN(object);
  gboolean isset__new = FALSE;
  gboolean isset_modified = FALSE;
  gboolean isset_initialized = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->_new, error)) < 0)
            return -1;
          xfer += ret;
          isset__new = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->modified, error)) < 0)
            return -1;
          xfer += ret;
          isset_modified = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->initialized, error)) < 0)
            return -1;
          xfer += ret;
          isset_initialized = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_deviceId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->verifyFeature != NULL)
          {
            g_free(this_object->verifyFeature);
            this_object->verifyFeature = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->verifyFeature, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_verifyFeature = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->compareFace, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_compareFace = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->verifyStatus, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_verifyStatus = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->similarty, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_similarty = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->verifyTime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_verifyTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->createTime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_createTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset__new)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_modified)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_initialized)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
log_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  LogBean * this_object = LOG_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "LogBean", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "_new", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->_new, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "modified", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->modified, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "initialized", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->initialized, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_id == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->id, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_personId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_deviceId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceId", T_I32, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_verifyFeature == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "verifyFeature", T_STRING, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->verifyFeature, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_compareFace == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "compareFace", T_I32, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->compareFace, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_verifyStatus == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "verifyStatus", T_I32, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->verifyStatus, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_similarty == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "similarty", T_DOUBLE, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_double (protocol, this_object->similarty, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_verifyTime == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "verifyTime", T_I64, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->verifyTime, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_createTime == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "createTime", T_I64, 12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->createTime, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
log_bean_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  LogBean *self = LOG_BEAN (object);

  switch (property_id)
  {
    case PROP_LOG_BEAN__NEW:
      self->_new = g_value_get_boolean (value);
      break;

    case PROP_LOG_BEAN_MODIFIED:
      self->modified = g_value_get_int (value);
      break;

    case PROP_LOG_BEAN_INITIALIZED:
      self->initialized = g_value_get_int (value);
      break;

    case PROP_LOG_BEAN_ID:
      self->id = g_value_get_int (value);
      self->__isset_id = TRUE;
      break;

    case PROP_LOG_BEAN_PERSON_ID:
      self->personId = g_value_get_int (value);
      self->__isset_personId = TRUE;
      break;

    case PROP_LOG_BEAN_DEVICE_ID:
      self->deviceId = g_value_get_int (value);
      self->__isset_deviceId = TRUE;
      break;

    case PROP_LOG_BEAN_VERIFY_FEATURE:
      if (self->verifyFeature != NULL)
        g_free (self->verifyFeature);
      self->verifyFeature = g_value_dup_string (value);
      self->__isset_verifyFeature = TRUE;
      break;

    case PROP_LOG_BEAN_COMPARE_FACE:
      self->compareFace = g_value_get_int (value);
      self->__isset_compareFace = TRUE;
      break;

    case PROP_LOG_BEAN_VERIFY_STATUS:
      self->verifyStatus = g_value_get_int (value);
      self->__isset_verifyStatus = TRUE;
      break;

    case PROP_LOG_BEAN_SIMILARTY:
      self->similarty = g_value_get_double (value);
      self->__isset_similarty = TRUE;
      break;

    case PROP_LOG_BEAN_VERIFY_TIME:
      self->verifyTime = g_value_get_int64 (value);
      self->__isset_verifyTime = TRUE;
      break;

    case PROP_LOG_BEAN_CREATE_TIME:
      self->createTime = g_value_get_int64 (value);
      self->__isset_createTime = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
log_bean_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  LogBean *self = LOG_BEAN (object);

  switch (property_id)
  {
    case PROP_LOG_BEAN__NEW:
      g_value_set_boolean (value, self->_new);
      break;

    case PROP_LOG_BEAN_MODIFIED:
      g_value_set_int (value, self->modified);
      break;

    case PROP_LOG_BEAN_INITIALIZED:
      g_value_set_int (value, self->initialized);
      break;

    case PROP_LOG_BEAN_ID:
      g_value_set_int (value, self->id);
      break;

    case PROP_LOG_BEAN_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    case PROP_LOG_BEAN_DEVICE_ID:
      g_value_set_int (value, self->deviceId);
      break;

    case PROP_LOG_BEAN_VERIFY_FEATURE:
      g_value_set_string (value, self->verifyFeature);
      break;

    case PROP_LOG_BEAN_COMPARE_FACE:
      g_value_set_int (value, self->compareFace);
      break;

    case PROP_LOG_BEAN_VERIFY_STATUS:
      g_value_set_int (value, self->verifyStatus);
      break;

    case PROP_LOG_BEAN_SIMILARTY:
      g_value_set_double (value, self->similarty);
      break;

    case PROP_LOG_BEAN_VERIFY_TIME:
      g_value_set_int64 (value, self->verifyTime);
      break;

    case PROP_LOG_BEAN_CREATE_TIME:
      g_value_set_int64 (value, self->createTime);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
log_bean_instance_init (LogBean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->_new = 0;
  object->modified = 0;
  object->initialized = 0;
  object->id = 0;
  object->__isset_id = FALSE;
  object->personId = 0;
  object->__isset_personId = FALSE;
  object->deviceId = 0;
  object->__isset_deviceId = FALSE;
  object->verifyFeature = NULL;
  object->__isset_verifyFeature = FALSE;
  object->compareFace = 0;
  object->__isset_compareFace = FALSE;
  object->verifyStatus = 0;
  object->__isset_verifyStatus = FALSE;
  object->similarty = 0;
  object->__isset_similarty = FALSE;
  object->verifyTime = 0;
  object->__isset_verifyTime = FALSE;
  object->createTime = 0;
  object->__isset_createTime = FALSE;
}

static void 
log_bean_finalize (GObject *object)
{
  LogBean *tobject = LOG_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->verifyFeature != NULL)
  {
    g_free(tobject->verifyFeature);
    tobject->verifyFeature = NULL;
  }
}

static void
log_bean_class_init (LogBeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = log_bean_read;
  struct_class->write = log_bean_write;

  gobject_class->finalize = log_bean_finalize;
  gobject_class->get_property = log_bean_get_property;
  gobject_class->set_property = log_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_LOG_BEAN__NEW,
     g_param_spec_boolean ("_new",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOG_BEAN_MODIFIED,
     g_param_spec_int ("modified",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOG_BEAN_INITIALIZED,
     g_param_spec_int ("initialized",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOG_BEAN_ID,
     g_param_spec_int ("id",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOG_BEAN_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOG_BEAN_DEVICE_ID,
     g_param_spec_int ("deviceId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOG_BEAN_VERIFY_FEATURE,
     g_param_spec_string ("verifyFeature",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOG_BEAN_COMPARE_FACE,
     g_param_spec_int ("compareFace",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOG_BEAN_VERIFY_STATUS,
     g_param_spec_int ("verifyStatus",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOG_BEAN_SIMILARTY,
     g_param_spec_double ("similarty",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOG_BEAN_VERIFY_TIME,
     g_param_spec_int64 ("verifyTime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOG_BEAN_CREATE_TIME,
     g_param_spec_int64 ("createTime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
log_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (LogBeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) log_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (LogBean),
      0, /* n_preallocs */
      (GInstanceInitFunc) log_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "LogBeanType",
                                   &type_info, 0);
  }

  return type;
}

enum _DeviceBeanProperties
{
  PROP_DEVICE_BEAN_0,
  PROP_DEVICE_BEAN__NEW,
  PROP_DEVICE_BEAN_MODIFIED,
  PROP_DEVICE_BEAN_INITIALIZED,
  PROP_DEVICE_BEAN_ID,
  PROP_DEVICE_BEAN_GROUP_ID,
  PROP_DEVICE_BEAN_NAME,
  PROP_DEVICE_BEAN_PRODUCT_NAME,
  PROP_DEVICE_BEAN_MODEL,
  PROP_DEVICE_BEAN_VENDOR,
  PROP_DEVICE_BEAN_MANUFACTURER,
  PROP_DEVICE_BEAN_MADE_DATE,
  PROP_DEVICE_BEAN_VERSION,
  PROP_DEVICE_BEAN_USED_SDKS,
  PROP_DEVICE_BEAN_SERIAL_NO,
  PROP_DEVICE_BEAN_MAC,
  PROP_DEVICE_BEAN_REMARK,
  PROP_DEVICE_BEAN_EXT_BIN,
  PROP_DEVICE_BEAN_EXT_TXT,
  PROP_DEVICE_BEAN_CREATE_TIME,
  PROP_DEVICE_BEAN_UPDATE_TIME
};

/* reads a device_bean object */
static gint32
device_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DeviceBean * this_object = DEVICE_BEAN(object);
  gboolean isset__new = FALSE;
  gboolean isset_modified = FALSE;
  gboolean isset_initialized = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->_new, error)) < 0)
            return -1;
          xfer += ret;
          isset__new = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->modified, error)) < 0)
            return -1;
          xfer += ret;
          isset_modified = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->initialized, error)) < 0)
            return -1;
          xfer += ret;
          isset_initialized = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->groupId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_groupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->productName != NULL)
          {
            g_free(this_object->productName);
            this_object->productName = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->productName, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_productName = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRING)
        {
          if (this_object->model != NULL)
          {
            g_free(this_object->model);
            this_object->model = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->model, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_model = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRING)
        {
          if (this_object->vendor != NULL)
          {
            g_free(this_object->vendor);
            this_object->vendor = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->vendor, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_vendor = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_STRING)
        {
          if (this_object->manufacturer != NULL)
          {
            g_free(this_object->manufacturer);
            this_object->manufacturer = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->manufacturer, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_manufacturer = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->madeDate, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_madeDate = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_STRING)
        {
          if (this_object->version != NULL)
          {
            g_free(this_object->version);
            this_object->version = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->version, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_version = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_STRING)
        {
          if (this_object->usedSdks != NULL)
          {
            g_free(this_object->usedSdks);
            this_object->usedSdks = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->usedSdks, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_usedSdks = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 14:
        if (ftype == T_STRING)
        {
          if (this_object->serialNo != NULL)
          {
            g_free(this_object->serialNo);
            this_object->serialNo = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->serialNo, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_serialNo = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 15:
        if (ftype == T_STRING)
        {
          if (this_object->mac != NULL)
          {
            g_free(this_object->mac);
            this_object->mac = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->mac, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_mac = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 16:
        if (ftype == T_STRING)
        {
          if (this_object->remark != NULL)
          {
            g_free(this_object->remark);
            this_object->remark = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->remark, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_remark = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 17:
        if (ftype == T_STRING)
        {
          if (this_object->extBin != NULL)
          {
            g_free(this_object->extBin);
            this_object->extBin = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->extBin = g_byte_array_new();
          g_byte_array_append (this_object->extBin, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_extBin = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 18:
        if (ftype == T_STRING)
        {
          if (this_object->extTxt != NULL)
          {
            g_free(this_object->extTxt);
            this_object->extTxt = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->extTxt, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_extTxt = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 19:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->createTime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_createTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 20:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->updateTime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_updateTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset__new)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_modified)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_initialized)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
device_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DeviceBean * this_object = DEVICE_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DeviceBean", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "_new", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->_new, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "modified", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->modified, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "initialized", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->initialized, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_id == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->id, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_groupId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "groupId", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->groupId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_name == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_productName == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "productName", T_STRING, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->productName, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_model == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "model", T_STRING, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->model, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_vendor == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "vendor", T_STRING, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->vendor, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_manufacturer == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "manufacturer", T_STRING, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->manufacturer, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_madeDate == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "madeDate", T_I64, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->madeDate, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_version == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "version", T_STRING, 12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->version, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_usedSdks == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "usedSdks", T_STRING, 13, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->usedSdks, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_serialNo == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "serialNo", T_STRING, 14, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->serialNo, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_mac == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "mac", T_STRING, 15, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->mac, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_remark == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "remark", T_STRING, 16, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->remark, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extBin == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extBin", T_STRING, 17, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->extBin ? ((GByteArray *) this_object->extBin)->data : NULL, this_object->extBin ? ((GByteArray *) this_object->extBin)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extTxt == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extTxt", T_STRING, 18, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->extTxt, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_createTime == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "createTime", T_I64, 19, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->createTime, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_updateTime == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "updateTime", T_I64, 20, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->updateTime, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
device_bean_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  DeviceBean *self = DEVICE_BEAN (object);

  switch (property_id)
  {
    case PROP_DEVICE_BEAN__NEW:
      self->_new = g_value_get_boolean (value);
      break;

    case PROP_DEVICE_BEAN_MODIFIED:
      self->modified = g_value_get_int (value);
      break;

    case PROP_DEVICE_BEAN_INITIALIZED:
      self->initialized = g_value_get_int (value);
      break;

    case PROP_DEVICE_BEAN_ID:
      self->id = g_value_get_int (value);
      self->__isset_id = TRUE;
      break;

    case PROP_DEVICE_BEAN_GROUP_ID:
      self->groupId = g_value_get_int (value);
      self->__isset_groupId = TRUE;
      break;

    case PROP_DEVICE_BEAN_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_DEVICE_BEAN_PRODUCT_NAME:
      if (self->productName != NULL)
        g_free (self->productName);
      self->productName = g_value_dup_string (value);
      self->__isset_productName = TRUE;
      break;

    case PROP_DEVICE_BEAN_MODEL:
      if (self->model != NULL)
        g_free (self->model);
      self->model = g_value_dup_string (value);
      self->__isset_model = TRUE;
      break;

    case PROP_DEVICE_BEAN_VENDOR:
      if (self->vendor != NULL)
        g_free (self->vendor);
      self->vendor = g_value_dup_string (value);
      self->__isset_vendor = TRUE;
      break;

    case PROP_DEVICE_BEAN_MANUFACTURER:
      if (self->manufacturer != NULL)
        g_free (self->manufacturer);
      self->manufacturer = g_value_dup_string (value);
      self->__isset_manufacturer = TRUE;
      break;

    case PROP_DEVICE_BEAN_MADE_DATE:
      self->madeDate = g_value_get_int64 (value);
      self->__isset_madeDate = TRUE;
      break;

    case PROP_DEVICE_BEAN_VERSION:
      if (self->version != NULL)
        g_free (self->version);
      self->version = g_value_dup_string (value);
      self->__isset_version = TRUE;
      break;

    case PROP_DEVICE_BEAN_USED_SDKS:
      if (self->usedSdks != NULL)
        g_free (self->usedSdks);
      self->usedSdks = g_value_dup_string (value);
      self->__isset_usedSdks = TRUE;
      break;

    case PROP_DEVICE_BEAN_SERIAL_NO:
      if (self->serialNo != NULL)
        g_free (self->serialNo);
      self->serialNo = g_value_dup_string (value);
      self->__isset_serialNo = TRUE;
      break;

    case PROP_DEVICE_BEAN_MAC:
      if (self->mac != NULL)
        g_free (self->mac);
      self->mac = g_value_dup_string (value);
      self->__isset_mac = TRUE;
      break;

    case PROP_DEVICE_BEAN_REMARK:
      if (self->remark != NULL)
        g_free (self->remark);
      self->remark = g_value_dup_string (value);
      self->__isset_remark = TRUE;
      break;

    case PROP_DEVICE_BEAN_EXT_BIN:
      if (self->extBin != NULL)
        g_byte_array_unref (self->extBin);
      self->extBin = g_value_dup_boxed (value);
      self->__isset_extBin = TRUE;
      break;

    case PROP_DEVICE_BEAN_EXT_TXT:
      if (self->extTxt != NULL)
        g_free (self->extTxt);
      self->extTxt = g_value_dup_string (value);
      self->__isset_extTxt = TRUE;
      break;

    case PROP_DEVICE_BEAN_CREATE_TIME:
      self->createTime = g_value_get_int64 (value);
      self->__isset_createTime = TRUE;
      break;

    case PROP_DEVICE_BEAN_UPDATE_TIME:
      self->updateTime = g_value_get_int64 (value);
      self->__isset_updateTime = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
device_bean_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  DeviceBean *self = DEVICE_BEAN (object);

  switch (property_id)
  {
    case PROP_DEVICE_BEAN__NEW:
      g_value_set_boolean (value, self->_new);
      break;

    case PROP_DEVICE_BEAN_MODIFIED:
      g_value_set_int (value, self->modified);
      break;

    case PROP_DEVICE_BEAN_INITIALIZED:
      g_value_set_int (value, self->initialized);
      break;

    case PROP_DEVICE_BEAN_ID:
      g_value_set_int (value, self->id);
      break;

    case PROP_DEVICE_BEAN_GROUP_ID:
      g_value_set_int (value, self->groupId);
      break;

    case PROP_DEVICE_BEAN_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_DEVICE_BEAN_PRODUCT_NAME:
      g_value_set_string (value, self->productName);
      break;

    case PROP_DEVICE_BEAN_MODEL:
      g_value_set_string (value, self->model);
      break;

    case PROP_DEVICE_BEAN_VENDOR:
      g_value_set_string (value, self->vendor);
      break;

    case PROP_DEVICE_BEAN_MANUFACTURER:
      g_value_set_string (value, self->manufacturer);
      break;

    case PROP_DEVICE_BEAN_MADE_DATE:
      g_value_set_int64 (value, self->madeDate);
      break;

    case PROP_DEVICE_BEAN_VERSION:
      g_value_set_string (value, self->version);
      break;

    case PROP_DEVICE_BEAN_USED_SDKS:
      g_value_set_string (value, self->usedSdks);
      break;

    case PROP_DEVICE_BEAN_SERIAL_NO:
      g_value_set_string (value, self->serialNo);
      break;

    case PROP_DEVICE_BEAN_MAC:
      g_value_set_string (value, self->mac);
      break;

    case PROP_DEVICE_BEAN_REMARK:
      g_value_set_string (value, self->remark);
      break;

    case PROP_DEVICE_BEAN_EXT_BIN:
      g_value_set_boxed (value, self->extBin);
      break;

    case PROP_DEVICE_BEAN_EXT_TXT:
      g_value_set_string (value, self->extTxt);
      break;

    case PROP_DEVICE_BEAN_CREATE_TIME:
      g_value_set_int64 (value, self->createTime);
      break;

    case PROP_DEVICE_BEAN_UPDATE_TIME:
      g_value_set_int64 (value, self->updateTime);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
device_bean_instance_init (DeviceBean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->_new = 0;
  object->modified = 0;
  object->initialized = 0;
  object->id = 0;
  object->__isset_id = FALSE;
  object->groupId = 0;
  object->__isset_groupId = FALSE;
  object->name = NULL;
  object->__isset_name = FALSE;
  object->productName = NULL;
  object->__isset_productName = FALSE;
  object->model = NULL;
  object->__isset_model = FALSE;
  object->vendor = NULL;
  object->__isset_vendor = FALSE;
  object->manufacturer = NULL;
  object->__isset_manufacturer = FALSE;
  object->madeDate = 0;
  object->__isset_madeDate = FALSE;
  object->version = NULL;
  object->__isset_version = FALSE;
  object->usedSdks = NULL;
  object->__isset_usedSdks = FALSE;
  object->serialNo = NULL;
  object->__isset_serialNo = FALSE;
  object->mac = NULL;
  object->__isset_mac = FALSE;
  object->remark = NULL;
  object->__isset_remark = FALSE;
  object->extBin = NULL;
  object->__isset_extBin = FALSE;
  object->extTxt = NULL;
  object->__isset_extTxt = FALSE;
  object->createTime = 0;
  object->__isset_createTime = FALSE;
  object->updateTime = 0;
  object->__isset_updateTime = FALSE;
}

static void 
device_bean_finalize (GObject *object)
{
  DeviceBean *tobject = DEVICE_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->productName != NULL)
  {
    g_free(tobject->productName);
    tobject->productName = NULL;
  }
  if (tobject->model != NULL)
  {
    g_free(tobject->model);
    tobject->model = NULL;
  }
  if (tobject->vendor != NULL)
  {
    g_free(tobject->vendor);
    tobject->vendor = NULL;
  }
  if (tobject->manufacturer != NULL)
  {
    g_free(tobject->manufacturer);
    tobject->manufacturer = NULL;
  }
  if (tobject->version != NULL)
  {
    g_free(tobject->version);
    tobject->version = NULL;
  }
  if (tobject->usedSdks != NULL)
  {
    g_free(tobject->usedSdks);
    tobject->usedSdks = NULL;
  }
  if (tobject->serialNo != NULL)
  {
    g_free(tobject->serialNo);
    tobject->serialNo = NULL;
  }
  if (tobject->mac != NULL)
  {
    g_free(tobject->mac);
    tobject->mac = NULL;
  }
  if (tobject->remark != NULL)
  {
    g_free(tobject->remark);
    tobject->remark = NULL;
  }
  if (tobject->extBin != NULL)
  {
    thrift_string_free(tobject->extBin);
    tobject->extBin = NULL;
  }
  if (tobject->extTxt != NULL)
  {
    g_free(tobject->extTxt);
    tobject->extTxt = NULL;
  }
}

static void
device_bean_class_init (DeviceBeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = device_bean_read;
  struct_class->write = device_bean_write;

  gobject_class->finalize = device_bean_finalize;
  gobject_class->get_property = device_bean_get_property;
  gobject_class->set_property = device_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_BEAN__NEW,
     g_param_spec_boolean ("_new",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_BEAN_MODIFIED,
     g_param_spec_int ("modified",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_BEAN_INITIALIZED,
     g_param_spec_int ("initialized",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_BEAN_ID,
     g_param_spec_int ("id",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_BEAN_GROUP_ID,
     g_param_spec_int ("groupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_BEAN_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_BEAN_PRODUCT_NAME,
     g_param_spec_string ("productName",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_BEAN_MODEL,
     g_param_spec_string ("model",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_BEAN_VENDOR,
     g_param_spec_string ("vendor",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_BEAN_MANUFACTURER,
     g_param_spec_string ("manufacturer",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_BEAN_MADE_DATE,
     g_param_spec_int64 ("madeDate",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_BEAN_VERSION,
     g_param_spec_string ("version",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_BEAN_USED_SDKS,
     g_param_spec_string ("usedSdks",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_BEAN_SERIAL_NO,
     g_param_spec_string ("serialNo",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_BEAN_MAC,
     g_param_spec_string ("mac",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_BEAN_REMARK,
     g_param_spec_string ("remark",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_BEAN_EXT_BIN,
     g_param_spec_boxed ("extBin",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_BEAN_EXT_TXT,
     g_param_spec_string ("extTxt",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_BEAN_CREATE_TIME,
     g_param_spec_int64 ("createTime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_BEAN_UPDATE_TIME,
     g_param_spec_int64 ("updateTime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
device_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DeviceBeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) device_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DeviceBean),
      0, /* n_preallocs */
      (GInstanceInitFunc) device_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DeviceBeanType",
                                   &type_info, 0);
  }

  return type;
}

enum _DeviceGroupBeanProperties
{
  PROP_DEVICE_GROUP_BEAN_0,
  PROP_DEVICE_GROUP_BEAN__NEW,
  PROP_DEVICE_GROUP_BEAN_MODIFIED,
  PROP_DEVICE_GROUP_BEAN_INITIALIZED,
  PROP_DEVICE_GROUP_BEAN_ID,
  PROP_DEVICE_GROUP_BEAN_NAME,
  PROP_DEVICE_GROUP_BEAN_LEAF,
  PROP_DEVICE_GROUP_BEAN_PARENT,
  PROP_DEVICE_GROUP_BEAN_ROOT_GROUP,
  PROP_DEVICE_GROUP_BEAN_SCHEDULE,
  PROP_DEVICE_GROUP_BEAN_REMARK,
  PROP_DEVICE_GROUP_BEAN_EXT_BIN,
  PROP_DEVICE_GROUP_BEAN_EXT_TXT,
  PROP_DEVICE_GROUP_BEAN_CREATE_TIME,
  PROP_DEVICE_GROUP_BEAN_UPDATE_TIME
};

/* reads a device_group_bean object */
static gint32
device_group_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  DeviceGroupBean * this_object = DEVICE_GROUP_BEAN(object);
  gboolean isset__new = FALSE;
  gboolean isset_modified = FALSE;
  gboolean isset_initialized = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->_new, error)) < 0)
            return -1;
          xfer += ret;
          isset__new = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->modified, error)) < 0)
            return -1;
          xfer += ret;
          isset_modified = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->initialized, error)) < 0)
            return -1;
          xfer += ret;
          isset_initialized = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->leaf, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_leaf = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->parent, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_parent = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->rootGroup, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rootGroup = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRING)
        {
          if (this_object->schedule != NULL)
          {
            g_free(this_object->schedule);
            this_object->schedule = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->schedule, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_schedule = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_STRING)
        {
          if (this_object->remark != NULL)
          {
            g_free(this_object->remark);
            this_object->remark = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->remark, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_remark = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRING)
        {
          if (this_object->extBin != NULL)
          {
            g_free(this_object->extBin);
            this_object->extBin = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->extBin = g_byte_array_new();
          g_byte_array_append (this_object->extBin, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_extBin = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_STRING)
        {
          if (this_object->extTxt != NULL)
          {
            g_free(this_object->extTxt);
            this_object->extTxt = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->extTxt, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_extTxt = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->createTime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_createTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 14:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->updateTime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_updateTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset__new)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_modified)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_initialized)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
device_group_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  DeviceGroupBean * this_object = DEVICE_GROUP_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "DeviceGroupBean", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "_new", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->_new, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "modified", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->modified, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "initialized", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->initialized, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_id == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->id, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_name == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_leaf == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "leaf", T_I32, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->leaf, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_parent == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "parent", T_I32, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->parent, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_rootGroup == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "rootGroup", T_I32, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->rootGroup, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_schedule == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "schedule", T_STRING, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->schedule, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_remark == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "remark", T_STRING, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->remark, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extBin == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extBin", T_STRING, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->extBin ? ((GByteArray *) this_object->extBin)->data : NULL, this_object->extBin ? ((GByteArray *) this_object->extBin)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extTxt == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extTxt", T_STRING, 12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->extTxt, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_createTime == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "createTime", T_I64, 13, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->createTime, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_updateTime == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "updateTime", T_I64, 14, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->updateTime, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
device_group_bean_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  DeviceGroupBean *self = DEVICE_GROUP_BEAN (object);

  switch (property_id)
  {
    case PROP_DEVICE_GROUP_BEAN__NEW:
      self->_new = g_value_get_boolean (value);
      break;

    case PROP_DEVICE_GROUP_BEAN_MODIFIED:
      self->modified = g_value_get_int (value);
      break;

    case PROP_DEVICE_GROUP_BEAN_INITIALIZED:
      self->initialized = g_value_get_int (value);
      break;

    case PROP_DEVICE_GROUP_BEAN_ID:
      self->id = g_value_get_int (value);
      self->__isset_id = TRUE;
      break;

    case PROP_DEVICE_GROUP_BEAN_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_DEVICE_GROUP_BEAN_LEAF:
      self->leaf = g_value_get_int (value);
      self->__isset_leaf = TRUE;
      break;

    case PROP_DEVICE_GROUP_BEAN_PARENT:
      self->parent = g_value_get_int (value);
      self->__isset_parent = TRUE;
      break;

    case PROP_DEVICE_GROUP_BEAN_ROOT_GROUP:
      self->rootGroup = g_value_get_int (value);
      self->__isset_rootGroup = TRUE;
      break;

    case PROP_DEVICE_GROUP_BEAN_SCHEDULE:
      if (self->schedule != NULL)
        g_free (self->schedule);
      self->schedule = g_value_dup_string (value);
      self->__isset_schedule = TRUE;
      break;

    case PROP_DEVICE_GROUP_BEAN_REMARK:
      if (self->remark != NULL)
        g_free (self->remark);
      self->remark = g_value_dup_string (value);
      self->__isset_remark = TRUE;
      break;

    case PROP_DEVICE_GROUP_BEAN_EXT_BIN:
      if (self->extBin != NULL)
        g_byte_array_unref (self->extBin);
      self->extBin = g_value_dup_boxed (value);
      self->__isset_extBin = TRUE;
      break;

    case PROP_DEVICE_GROUP_BEAN_EXT_TXT:
      if (self->extTxt != NULL)
        g_free (self->extTxt);
      self->extTxt = g_value_dup_string (value);
      self->__isset_extTxt = TRUE;
      break;

    case PROP_DEVICE_GROUP_BEAN_CREATE_TIME:
      self->createTime = g_value_get_int64 (value);
      self->__isset_createTime = TRUE;
      break;

    case PROP_DEVICE_GROUP_BEAN_UPDATE_TIME:
      self->updateTime = g_value_get_int64 (value);
      self->__isset_updateTime = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
device_group_bean_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  DeviceGroupBean *self = DEVICE_GROUP_BEAN (object);

  switch (property_id)
  {
    case PROP_DEVICE_GROUP_BEAN__NEW:
      g_value_set_boolean (value, self->_new);
      break;

    case PROP_DEVICE_GROUP_BEAN_MODIFIED:
      g_value_set_int (value, self->modified);
      break;

    case PROP_DEVICE_GROUP_BEAN_INITIALIZED:
      g_value_set_int (value, self->initialized);
      break;

    case PROP_DEVICE_GROUP_BEAN_ID:
      g_value_set_int (value, self->id);
      break;

    case PROP_DEVICE_GROUP_BEAN_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_DEVICE_GROUP_BEAN_LEAF:
      g_value_set_int (value, self->leaf);
      break;

    case PROP_DEVICE_GROUP_BEAN_PARENT:
      g_value_set_int (value, self->parent);
      break;

    case PROP_DEVICE_GROUP_BEAN_ROOT_GROUP:
      g_value_set_int (value, self->rootGroup);
      break;

    case PROP_DEVICE_GROUP_BEAN_SCHEDULE:
      g_value_set_string (value, self->schedule);
      break;

    case PROP_DEVICE_GROUP_BEAN_REMARK:
      g_value_set_string (value, self->remark);
      break;

    case PROP_DEVICE_GROUP_BEAN_EXT_BIN:
      g_value_set_boxed (value, self->extBin);
      break;

    case PROP_DEVICE_GROUP_BEAN_EXT_TXT:
      g_value_set_string (value, self->extTxt);
      break;

    case PROP_DEVICE_GROUP_BEAN_CREATE_TIME:
      g_value_set_int64 (value, self->createTime);
      break;

    case PROP_DEVICE_GROUP_BEAN_UPDATE_TIME:
      g_value_set_int64 (value, self->updateTime);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
device_group_bean_instance_init (DeviceGroupBean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->_new = 0;
  object->modified = 0;
  object->initialized = 0;
  object->id = 0;
  object->__isset_id = FALSE;
  object->name = NULL;
  object->__isset_name = FALSE;
  object->leaf = 0;
  object->__isset_leaf = FALSE;
  object->parent = 0;
  object->__isset_parent = FALSE;
  object->rootGroup = 0;
  object->__isset_rootGroup = FALSE;
  object->schedule = NULL;
  object->__isset_schedule = FALSE;
  object->remark = NULL;
  object->__isset_remark = FALSE;
  object->extBin = NULL;
  object->__isset_extBin = FALSE;
  object->extTxt = NULL;
  object->__isset_extTxt = FALSE;
  object->createTime = 0;
  object->__isset_createTime = FALSE;
  object->updateTime = 0;
  object->__isset_updateTime = FALSE;
}

static void 
device_group_bean_finalize (GObject *object)
{
  DeviceGroupBean *tobject = DEVICE_GROUP_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->schedule != NULL)
  {
    g_free(tobject->schedule);
    tobject->schedule = NULL;
  }
  if (tobject->remark != NULL)
  {
    g_free(tobject->remark);
    tobject->remark = NULL;
  }
  if (tobject->extBin != NULL)
  {
    thrift_string_free(tobject->extBin);
    tobject->extBin = NULL;
  }
  if (tobject->extTxt != NULL)
  {
    g_free(tobject->extTxt);
    tobject->extTxt = NULL;
  }
}

static void
device_group_bean_class_init (DeviceGroupBeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = device_group_bean_read;
  struct_class->write = device_group_bean_write;

  gobject_class->finalize = device_group_bean_finalize;
  gobject_class->get_property = device_group_bean_get_property;
  gobject_class->set_property = device_group_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_GROUP_BEAN__NEW,
     g_param_spec_boolean ("_new",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_GROUP_BEAN_MODIFIED,
     g_param_spec_int ("modified",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_GROUP_BEAN_INITIALIZED,
     g_param_spec_int ("initialized",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_GROUP_BEAN_ID,
     g_param_spec_int ("id",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_GROUP_BEAN_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_GROUP_BEAN_LEAF,
     g_param_spec_int ("leaf",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_GROUP_BEAN_PARENT,
     g_param_spec_int ("parent",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_GROUP_BEAN_ROOT_GROUP,
     g_param_spec_int ("rootGroup",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_GROUP_BEAN_SCHEDULE,
     g_param_spec_string ("schedule",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_GROUP_BEAN_REMARK,
     g_param_spec_string ("remark",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_GROUP_BEAN_EXT_BIN,
     g_param_spec_boxed ("extBin",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_GROUP_BEAN_EXT_TXT,
     g_param_spec_string ("extTxt",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_GROUP_BEAN_CREATE_TIME,
     g_param_spec_int64 ("createTime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_DEVICE_GROUP_BEAN_UPDATE_TIME,
     g_param_spec_int64 ("updateTime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
device_group_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (DeviceGroupBeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) device_group_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (DeviceGroupBean),
      0, /* n_preallocs */
      (GInstanceInitFunc) device_group_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "DeviceGroupBeanType",
                                   &type_info, 0);
  }

  return type;
}

enum _PermitBeanProperties
{
  PROP_PERMIT_BEAN_0,
  PROP_PERMIT_BEAN__NEW,
  PROP_PERMIT_BEAN_MODIFIED,
  PROP_PERMIT_BEAN_INITIALIZED,
  PROP_PERMIT_BEAN_DEVICE_GROUP_ID,
  PROP_PERMIT_BEAN_PERSON_GROUP_ID,
  PROP_PERMIT_BEAN_SCHEDULE,
  PROP_PERMIT_BEAN_REMARK,
  PROP_PERMIT_BEAN_EXT_BIN,
  PROP_PERMIT_BEAN_EXT_TXT,
  PROP_PERMIT_BEAN_CREATE_TIME
};

/* reads a permit_bean object */
static gint32
permit_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  PermitBean * this_object = PERMIT_BEAN(object);
  gboolean isset__new = FALSE;
  gboolean isset_modified = FALSE;
  gboolean isset_initialized = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->_new, error)) < 0)
            return -1;
          xfer += ret;
          isset__new = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->modified, error)) < 0)
            return -1;
          xfer += ret;
          isset_modified = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->initialized, error)) < 0)
            return -1;
          xfer += ret;
          isset_initialized = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceGroupId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_deviceGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personGroupId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_personGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->schedule != NULL)
          {
            g_free(this_object->schedule);
            this_object->schedule = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->schedule, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_schedule = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRING)
        {
          if (this_object->remark != NULL)
          {
            g_free(this_object->remark);
            this_object->remark = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->remark, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_remark = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRING)
        {
          if (this_object->extBin != NULL)
          {
            g_free(this_object->extBin);
            this_object->extBin = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->extBin = g_byte_array_new();
          g_byte_array_append (this_object->extBin, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_extBin = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRING)
        {
          if (this_object->extTxt != NULL)
          {
            g_free(this_object->extTxt);
            this_object->extTxt = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->extTxt, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_extTxt = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->createTime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_createTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset__new)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_modified)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_initialized)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
permit_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  PermitBean * this_object = PERMIT_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PermitBean", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "_new", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->_new, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "modified", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->modified, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "initialized", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->initialized, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_deviceGroupId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceGroupId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_personGroupId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->personGroupId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_schedule == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "schedule", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->schedule, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_remark == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "remark", T_STRING, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->remark, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extBin == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extBin", T_STRING, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->extBin ? ((GByteArray *) this_object->extBin)->data : NULL, this_object->extBin ? ((GByteArray *) this_object->extBin)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extTxt == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extTxt", T_STRING, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->extTxt, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_createTime == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "createTime", T_I64, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->createTime, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
permit_bean_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  PermitBean *self = PERMIT_BEAN (object);

  switch (property_id)
  {
    case PROP_PERMIT_BEAN__NEW:
      self->_new = g_value_get_boolean (value);
      break;

    case PROP_PERMIT_BEAN_MODIFIED:
      self->modified = g_value_get_int (value);
      break;

    case PROP_PERMIT_BEAN_INITIALIZED:
      self->initialized = g_value_get_int (value);
      break;

    case PROP_PERMIT_BEAN_DEVICE_GROUP_ID:
      self->deviceGroupId = g_value_get_int (value);
      self->__isset_deviceGroupId = TRUE;
      break;

    case PROP_PERMIT_BEAN_PERSON_GROUP_ID:
      self->personGroupId = g_value_get_int (value);
      self->__isset_personGroupId = TRUE;
      break;

    case PROP_PERMIT_BEAN_SCHEDULE:
      if (self->schedule != NULL)
        g_free (self->schedule);
      self->schedule = g_value_dup_string (value);
      self->__isset_schedule = TRUE;
      break;

    case PROP_PERMIT_BEAN_REMARK:
      if (self->remark != NULL)
        g_free (self->remark);
      self->remark = g_value_dup_string (value);
      self->__isset_remark = TRUE;
      break;

    case PROP_PERMIT_BEAN_EXT_BIN:
      if (self->extBin != NULL)
        g_byte_array_unref (self->extBin);
      self->extBin = g_value_dup_boxed (value);
      self->__isset_extBin = TRUE;
      break;

    case PROP_PERMIT_BEAN_EXT_TXT:
      if (self->extTxt != NULL)
        g_free (self->extTxt);
      self->extTxt = g_value_dup_string (value);
      self->__isset_extTxt = TRUE;
      break;

    case PROP_PERMIT_BEAN_CREATE_TIME:
      self->createTime = g_value_get_int64 (value);
      self->__isset_createTime = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
permit_bean_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  PermitBean *self = PERMIT_BEAN (object);

  switch (property_id)
  {
    case PROP_PERMIT_BEAN__NEW:
      g_value_set_boolean (value, self->_new);
      break;

    case PROP_PERMIT_BEAN_MODIFIED:
      g_value_set_int (value, self->modified);
      break;

    case PROP_PERMIT_BEAN_INITIALIZED:
      g_value_set_int (value, self->initialized);
      break;

    case PROP_PERMIT_BEAN_DEVICE_GROUP_ID:
      g_value_set_int (value, self->deviceGroupId);
      break;

    case PROP_PERMIT_BEAN_PERSON_GROUP_ID:
      g_value_set_int (value, self->personGroupId);
      break;

    case PROP_PERMIT_BEAN_SCHEDULE:
      g_value_set_string (value, self->schedule);
      break;

    case PROP_PERMIT_BEAN_REMARK:
      g_value_set_string (value, self->remark);
      break;

    case PROP_PERMIT_BEAN_EXT_BIN:
      g_value_set_boxed (value, self->extBin);
      break;

    case PROP_PERMIT_BEAN_EXT_TXT:
      g_value_set_string (value, self->extTxt);
      break;

    case PROP_PERMIT_BEAN_CREATE_TIME:
      g_value_set_int64 (value, self->createTime);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
permit_bean_instance_init (PermitBean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->_new = 0;
  object->modified = 0;
  object->initialized = 0;
  object->deviceGroupId = 0;
  object->__isset_deviceGroupId = FALSE;
  object->personGroupId = 0;
  object->__isset_personGroupId = FALSE;
  object->schedule = NULL;
  object->__isset_schedule = FALSE;
  object->remark = NULL;
  object->__isset_remark = FALSE;
  object->extBin = NULL;
  object->__isset_extBin = FALSE;
  object->extTxt = NULL;
  object->__isset_extTxt = FALSE;
  object->createTime = 0;
  object->__isset_createTime = FALSE;
}

static void 
permit_bean_finalize (GObject *object)
{
  PermitBean *tobject = PERMIT_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->schedule != NULL)
  {
    g_free(tobject->schedule);
    tobject->schedule = NULL;
  }
  if (tobject->remark != NULL)
  {
    g_free(tobject->remark);
    tobject->remark = NULL;
  }
  if (tobject->extBin != NULL)
  {
    thrift_string_free(tobject->extBin);
    tobject->extBin = NULL;
  }
  if (tobject->extTxt != NULL)
  {
    g_free(tobject->extTxt);
    tobject->extTxt = NULL;
  }
}

static void
permit_bean_class_init (PermitBeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = permit_bean_read;
  struct_class->write = permit_bean_write;

  gobject_class->finalize = permit_bean_finalize;
  gobject_class->get_property = permit_bean_get_property;
  gobject_class->set_property = permit_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PERMIT_BEAN__NEW,
     g_param_spec_boolean ("_new",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERMIT_BEAN_MODIFIED,
     g_param_spec_int ("modified",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERMIT_BEAN_INITIALIZED,
     g_param_spec_int ("initialized",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERMIT_BEAN_DEVICE_GROUP_ID,
     g_param_spec_int ("deviceGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERMIT_BEAN_PERSON_GROUP_ID,
     g_param_spec_int ("personGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERMIT_BEAN_SCHEDULE,
     g_param_spec_string ("schedule",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERMIT_BEAN_REMARK,
     g_param_spec_string ("remark",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERMIT_BEAN_EXT_BIN,
     g_param_spec_boxed ("extBin",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERMIT_BEAN_EXT_TXT,
     g_param_spec_string ("extTxt",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERMIT_BEAN_CREATE_TIME,
     g_param_spec_int64 ("createTime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
permit_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (PermitBeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) permit_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (PermitBean),
      0, /* n_preallocs */
      (GInstanceInitFunc) permit_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "PermitBeanType",
                                   &type_info, 0);
  }

  return type;
}

enum _PersonBeanProperties
{
  PROP_PERSON_BEAN_0,
  PROP_PERSON_BEAN__NEW,
  PROP_PERSON_BEAN_MODIFIED,
  PROP_PERSON_BEAN_INITIALIZED,
  PROP_PERSON_BEAN_ID,
  PROP_PERSON_BEAN_GROUP_ID,
  PROP_PERSON_BEAN_NAME,
  PROP_PERSON_BEAN_SEX,
  PROP_PERSON_BEAN_RANK,
  PROP_PERSON_BEAN_PASSWORD,
  PROP_PERSON_BEAN_BIRTHDATE,
  PROP_PERSON_BEAN_MOBILE_PHONE,
  PROP_PERSON_BEAN_PAPERS_TYPE,
  PROP_PERSON_BEAN_PAPERS_NUM,
  PROP_PERSON_BEAN_IMAGE_MD5,
  PROP_PERSON_BEAN_EXPIRY_DATE,
  PROP_PERSON_BEAN_REMARK,
  PROP_PERSON_BEAN_EXT_BIN,
  PROP_PERSON_BEAN_EXT_TXT,
  PROP_PERSON_BEAN_CREATE_TIME,
  PROP_PERSON_BEAN_UPDATE_TIME
};

/* reads a person_bean object */
static gint32
person_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  PersonBean * this_object = PERSON_BEAN(object);
  gboolean isset__new = FALSE;
  gboolean isset_modified = FALSE;
  gboolean isset_initialized = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->_new, error)) < 0)
            return -1;
          xfer += ret;
          isset__new = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->modified, error)) < 0)
            return -1;
          xfer += ret;
          isset_modified = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->initialized, error)) < 0)
            return -1;
          xfer += ret;
          isset_initialized = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->groupId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_groupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->sex, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sex = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->rank, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rank = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRING)
        {
          if (this_object->password != NULL)
          {
            g_free(this_object->password);
            this_object->password = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->password, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_password = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->birthdate, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_birthdate = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRING)
        {
          if (this_object->mobilePhone != NULL)
          {
            g_free(this_object->mobilePhone);
            this_object->mobilePhone = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->mobilePhone, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_mobilePhone = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->papersType, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_papersType = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_STRING)
        {
          if (this_object->papersNum != NULL)
          {
            g_free(this_object->papersNum);
            this_object->papersNum = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->papersNum, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_papersNum = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 14:
        if (ftype == T_STRING)
        {
          if (this_object->imageMd5 != NULL)
          {
            g_free(this_object->imageMd5);
            this_object->imageMd5 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->imageMd5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_imageMd5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 15:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->expiryDate, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_expiryDate = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 16:
        if (ftype == T_STRING)
        {
          if (this_object->remark != NULL)
          {
            g_free(this_object->remark);
            this_object->remark = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->remark, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_remark = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 17:
        if (ftype == T_STRING)
        {
          if (this_object->extBin != NULL)
          {
            g_free(this_object->extBin);
            this_object->extBin = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->extBin = g_byte_array_new();
          g_byte_array_append (this_object->extBin, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_extBin = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 18:
        if (ftype == T_STRING)
        {
          if (this_object->extTxt != NULL)
          {
            g_free(this_object->extTxt);
            this_object->extTxt = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->extTxt, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_extTxt = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 19:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->createTime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_createTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 20:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->updateTime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_updateTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset__new)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_modified)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_initialized)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
person_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  PersonBean * this_object = PERSON_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PersonBean", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "_new", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->_new, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "modified", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->modified, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "initialized", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->initialized, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_id == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->id, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_groupId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "groupId", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->groupId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_name == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_sex == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "sex", T_I32, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->sex, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_rank == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "rank", T_I32, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->rank, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_password == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "password", T_STRING, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->password, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_birthdate == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "birthdate", T_I64, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->birthdate, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_mobilePhone == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "mobilePhone", T_STRING, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->mobilePhone, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_papersType == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "papersType", T_I32, 12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->papersType, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_papersNum == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "papersNum", T_STRING, 13, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->papersNum, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_imageMd5 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "imageMd5", T_STRING, 14, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->imageMd5, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_expiryDate == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "expiryDate", T_I64, 15, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->expiryDate, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_remark == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "remark", T_STRING, 16, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->remark, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extBin == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extBin", T_STRING, 17, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->extBin ? ((GByteArray *) this_object->extBin)->data : NULL, this_object->extBin ? ((GByteArray *) this_object->extBin)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extTxt == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extTxt", T_STRING, 18, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->extTxt, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_createTime == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "createTime", T_I64, 19, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->createTime, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_updateTime == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "updateTime", T_I64, 20, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->updateTime, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
person_bean_set_property (GObject *object,
                          guint property_id,
                          const GValue *value,
                          GParamSpec *pspec)
{
  PersonBean *self = PERSON_BEAN (object);

  switch (property_id)
  {
    case PROP_PERSON_BEAN__NEW:
      self->_new = g_value_get_boolean (value);
      break;

    case PROP_PERSON_BEAN_MODIFIED:
      self->modified = g_value_get_int (value);
      break;

    case PROP_PERSON_BEAN_INITIALIZED:
      self->initialized = g_value_get_int (value);
      break;

    case PROP_PERSON_BEAN_ID:
      self->id = g_value_get_int (value);
      self->__isset_id = TRUE;
      break;

    case PROP_PERSON_BEAN_GROUP_ID:
      self->groupId = g_value_get_int (value);
      self->__isset_groupId = TRUE;
      break;

    case PROP_PERSON_BEAN_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_PERSON_BEAN_SEX:
      self->sex = g_value_get_int (value);
      self->__isset_sex = TRUE;
      break;

    case PROP_PERSON_BEAN_RANK:
      self->rank = g_value_get_int (value);
      self->__isset_rank = TRUE;
      break;

    case PROP_PERSON_BEAN_PASSWORD:
      if (self->password != NULL)
        g_free (self->password);
      self->password = g_value_dup_string (value);
      self->__isset_password = TRUE;
      break;

    case PROP_PERSON_BEAN_BIRTHDATE:
      self->birthdate = g_value_get_int64 (value);
      self->__isset_birthdate = TRUE;
      break;

    case PROP_PERSON_BEAN_MOBILE_PHONE:
      if (self->mobilePhone != NULL)
        g_free (self->mobilePhone);
      self->mobilePhone = g_value_dup_string (value);
      self->__isset_mobilePhone = TRUE;
      break;

    case PROP_PERSON_BEAN_PAPERS_TYPE:
      self->papersType = g_value_get_int (value);
      self->__isset_papersType = TRUE;
      break;

    case PROP_PERSON_BEAN_PAPERS_NUM:
      if (self->papersNum != NULL)
        g_free (self->papersNum);
      self->papersNum = g_value_dup_string (value);
      self->__isset_papersNum = TRUE;
      break;

    case PROP_PERSON_BEAN_IMAGE_MD5:
      if (self->imageMd5 != NULL)
        g_free (self->imageMd5);
      self->imageMd5 = g_value_dup_string (value);
      self->__isset_imageMd5 = TRUE;
      break;

    case PROP_PERSON_BEAN_EXPIRY_DATE:
      self->expiryDate = g_value_get_int64 (value);
      self->__isset_expiryDate = TRUE;
      break;

    case PROP_PERSON_BEAN_REMARK:
      if (self->remark != NULL)
        g_free (self->remark);
      self->remark = g_value_dup_string (value);
      self->__isset_remark = TRUE;
      break;

    case PROP_PERSON_BEAN_EXT_BIN:
      if (self->extBin != NULL)
        g_byte_array_unref (self->extBin);
      self->extBin = g_value_dup_boxed (value);
      self->__isset_extBin = TRUE;
      break;

    case PROP_PERSON_BEAN_EXT_TXT:
      if (self->extTxt != NULL)
        g_free (self->extTxt);
      self->extTxt = g_value_dup_string (value);
      self->__isset_extTxt = TRUE;
      break;

    case PROP_PERSON_BEAN_CREATE_TIME:
      self->createTime = g_value_get_int64 (value);
      self->__isset_createTime = TRUE;
      break;

    case PROP_PERSON_BEAN_UPDATE_TIME:
      self->updateTime = g_value_get_int64 (value);
      self->__isset_updateTime = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
person_bean_get_property (GObject *object,
                          guint property_id,
                          GValue *value,
                          GParamSpec *pspec)
{
  PersonBean *self = PERSON_BEAN (object);

  switch (property_id)
  {
    case PROP_PERSON_BEAN__NEW:
      g_value_set_boolean (value, self->_new);
      break;

    case PROP_PERSON_BEAN_MODIFIED:
      g_value_set_int (value, self->modified);
      break;

    case PROP_PERSON_BEAN_INITIALIZED:
      g_value_set_int (value, self->initialized);
      break;

    case PROP_PERSON_BEAN_ID:
      g_value_set_int (value, self->id);
      break;

    case PROP_PERSON_BEAN_GROUP_ID:
      g_value_set_int (value, self->groupId);
      break;

    case PROP_PERSON_BEAN_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_PERSON_BEAN_SEX:
      g_value_set_int (value, self->sex);
      break;

    case PROP_PERSON_BEAN_RANK:
      g_value_set_int (value, self->rank);
      break;

    case PROP_PERSON_BEAN_PASSWORD:
      g_value_set_string (value, self->password);
      break;

    case PROP_PERSON_BEAN_BIRTHDATE:
      g_value_set_int64 (value, self->birthdate);
      break;

    case PROP_PERSON_BEAN_MOBILE_PHONE:
      g_value_set_string (value, self->mobilePhone);
      break;

    case PROP_PERSON_BEAN_PAPERS_TYPE:
      g_value_set_int (value, self->papersType);
      break;

    case PROP_PERSON_BEAN_PAPERS_NUM:
      g_value_set_string (value, self->papersNum);
      break;

    case PROP_PERSON_BEAN_IMAGE_MD5:
      g_value_set_string (value, self->imageMd5);
      break;

    case PROP_PERSON_BEAN_EXPIRY_DATE:
      g_value_set_int64 (value, self->expiryDate);
      break;

    case PROP_PERSON_BEAN_REMARK:
      g_value_set_string (value, self->remark);
      break;

    case PROP_PERSON_BEAN_EXT_BIN:
      g_value_set_boxed (value, self->extBin);
      break;

    case PROP_PERSON_BEAN_EXT_TXT:
      g_value_set_string (value, self->extTxt);
      break;

    case PROP_PERSON_BEAN_CREATE_TIME:
      g_value_set_int64 (value, self->createTime);
      break;

    case PROP_PERSON_BEAN_UPDATE_TIME:
      g_value_set_int64 (value, self->updateTime);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
person_bean_instance_init (PersonBean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->_new = 0;
  object->modified = 0;
  object->initialized = 0;
  object->id = 0;
  object->__isset_id = FALSE;
  object->groupId = 0;
  object->__isset_groupId = FALSE;
  object->name = NULL;
  object->__isset_name = FALSE;
  object->sex = 0;
  object->__isset_sex = FALSE;
  object->rank = 0;
  object->__isset_rank = FALSE;
  object->password = NULL;
  object->__isset_password = FALSE;
  object->birthdate = 0;
  object->__isset_birthdate = FALSE;
  object->mobilePhone = NULL;
  object->__isset_mobilePhone = FALSE;
  object->papersType = 0;
  object->__isset_papersType = FALSE;
  object->papersNum = NULL;
  object->__isset_papersNum = FALSE;
  object->imageMd5 = NULL;
  object->__isset_imageMd5 = FALSE;
  object->expiryDate = 0;
  object->__isset_expiryDate = FALSE;
  object->remark = NULL;
  object->__isset_remark = FALSE;
  object->extBin = NULL;
  object->__isset_extBin = FALSE;
  object->extTxt = NULL;
  object->__isset_extTxt = FALSE;
  object->createTime = 0;
  object->__isset_createTime = FALSE;
  object->updateTime = 0;
  object->__isset_updateTime = FALSE;
}

static void 
person_bean_finalize (GObject *object)
{
  PersonBean *tobject = PERSON_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->password != NULL)
  {
    g_free(tobject->password);
    tobject->password = NULL;
  }
  if (tobject->mobilePhone != NULL)
  {
    g_free(tobject->mobilePhone);
    tobject->mobilePhone = NULL;
  }
  if (tobject->papersNum != NULL)
  {
    g_free(tobject->papersNum);
    tobject->papersNum = NULL;
  }
  if (tobject->imageMd5 != NULL)
  {
    g_free(tobject->imageMd5);
    tobject->imageMd5 = NULL;
  }
  if (tobject->remark != NULL)
  {
    g_free(tobject->remark);
    tobject->remark = NULL;
  }
  if (tobject->extBin != NULL)
  {
    thrift_string_free(tobject->extBin);
    tobject->extBin = NULL;
  }
  if (tobject->extTxt != NULL)
  {
    g_free(tobject->extTxt);
    tobject->extTxt = NULL;
  }
}

static void
person_bean_class_init (PersonBeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = person_bean_read;
  struct_class->write = person_bean_write;

  gobject_class->finalize = person_bean_finalize;
  gobject_class->get_property = person_bean_get_property;
  gobject_class->set_property = person_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_BEAN__NEW,
     g_param_spec_boolean ("_new",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_BEAN_MODIFIED,
     g_param_spec_int ("modified",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_BEAN_INITIALIZED,
     g_param_spec_int ("initialized",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_BEAN_ID,
     g_param_spec_int ("id",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_BEAN_GROUP_ID,
     g_param_spec_int ("groupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_BEAN_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_BEAN_SEX,
     g_param_spec_int ("sex",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_BEAN_RANK,
     g_param_spec_int ("rank",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_BEAN_PASSWORD,
     g_param_spec_string ("password",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_BEAN_BIRTHDATE,
     g_param_spec_int64 ("birthdate",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_BEAN_MOBILE_PHONE,
     g_param_spec_string ("mobilePhone",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_BEAN_PAPERS_TYPE,
     g_param_spec_int ("papersType",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_BEAN_PAPERS_NUM,
     g_param_spec_string ("papersNum",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_BEAN_IMAGE_MD5,
     g_param_spec_string ("imageMd5",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_BEAN_EXPIRY_DATE,
     g_param_spec_int64 ("expiryDate",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_BEAN_REMARK,
     g_param_spec_string ("remark",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_BEAN_EXT_BIN,
     g_param_spec_boxed ("extBin",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_BEAN_EXT_TXT,
     g_param_spec_string ("extTxt",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_BEAN_CREATE_TIME,
     g_param_spec_int64 ("createTime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_BEAN_UPDATE_TIME,
     g_param_spec_int64 ("updateTime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
person_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (PersonBeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) person_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (PersonBean),
      0, /* n_preallocs */
      (GInstanceInitFunc) person_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "PersonBeanType",
                                   &type_info, 0);
  }

  return type;
}

enum _PersonGroupBeanProperties
{
  PROP_PERSON_GROUP_BEAN_0,
  PROP_PERSON_GROUP_BEAN__NEW,
  PROP_PERSON_GROUP_BEAN_MODIFIED,
  PROP_PERSON_GROUP_BEAN_INITIALIZED,
  PROP_PERSON_GROUP_BEAN_ID,
  PROP_PERSON_GROUP_BEAN_NAME,
  PROP_PERSON_GROUP_BEAN_LEAF,
  PROP_PERSON_GROUP_BEAN_PARENT,
  PROP_PERSON_GROUP_BEAN_ROOT_GROUP,
  PROP_PERSON_GROUP_BEAN_REMARK,
  PROP_PERSON_GROUP_BEAN_EXT_BIN,
  PROP_PERSON_GROUP_BEAN_EXT_TXT,
  PROP_PERSON_GROUP_BEAN_CREATE_TIME,
  PROP_PERSON_GROUP_BEAN_UPDATE_TIME
};

/* reads a person_group_bean object */
static gint32
person_group_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  PersonGroupBean * this_object = PERSON_GROUP_BEAN(object);
  gboolean isset__new = FALSE;
  gboolean isset_modified = FALSE;
  gboolean isset_initialized = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->_new, error)) < 0)
            return -1;
          xfer += ret;
          isset__new = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->modified, error)) < 0)
            return -1;
          xfer += ret;
          isset_modified = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->initialized, error)) < 0)
            return -1;
          xfer += ret;
          isset_initialized = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->leaf, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_leaf = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->parent, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_parent = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->rootGroup, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_rootGroup = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRING)
        {
          if (this_object->remark != NULL)
          {
            g_free(this_object->remark);
            this_object->remark = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->remark, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_remark = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_STRING)
        {
          if (this_object->extBin != NULL)
          {
            g_free(this_object->extBin);
            this_object->extBin = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->extBin = g_byte_array_new();
          g_byte_array_append (this_object->extBin, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_extBin = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRING)
        {
          if (this_object->extTxt != NULL)
          {
            g_free(this_object->extTxt);
            this_object->extTxt = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->extTxt, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_extTxt = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->createTime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_createTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->updateTime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_updateTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset__new)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_modified)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_initialized)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
person_group_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  PersonGroupBean * this_object = PERSON_GROUP_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "PersonGroupBean", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "_new", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->_new, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "modified", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->modified, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "initialized", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->initialized, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_id == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->id, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_name == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_leaf == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "leaf", T_I32, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->leaf, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_parent == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "parent", T_I32, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->parent, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_rootGroup == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "rootGroup", T_I32, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->rootGroup, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_remark == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "remark", T_STRING, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->remark, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extBin == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extBin", T_STRING, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->extBin ? ((GByteArray *) this_object->extBin)->data : NULL, this_object->extBin ? ((GByteArray *) this_object->extBin)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_extTxt == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "extTxt", T_STRING, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->extTxt, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_createTime == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "createTime", T_I64, 12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->createTime, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_updateTime == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "updateTime", T_I64, 13, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->updateTime, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
person_group_bean_set_property (GObject *object,
                                guint property_id,
                                const GValue *value,
                                GParamSpec *pspec)
{
  PersonGroupBean *self = PERSON_GROUP_BEAN (object);

  switch (property_id)
  {
    case PROP_PERSON_GROUP_BEAN__NEW:
      self->_new = g_value_get_boolean (value);
      break;

    case PROP_PERSON_GROUP_BEAN_MODIFIED:
      self->modified = g_value_get_int (value);
      break;

    case PROP_PERSON_GROUP_BEAN_INITIALIZED:
      self->initialized = g_value_get_int (value);
      break;

    case PROP_PERSON_GROUP_BEAN_ID:
      self->id = g_value_get_int (value);
      self->__isset_id = TRUE;
      break;

    case PROP_PERSON_GROUP_BEAN_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_PERSON_GROUP_BEAN_LEAF:
      self->leaf = g_value_get_int (value);
      self->__isset_leaf = TRUE;
      break;

    case PROP_PERSON_GROUP_BEAN_PARENT:
      self->parent = g_value_get_int (value);
      self->__isset_parent = TRUE;
      break;

    case PROP_PERSON_GROUP_BEAN_ROOT_GROUP:
      self->rootGroup = g_value_get_int (value);
      self->__isset_rootGroup = TRUE;
      break;

    case PROP_PERSON_GROUP_BEAN_REMARK:
      if (self->remark != NULL)
        g_free (self->remark);
      self->remark = g_value_dup_string (value);
      self->__isset_remark = TRUE;
      break;

    case PROP_PERSON_GROUP_BEAN_EXT_BIN:
      if (self->extBin != NULL)
        g_byte_array_unref (self->extBin);
      self->extBin = g_value_dup_boxed (value);
      self->__isset_extBin = TRUE;
      break;

    case PROP_PERSON_GROUP_BEAN_EXT_TXT:
      if (self->extTxt != NULL)
        g_free (self->extTxt);
      self->extTxt = g_value_dup_string (value);
      self->__isset_extTxt = TRUE;
      break;

    case PROP_PERSON_GROUP_BEAN_CREATE_TIME:
      self->createTime = g_value_get_int64 (value);
      self->__isset_createTime = TRUE;
      break;

    case PROP_PERSON_GROUP_BEAN_UPDATE_TIME:
      self->updateTime = g_value_get_int64 (value);
      self->__isset_updateTime = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
person_group_bean_get_property (GObject *object,
                                guint property_id,
                                GValue *value,
                                GParamSpec *pspec)
{
  PersonGroupBean *self = PERSON_GROUP_BEAN (object);

  switch (property_id)
  {
    case PROP_PERSON_GROUP_BEAN__NEW:
      g_value_set_boolean (value, self->_new);
      break;

    case PROP_PERSON_GROUP_BEAN_MODIFIED:
      g_value_set_int (value, self->modified);
      break;

    case PROP_PERSON_GROUP_BEAN_INITIALIZED:
      g_value_set_int (value, self->initialized);
      break;

    case PROP_PERSON_GROUP_BEAN_ID:
      g_value_set_int (value, self->id);
      break;

    case PROP_PERSON_GROUP_BEAN_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_PERSON_GROUP_BEAN_LEAF:
      g_value_set_int (value, self->leaf);
      break;

    case PROP_PERSON_GROUP_BEAN_PARENT:
      g_value_set_int (value, self->parent);
      break;

    case PROP_PERSON_GROUP_BEAN_ROOT_GROUP:
      g_value_set_int (value, self->rootGroup);
      break;

    case PROP_PERSON_GROUP_BEAN_REMARK:
      g_value_set_string (value, self->remark);
      break;

    case PROP_PERSON_GROUP_BEAN_EXT_BIN:
      g_value_set_boxed (value, self->extBin);
      break;

    case PROP_PERSON_GROUP_BEAN_EXT_TXT:
      g_value_set_string (value, self->extTxt);
      break;

    case PROP_PERSON_GROUP_BEAN_CREATE_TIME:
      g_value_set_int64 (value, self->createTime);
      break;

    case PROP_PERSON_GROUP_BEAN_UPDATE_TIME:
      g_value_set_int64 (value, self->updateTime);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
person_group_bean_instance_init (PersonGroupBean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->_new = 0;
  object->modified = 0;
  object->initialized = 0;
  object->id = 0;
  object->__isset_id = FALSE;
  object->name = NULL;
  object->__isset_name = FALSE;
  object->leaf = 0;
  object->__isset_leaf = FALSE;
  object->parent = 0;
  object->__isset_parent = FALSE;
  object->rootGroup = 0;
  object->__isset_rootGroup = FALSE;
  object->remark = NULL;
  object->__isset_remark = FALSE;
  object->extBin = NULL;
  object->__isset_extBin = FALSE;
  object->extTxt = NULL;
  object->__isset_extTxt = FALSE;
  object->createTime = 0;
  object->__isset_createTime = FALSE;
  object->updateTime = 0;
  object->__isset_updateTime = FALSE;
}

static void 
person_group_bean_finalize (GObject *object)
{
  PersonGroupBean *tobject = PERSON_GROUP_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->remark != NULL)
  {
    g_free(tobject->remark);
    tobject->remark = NULL;
  }
  if (tobject->extBin != NULL)
  {
    thrift_string_free(tobject->extBin);
    tobject->extBin = NULL;
  }
  if (tobject->extTxt != NULL)
  {
    g_free(tobject->extTxt);
    tobject->extTxt = NULL;
  }
}

static void
person_group_bean_class_init (PersonGroupBeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = person_group_bean_read;
  struct_class->write = person_group_bean_write;

  gobject_class->finalize = person_group_bean_finalize;
  gobject_class->get_property = person_group_bean_get_property;
  gobject_class->set_property = person_group_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_GROUP_BEAN__NEW,
     g_param_spec_boolean ("_new",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_GROUP_BEAN_MODIFIED,
     g_param_spec_int ("modified",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_GROUP_BEAN_INITIALIZED,
     g_param_spec_int ("initialized",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_GROUP_BEAN_ID,
     g_param_spec_int ("id",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_GROUP_BEAN_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_GROUP_BEAN_LEAF,
     g_param_spec_int ("leaf",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_GROUP_BEAN_PARENT,
     g_param_spec_int ("parent",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_GROUP_BEAN_ROOT_GROUP,
     g_param_spec_int ("rootGroup",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_GROUP_BEAN_REMARK,
     g_param_spec_string ("remark",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_GROUP_BEAN_EXT_BIN,
     g_param_spec_boxed ("extBin",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_GROUP_BEAN_EXT_TXT,
     g_param_spec_string ("extTxt",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_GROUP_BEAN_CREATE_TIME,
     g_param_spec_int64 ("createTime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_PERSON_GROUP_BEAN_UPDATE_TIME,
     g_param_spec_int64 ("updateTime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
person_group_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (PersonGroupBeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) person_group_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (PersonGroupBean),
      0, /* n_preallocs */
      (GInstanceInitFunc) person_group_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "PersonGroupBeanType",
                                   &type_info, 0);
  }

  return type;
}

enum _LogLightBeanProperties
{
  PROP_LOG_LIGHT_BEAN_0,
  PROP_LOG_LIGHT_BEAN__NEW,
  PROP_LOG_LIGHT_BEAN_MODIFIED,
  PROP_LOG_LIGHT_BEAN_INITIALIZED,
  PROP_LOG_LIGHT_BEAN_ID,
  PROP_LOG_LIGHT_BEAN_PERSON_ID,
  PROP_LOG_LIGHT_BEAN_NAME,
  PROP_LOG_LIGHT_BEAN_PAPERS_TYPE,
  PROP_LOG_LIGHT_BEAN_PAPERS_NUM,
  PROP_LOG_LIGHT_BEAN_VERIFY_TIME
};

/* reads a log_light_bean object */
static gint32
log_light_bean_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  LogLightBean * this_object = LOG_LIGHT_BEAN(object);
  gboolean isset__new = FALSE;
  gboolean isset_modified = FALSE;
  gboolean isset_initialized = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->_new, error)) < 0)
            return -1;
          xfer += ret;
          isset__new = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->modified, error)) < 0)
            return -1;
          xfer += ret;
          isset_modified = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->initialized, error)) < 0)
            return -1;
          xfer += ret;
          isset_initialized = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRING)
        {
          if (this_object->name != NULL)
          {
            g_free(this_object->name);
            this_object->name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->papersType, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_papersType = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRING)
        {
          if (this_object->papersNum != NULL)
          {
            g_free(this_object->papersNum);
            this_object->papersNum = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->papersNum, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_papersNum = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->verifyTime, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_verifyTime = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset__new)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_modified)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_initialized)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
log_light_bean_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  LogLightBean * this_object = LOG_LIGHT_BEAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "LogLightBean", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "_new", T_BOOL, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->_new, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "modified", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->modified, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "initialized", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->initialized, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_id == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->id, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_personId == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_name == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "name", T_STRING, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->name, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_papersType == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "papersType", T_I32, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->papersType, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_papersNum == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "papersNum", T_STRING, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->papersNum, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_verifyTime == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "verifyTime", T_I64, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->verifyTime, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
log_light_bean_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  LogLightBean *self = LOG_LIGHT_BEAN (object);

  switch (property_id)
  {
    case PROP_LOG_LIGHT_BEAN__NEW:
      self->_new = g_value_get_boolean (value);
      break;

    case PROP_LOG_LIGHT_BEAN_MODIFIED:
      self->modified = g_value_get_int (value);
      break;

    case PROP_LOG_LIGHT_BEAN_INITIALIZED:
      self->initialized = g_value_get_int (value);
      break;

    case PROP_LOG_LIGHT_BEAN_ID:
      self->id = g_value_get_int (value);
      self->__isset_id = TRUE;
      break;

    case PROP_LOG_LIGHT_BEAN_PERSON_ID:
      self->personId = g_value_get_int (value);
      self->__isset_personId = TRUE;
      break;

    case PROP_LOG_LIGHT_BEAN_NAME:
      if (self->name != NULL)
        g_free (self->name);
      self->name = g_value_dup_string (value);
      self->__isset_name = TRUE;
      break;

    case PROP_LOG_LIGHT_BEAN_PAPERS_TYPE:
      self->papersType = g_value_get_int (value);
      self->__isset_papersType = TRUE;
      break;

    case PROP_LOG_LIGHT_BEAN_PAPERS_NUM:
      if (self->papersNum != NULL)
        g_free (self->papersNum);
      self->papersNum = g_value_dup_string (value);
      self->__isset_papersNum = TRUE;
      break;

    case PROP_LOG_LIGHT_BEAN_VERIFY_TIME:
      self->verifyTime = g_value_get_int64 (value);
      self->__isset_verifyTime = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
log_light_bean_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  LogLightBean *self = LOG_LIGHT_BEAN (object);

  switch (property_id)
  {
    case PROP_LOG_LIGHT_BEAN__NEW:
      g_value_set_boolean (value, self->_new);
      break;

    case PROP_LOG_LIGHT_BEAN_MODIFIED:
      g_value_set_int (value, self->modified);
      break;

    case PROP_LOG_LIGHT_BEAN_INITIALIZED:
      g_value_set_int (value, self->initialized);
      break;

    case PROP_LOG_LIGHT_BEAN_ID:
      g_value_set_int (value, self->id);
      break;

    case PROP_LOG_LIGHT_BEAN_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    case PROP_LOG_LIGHT_BEAN_NAME:
      g_value_set_string (value, self->name);
      break;

    case PROP_LOG_LIGHT_BEAN_PAPERS_TYPE:
      g_value_set_int (value, self->papersType);
      break;

    case PROP_LOG_LIGHT_BEAN_PAPERS_NUM:
      g_value_set_string (value, self->papersNum);
      break;

    case PROP_LOG_LIGHT_BEAN_VERIFY_TIME:
      g_value_set_int64 (value, self->verifyTime);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
log_light_bean_instance_init (LogLightBean * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->_new = 0;
  object->modified = 0;
  object->initialized = 0;
  object->id = 0;
  object->__isset_id = FALSE;
  object->personId = 0;
  object->__isset_personId = FALSE;
  object->name = NULL;
  object->__isset_name = FALSE;
  object->papersType = 0;
  object->__isset_papersType = FALSE;
  object->papersNum = NULL;
  object->__isset_papersNum = FALSE;
  object->verifyTime = 0;
  object->__isset_verifyTime = FALSE;
}

static void 
log_light_bean_finalize (GObject *object)
{
  LogLightBean *tobject = LOG_LIGHT_BEAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->name != NULL)
  {
    g_free(tobject->name);
    tobject->name = NULL;
  }
  if (tobject->papersNum != NULL)
  {
    g_free(tobject->papersNum);
    tobject->papersNum = NULL;
  }
}

static void
log_light_bean_class_init (LogLightBeanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = log_light_bean_read;
  struct_class->write = log_light_bean_write;

  gobject_class->finalize = log_light_bean_finalize;
  gobject_class->get_property = log_light_bean_get_property;
  gobject_class->set_property = log_light_bean_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_LOG_LIGHT_BEAN__NEW,
     g_param_spec_boolean ("_new",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOG_LIGHT_BEAN_MODIFIED,
     g_param_spec_int ("modified",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOG_LIGHT_BEAN_INITIALIZED,
     g_param_spec_int ("initialized",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOG_LIGHT_BEAN_ID,
     g_param_spec_int ("id",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOG_LIGHT_BEAN_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOG_LIGHT_BEAN_NAME,
     g_param_spec_string ("name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOG_LIGHT_BEAN_PAPERS_TYPE,
     g_param_spec_int ("papersType",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOG_LIGHT_BEAN_PAPERS_NUM,
     g_param_spec_string ("papersNum",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_LOG_LIGHT_BEAN_VERIFY_TIME,
     g_param_spec_int64 ("verifyTime",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
log_light_bean_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (LogLightBeanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) log_light_bean_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (LogLightBean),
      0, /* n_preallocs */
      (GInstanceInitFunc) log_light_bean_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "LogLightBeanType",
                                   &type_info, 0);
  }

  return type;
}

enum _TokenProperties
{
  PROP_TOKEN_0,
  PROP_TOKEN_ID,
  PROP_TOKEN_T1,
  PROP_TOKEN_T2,
  PROP_TOKEN_T3,
  PROP_TOKEN_T4,
  PROP_TOKEN_TYPE
};

/* reads a token object */
static gint32
token_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Token * this_object = TOKEN(object);
  gboolean isset_id = FALSE;
  gboolean isset_t1 = FALSE;
  gboolean isset_t2 = FALSE;
  gboolean isset_t3 = FALSE;
  gboolean isset_t4 = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->t1, error)) < 0)
            return -1;
          xfer += ret;
          isset_t1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->t2, error)) < 0)
            return -1;
          xfer += ret;
          isset_t2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->t3, error)) < 0)
            return -1;
          xfer += ret;
          isset_t3 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->t4, error)) < 0)
            return -1;
          xfer += ret;
          isset_t4 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          gint32 ecast0;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast0, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (TokenType)ecast0;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_id)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_t1)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_t2)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_t3)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_t4)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
token_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Token * this_object = TOKEN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Token", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->id, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "t1", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->t1, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "t2", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->t2, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "t3", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->t3, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "t4", T_I32, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->t4, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_type == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
token_set_property (GObject *object,
                    guint property_id,
                    const GValue *value,
                    GParamSpec *pspec)
{
  Token *self = TOKEN (object);

  switch (property_id)
  {
    case PROP_TOKEN_ID:
      self->id = g_value_get_int (value);
      break;

    case PROP_TOKEN_T1:
      self->t1 = g_value_get_int (value);
      break;

    case PROP_TOKEN_T2:
      self->t2 = g_value_get_int (value);
      break;

    case PROP_TOKEN_T3:
      self->t3 = g_value_get_int (value);
      break;

    case PROP_TOKEN_T4:
      self->t4 = g_value_get_int (value);
      break;

    case PROP_TOKEN_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
token_get_property (GObject *object,
                    guint property_id,
                    GValue *value,
                    GParamSpec *pspec)
{
  Token *self = TOKEN (object);

  switch (property_id)
  {
    case PROP_TOKEN_ID:
      g_value_set_int (value, self->id);
      break;

    case PROP_TOKEN_T1:
      g_value_set_int (value, self->t1);
      break;

    case PROP_TOKEN_T2:
      g_value_set_int (value, self->t2);
      break;

    case PROP_TOKEN_T3:
      g_value_set_int (value, self->t3);
      break;

    case PROP_TOKEN_T4:
      g_value_set_int (value, self->t4);
      break;

    case PROP_TOKEN_TYPE:
      g_value_set_int (value, self->type);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
token_instance_init (Token * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = 0;
  object->t1 = 0;
  object->t2 = 0;
  object->t3 = 0;
  object->t4 = 0;
  object->__isset_type = FALSE;
}

static void 
token_finalize (GObject *object)
{
  Token *tobject = TOKEN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
token_class_init (TokenClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = token_read;
  struct_class->write = token_write;

  gobject_class->finalize = token_finalize;
  gobject_class->get_property = token_get_property;
  gobject_class->set_property = token_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TOKEN_ID,
     g_param_spec_int ("id",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TOKEN_T1,
     g_param_spec_int ("t1",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TOKEN_T2,
     g_param_spec_int ("t2",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TOKEN_T3,
     g_param_spec_int ("t3",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TOKEN_T4,
     g_param_spec_int ("t4",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_TOKEN_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));
}

GType
token_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TokenClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) token_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Token),
      0, /* n_preallocs */
      (GInstanceInitFunc) token_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TokenType",
                                   &type_info, 0);
  }

  return type;
}

enum _ServiceSecurityExceptionProperties
{
  PROP_SERVICE_SECURITY_EXCEPTION_0,
  PROP_SERVICE_SECURITY_EXCEPTION_MESSAGE,
  PROP_SERVICE_SECURITY_EXCEPTION_CAUSE_CLASS,
  PROP_SERVICE_SECURITY_EXCEPTION_SERVICE_STACK_TRACE_MESSAGE,
  PROP_SERVICE_SECURITY_EXCEPTION_CAUSE_FIELDS,
  PROP_SERVICE_SECURITY_EXCEPTION_DEVICE_I_D,
  PROP_SERVICE_SECURITY_EXCEPTION_TYPE
};

/* reads a service_security_exception object */
static gint32
service_security_exception_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  ServiceSecurityException * this_object = SERVICE_SECURITY_EXCEPTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->causeClass != NULL)
          {
            g_free(this_object->causeClass);
            this_object->causeClass = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->causeClass, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_causeClass = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->serviceStackTraceMessage != NULL)
          {
            g_free(this_object->serviceStackTraceMessage);
            this_object->serviceStackTraceMessage = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->serviceStackTraceMessage, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_serviceStackTraceMessage = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->causeFields != NULL)
          {
            g_free(this_object->causeFields);
            this_object->causeFields = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->causeFields, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_causeFields = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceID, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_deviceID = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          gint32 ecast1;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast1, error)) < 0)
            return -1;
          xfer += ret;
          this_object->type = (SecurityExceptionType)ecast1;
          this_object->__isset_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
service_security_exception_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  ServiceSecurityException * this_object = SERVICE_SECURITY_EXCEPTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSecurityException", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_message == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_causeClass == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "causeClass", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->causeClass, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_serviceStackTraceMessage == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "serviceStackTraceMessage", T_STRING, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->serviceStackTraceMessage, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_causeFields == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "causeFields", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->causeFields, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_deviceID == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceID", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceID, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_type == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "type", T_I32, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->type, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
service_security_exception_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  ServiceSecurityException *self = SERVICE_SECURITY_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_SERVICE_SECURITY_EXCEPTION_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    case PROP_SERVICE_SECURITY_EXCEPTION_CAUSE_CLASS:
      if (self->causeClass != NULL)
        g_free (self->causeClass);
      self->causeClass = g_value_dup_string (value);
      self->__isset_causeClass = TRUE;
      break;

    case PROP_SERVICE_SECURITY_EXCEPTION_SERVICE_STACK_TRACE_MESSAGE:
      if (self->serviceStackTraceMessage != NULL)
        g_free (self->serviceStackTraceMessage);
      self->serviceStackTraceMessage = g_value_dup_string (value);
      self->__isset_serviceStackTraceMessage = TRUE;
      break;

    case PROP_SERVICE_SECURITY_EXCEPTION_CAUSE_FIELDS:
      if (self->causeFields != NULL)
        g_free (self->causeFields);
      self->causeFields = g_value_dup_string (value);
      self->__isset_causeFields = TRUE;
      break;

    case PROP_SERVICE_SECURITY_EXCEPTION_DEVICE_I_D:
      self->deviceID = g_value_get_int (value);
      self->__isset_deviceID = TRUE;
      break;

    case PROP_SERVICE_SECURITY_EXCEPTION_TYPE:
      self->type = g_value_get_int (value);
      self->__isset_type = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
service_security_exception_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  ServiceSecurityException *self = SERVICE_SECURITY_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_SERVICE_SECURITY_EXCEPTION_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    case PROP_SERVICE_SECURITY_EXCEPTION_CAUSE_CLASS:
      g_value_set_string (value, self->causeClass);
      break;

    case PROP_SERVICE_SECURITY_EXCEPTION_SERVICE_STACK_TRACE_MESSAGE:
      g_value_set_string (value, self->serviceStackTraceMessage);
      break;

    case PROP_SERVICE_SECURITY_EXCEPTION_CAUSE_FIELDS:
      g_value_set_string (value, self->causeFields);
      break;

    case PROP_SERVICE_SECURITY_EXCEPTION_DEVICE_I_D:
      g_value_set_int (value, self->deviceID);
      break;

    case PROP_SERVICE_SECURITY_EXCEPTION_TYPE:
      g_value_set_int (value, self->type);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
service_security_exception_instance_init (ServiceSecurityException * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->message = NULL;
  object->__isset_message = FALSE;
  object->causeClass = NULL;
  object->__isset_causeClass = FALSE;
  object->serviceStackTraceMessage = NULL;
  object->__isset_serviceStackTraceMessage = FALSE;
  object->causeFields = NULL;
  object->__isset_causeFields = FALSE;
  object->deviceID = 0;
  object->__isset_deviceID = FALSE;
  object->__isset_type = FALSE;
}

static void 
service_security_exception_finalize (GObject *object)
{
  ServiceSecurityException *tobject = SERVICE_SECURITY_EXCEPTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
  if (tobject->causeClass != NULL)
  {
    g_free(tobject->causeClass);
    tobject->causeClass = NULL;
  }
  if (tobject->serviceStackTraceMessage != NULL)
  {
    g_free(tobject->serviceStackTraceMessage);
    tobject->serviceStackTraceMessage = NULL;
  }
  if (tobject->causeFields != NULL)
  {
    g_free(tobject->causeFields);
    tobject->causeFields = NULL;
  }
}

static void
service_security_exception_class_init (ServiceSecurityExceptionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = service_security_exception_read;
  struct_class->write = service_security_exception_write;

  gobject_class->finalize = service_security_exception_finalize;
  gobject_class->get_property = service_security_exception_get_property;
  gobject_class->set_property = service_security_exception_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SECURITY_EXCEPTION_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SECURITY_EXCEPTION_CAUSE_CLASS,
     g_param_spec_string ("causeClass",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SECURITY_EXCEPTION_SERVICE_STACK_TRACE_MESSAGE,
     g_param_spec_string ("serviceStackTraceMessage",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SECURITY_EXCEPTION_CAUSE_FIELDS,
     g_param_spec_string ("causeFields",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SECURITY_EXCEPTION_DEVICE_I_D,
     g_param_spec_int ("deviceID",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SERVICE_SECURITY_EXCEPTION_TYPE,
     g_param_spec_int ("type",
                       NULL,
                       NULL,
                       0,
                       12,
                       0,
                       G_PARAM_READWRITE));
}

GType
service_security_exception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ServiceSecurityExceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) service_security_exception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (ServiceSecurityException),
      0, /* n_preallocs */
      (GInstanceInitFunc) service_security_exception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ServiceSecurityExceptionType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define SERVICE_SECURITY_EXCEPTION_ERROR_DOMAIN "service_security_exception_error_quark"
GQuark
service_security_exception_error_quark (void)
{
  return g_quark_from_static_string (SERVICE_SECURITY_EXCEPTION_ERROR_DOMAIN);
}

/* constants */

enum _IFaceLogAddFeatureArgsProperties
{
  PROP_I_FACE_LOG_ADD_FEATURE_ARGS_0,
  PROP_I_FACE_LOG_ADD_FEATURE_ARGS_FEATURE,
  PROP_I_FACE_LOG_ADD_FEATURE_ARGS_FEATURE_VERSION,
  PROP_I_FACE_LOG_ADD_FEATURE_ARGS_PERSON_ID,
  PROP_I_FACE_LOG_ADD_FEATURE_ARGS_FAEC_BEANS,
  PROP_I_FACE_LOG_ADD_FEATURE_ARGS_TOKEN
};

/* reads a i_face_log_add_feature_args object */
static gint32
i_face_log_add_feature_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogAddFeatureArgs * this_object = I_FACE_LOG_ADD_FEATURE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->feature != NULL)
          {
            g_free(this_object->feature);
            this_object->feature = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->feature = g_byte_array_new();
          g_byte_array_append (this_object->feature, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_feature = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->featureVersion != NULL)
          {
            g_free(this_object->featureVersion);
            this_object->featureVersion = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->featureVersion, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_featureVersion = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              FaceBean * _elem2 = NULL;
              if ( _elem2 != NULL)
              {
                g_object_unref (_elem2);
              }
              _elem2 = g_object_new (TYPE_FACE_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem2), protocol, error)) < 0)
              {
                g_object_unref (_elem2);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->faecBeans, _elem2);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_faecBeans = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_add_feature_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogAddFeatureArgs * this_object = I_FACE_LOG_ADD_FEATURE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogAddFeatureArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "feature", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->feature ? ((GByteArray *) this_object->feature)->data : NULL, this_object->feature ? ((GByteArray *) this_object->feature)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "featureVersion", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->featureVersion, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "faecBeans", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i3;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->faecBeans ? this_object->faecBeans->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i3 = 0; i3 < (this_object->faecBeans ? this_object->faecBeans->len : 0); i3++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->faecBeans, i3))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_add_feature_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  IFaceLogAddFeatureArgs *self = I_FACE_LOG_ADD_FEATURE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_FEATURE_ARGS_FEATURE:
      if (self->feature != NULL)
        g_byte_array_unref (self->feature);
      self->feature = g_value_dup_boxed (value);
      self->__isset_feature = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_ARGS_FEATURE_VERSION:
      if (self->featureVersion != NULL)
        g_free (self->featureVersion);
      self->featureVersion = g_value_dup_string (value);
      self->__isset_featureVersion = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_ARGS_PERSON_ID:
      self->personId = g_value_get_int (value);
      self->__isset_personId = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_ARGS_FAEC_BEANS:
      if (self->faecBeans != NULL)
        g_ptr_array_unref (self->faecBeans);
      self->faecBeans = g_value_dup_boxed (value);
      self->__isset_faecBeans = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_add_feature_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  IFaceLogAddFeatureArgs *self = I_FACE_LOG_ADD_FEATURE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_FEATURE_ARGS_FEATURE:
      g_value_set_boxed (value, self->feature);
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_ARGS_FEATURE_VERSION:
      g_value_set_string (value, self->featureVersion);
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_ARGS_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_ARGS_FAEC_BEANS:
      g_value_set_boxed (value, self->faecBeans);
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_add_feature_args_instance_init (IFaceLogAddFeatureArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->feature = NULL;
  object->__isset_feature = FALSE;
  object->featureVersion = NULL;
  object->__isset_featureVersion = FALSE;
  object->personId = 0;
  object->__isset_personId = FALSE;
  object->faecBeans = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_faecBeans = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_add_feature_args_finalize (GObject *object)
{
  IFaceLogAddFeatureArgs *tobject = I_FACE_LOG_ADD_FEATURE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->feature != NULL)
  {
    thrift_string_free(tobject->feature);
    tobject->feature = NULL;
  }
  if (tobject->featureVersion != NULL)
  {
    g_free(tobject->featureVersion);
    tobject->featureVersion = NULL;
  }
  if (tobject->faecBeans != NULL)
  {
    g_ptr_array_unref (tobject->faecBeans);
    tobject->faecBeans = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_add_feature_args_class_init (IFaceLogAddFeatureArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_add_feature_args_read;
  struct_class->write = i_face_log_add_feature_args_write;

  gobject_class->finalize = i_face_log_add_feature_args_finalize;
  gobject_class->get_property = i_face_log_add_feature_args_get_property;
  gobject_class->set_property = i_face_log_add_feature_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_ARGS_FEATURE,
     g_param_spec_boxed ("feature",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_ARGS_FEATURE_VERSION,
     g_param_spec_string ("featureVersion",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_ARGS_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_ARGS_FAEC_BEANS,
     g_param_spec_boxed ("faecBeans",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_add_feature_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogAddFeatureArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_add_feature_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogAddFeatureArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_add_feature_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogAddFeatureArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogAddFeatureResultProperties
{
  PROP_I_FACE_LOG_ADD_FEATURE_RESULT_0,
  PROP_I_FACE_LOG_ADD_FEATURE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_ADD_FEATURE_RESULT_EX1,
  PROP_I_FACE_LOG_ADD_FEATURE_RESULT_EX2
};

/* reads a i_face_log_add_feature_result object */
static gint32
i_face_log_add_feature_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogAddFeatureResult * this_object = I_FACE_LOG_ADD_FEATURE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_DUPLICATE_RECORD_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex2 != NULL)
          {
            g_object_unref (this_object->ex2);
          }
          this_object->ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex2);
            this_object->ex2 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_add_feature_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogAddFeatureResult * this_object = I_FACE_LOG_ADD_FEATURE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogAddFeatureResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex2", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_add_feature_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogAddFeatureResult *self = I_FACE_LOG_ADD_FEATURE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_FEATURE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_RESULT_EX2:
      if (self->ex2 != NULL)
        g_object_unref (self->ex2);
      self->ex2 = g_value_dup_object (value);
      self->__isset_ex2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_add_feature_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogAddFeatureResult *self = I_FACE_LOG_ADD_FEATURE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_FEATURE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_RESULT_EX2:
      g_value_set_object (value, self->ex2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_add_feature_result_instance_init (IFaceLogAddFeatureResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_FEATURE_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
  object->ex2 = NULL;
  object->__isset_ex2 = FALSE;
}

static void 
i_face_log_add_feature_result_finalize (GObject *object)
{
  IFaceLogAddFeatureResult *tobject = I_FACE_LOG_ADD_FEATURE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
  if (tobject->ex2 != NULL)
  {
    g_object_unref(tobject->ex2);
    tobject->ex2 = NULL;
  }
}

static void
i_face_log_add_feature_result_class_init (IFaceLogAddFeatureResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_add_feature_result_read;
  struct_class->write = i_face_log_add_feature_result_write;

  gobject_class->finalize = i_face_log_add_feature_result_finalize;
  gobject_class->get_property = i_face_log_add_feature_result_get_property;
  gobject_class->set_property = i_face_log_add_feature_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_FEATURE_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_DUPLICATE_RECORD_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_RESULT_EX2,
     g_param_spec_object ("ex2",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_add_feature_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogAddFeatureResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_add_feature_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogAddFeatureResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_add_feature_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogAddFeatureResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogAddFeatureMultiArgsProperties
{
  PROP_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS_0,
  PROP_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS_FEATURE,
  PROP_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS_FEATURE_VERSION,
  PROP_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS_PERSON_ID,
  PROP_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS_FACE_INFO,
  PROP_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS_TOKEN
};

/* reads a i_face_log_add_feature_multi_args object */
static gint32
i_face_log_add_feature_multi_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogAddFeatureMultiArgs * this_object = I_FACE_LOG_ADD_FEATURE_MULTI_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->feature != NULL)
          {
            g_free(this_object->feature);
            this_object->feature = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->feature = g_byte_array_new();
          g_byte_array_append (this_object->feature, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_feature = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->featureVersion != NULL)
          {
            g_free(this_object->featureVersion);
            this_object->featureVersion = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->featureVersion, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_featureVersion = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              GByteArray * key4 = NULL;
              FaceBean * val5 = NULL;
              if (key4 != NULL)
              {
                g_free(key4);
                key4 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key4 = g_byte_array_new();
              g_byte_array_append (key4, (guint8 *) data, (guint) len);
              g_free (data);
              if ( val5 != NULL)
              {
                g_object_unref (val5);
              }
              val5 = g_object_new (TYPE_FACE_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (val5), protocol, error)) < 0)
              {
                g_object_unref (val5);
                return -1;
              }
              xfer += ret;
              if (this_object->faceInfo && key4)
                g_hash_table_insert ((GHashTable *)this_object->faceInfo, (gpointer) key4, (gpointer) val5);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_faceInfo = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_add_feature_multi_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogAddFeatureMultiArgs * this_object = I_FACE_LOG_ADD_FEATURE_MULTI_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogAddFeatureMultiArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "feature", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->feature ? ((GByteArray *) this_object->feature)->data : NULL, this_object->feature ? ((GByteArray *) this_object->feature)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "featureVersion", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->featureVersion, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "faceInfo", T_MAP, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    GByteArray * key6 = NULL;
    FaceBean * val7 = NULL;
    GList *key_list = NULL, *iter = NULL;
    GByteArray ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRUCT, this_object->faceInfo ? (gint32) g_hash_table_size ((GHashTable *) this_object->faceInfo) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->faceInfo)
      g_hash_table_foreach ((GHashTable *) this_object->faceInfo, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (GByteArray *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (GByteArray *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key6 = keys[i];
      val7 = (FaceBean *) g_hash_table_lookup (((GHashTable *) this_object->faceInfo), (gpointer) key6);

      if ((ret = thrift_protocol_write_binary (protocol,  key6 ? ((GByteArray *)  key6)->data : NULL,  key6 ? ((GByteArray *)  key6)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_struct_write (THRIFT_STRUCT ( val7), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_add_feature_multi_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogAddFeatureMultiArgs *self = I_FACE_LOG_ADD_FEATURE_MULTI_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS_FEATURE:
      if (self->feature != NULL)
        g_byte_array_unref (self->feature);
      self->feature = g_value_dup_boxed (value);
      self->__isset_feature = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS_FEATURE_VERSION:
      if (self->featureVersion != NULL)
        g_free (self->featureVersion);
      self->featureVersion = g_value_dup_string (value);
      self->__isset_featureVersion = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS_PERSON_ID:
      self->personId = g_value_get_int (value);
      self->__isset_personId = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS_FACE_INFO:
      if (self->faceInfo != NULL)
        g_hash_table_unref (self->faceInfo);
      self->faceInfo = g_value_dup_boxed (value);
      self->__isset_faceInfo = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_add_feature_multi_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogAddFeatureMultiArgs *self = I_FACE_LOG_ADD_FEATURE_MULTI_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS_FEATURE:
      g_value_set_boxed (value, self->feature);
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS_FEATURE_VERSION:
      g_value_set_string (value, self->featureVersion);
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS_FACE_INFO:
      g_value_set_boxed (value, self->faceInfo);
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_add_feature_multi_args_instance_init (IFaceLogAddFeatureMultiArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->feature = NULL;
  object->__isset_feature = FALSE;
  object->featureVersion = NULL;
  object->__isset_featureVersion = FALSE;
  object->personId = 0;
  object->__isset_personId = FALSE;
  object->faceInfo = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, g_object_unref);
  object->__isset_faceInfo = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_add_feature_multi_args_finalize (GObject *object)
{
  IFaceLogAddFeatureMultiArgs *tobject = I_FACE_LOG_ADD_FEATURE_MULTI_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->feature != NULL)
  {
    thrift_string_free(tobject->feature);
    tobject->feature = NULL;
  }
  if (tobject->featureVersion != NULL)
  {
    g_free(tobject->featureVersion);
    tobject->featureVersion = NULL;
  }
  if (tobject->faceInfo != NULL)
  {
    g_hash_table_destroy (tobject->faceInfo);
    tobject->faceInfo = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_add_feature_multi_args_class_init (IFaceLogAddFeatureMultiArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_add_feature_multi_args_read;
  struct_class->write = i_face_log_add_feature_multi_args_write;

  gobject_class->finalize = i_face_log_add_feature_multi_args_finalize;
  gobject_class->get_property = i_face_log_add_feature_multi_args_get_property;
  gobject_class->set_property = i_face_log_add_feature_multi_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS_FEATURE,
     g_param_spec_boxed ("feature",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS_FEATURE_VERSION,
     g_param_spec_string ("featureVersion",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS_FACE_INFO,
     g_param_spec_boxed ("faceInfo",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_add_feature_multi_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogAddFeatureMultiArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_add_feature_multi_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogAddFeatureMultiArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_add_feature_multi_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogAddFeatureMultiArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogAddFeatureMultiResultProperties
{
  PROP_I_FACE_LOG_ADD_FEATURE_MULTI_RESULT_0,
  PROP_I_FACE_LOG_ADD_FEATURE_MULTI_RESULT_SUCCESS,
  PROP_I_FACE_LOG_ADD_FEATURE_MULTI_RESULT_EX1,
  PROP_I_FACE_LOG_ADD_FEATURE_MULTI_RESULT_EX2
};

/* reads a i_face_log_add_feature_multi_result object */
static gint32
i_face_log_add_feature_multi_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogAddFeatureMultiResult * this_object = I_FACE_LOG_ADD_FEATURE_MULTI_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_DUPLICATE_RECORD_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex2 != NULL)
          {
            g_object_unref (this_object->ex2);
          }
          this_object->ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex2);
            this_object->ex2 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_add_feature_multi_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogAddFeatureMultiResult * this_object = I_FACE_LOG_ADD_FEATURE_MULTI_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogAddFeatureMultiResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex2", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_add_feature_multi_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogAddFeatureMultiResult *self = I_FACE_LOG_ADD_FEATURE_MULTI_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_FEATURE_MULTI_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_MULTI_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_MULTI_RESULT_EX2:
      if (self->ex2 != NULL)
        g_object_unref (self->ex2);
      self->ex2 = g_value_dup_object (value);
      self->__isset_ex2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_add_feature_multi_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogAddFeatureMultiResult *self = I_FACE_LOG_ADD_FEATURE_MULTI_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_FEATURE_MULTI_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_MULTI_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_MULTI_RESULT_EX2:
      g_value_set_object (value, self->ex2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_add_feature_multi_result_instance_init (IFaceLogAddFeatureMultiResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_FEATURE_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
  object->ex2 = NULL;
  object->__isset_ex2 = FALSE;
}

static void 
i_face_log_add_feature_multi_result_finalize (GObject *object)
{
  IFaceLogAddFeatureMultiResult *tobject = I_FACE_LOG_ADD_FEATURE_MULTI_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
  if (tobject->ex2 != NULL)
  {
    g_object_unref(tobject->ex2);
    tobject->ex2 = NULL;
  }
}

static void
i_face_log_add_feature_multi_result_class_init (IFaceLogAddFeatureMultiResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_add_feature_multi_result_read;
  struct_class->write = i_face_log_add_feature_multi_result_write;

  gobject_class->finalize = i_face_log_add_feature_multi_result_finalize;
  gobject_class->get_property = i_face_log_add_feature_multi_result_get_property;
  gobject_class->set_property = i_face_log_add_feature_multi_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_MULTI_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_FEATURE_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_MULTI_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_DUPLICATE_RECORD_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_MULTI_RESULT_EX2,
     g_param_spec_object ("ex2",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_add_feature_multi_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogAddFeatureMultiResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_add_feature_multi_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogAddFeatureMultiResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_add_feature_multi_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogAddFeatureMultiResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogAddFeatureWithImageArgsProperties
{
  PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_0,
  PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_FEATURE,
  PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_FEATURE_VERSION,
  PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_PERSON_ID,
  PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_AS_ID_PHOTO_IF_ABSENT,
  PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_FEATURE_PHOTO,
  PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_FACE_BEAN,
  PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_TOKEN
};

/* reads a i_face_log_add_feature_with_image_args object */
static gint32
i_face_log_add_feature_with_image_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogAddFeatureWithImageArgs * this_object = I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS(object);
  gboolean isset_asIdPhotoIfAbsent = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->feature != NULL)
          {
            g_free(this_object->feature);
            this_object->feature = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->feature = g_byte_array_new();
          g_byte_array_append (this_object->feature, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_feature = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->featureVersion != NULL)
          {
            g_free(this_object->featureVersion);
            this_object->featureVersion = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->featureVersion, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_featureVersion = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->asIdPhotoIfAbsent, error)) < 0)
            return -1;
          xfer += ret;
          isset_asIdPhotoIfAbsent = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->featurePhoto != NULL)
          {
            g_free(this_object->featurePhoto);
            this_object->featurePhoto = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->featurePhoto = g_byte_array_new();
          g_byte_array_append (this_object->featurePhoto, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_featurePhoto = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->faceBean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_faceBean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_asIdPhotoIfAbsent)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_add_feature_with_image_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogAddFeatureWithImageArgs * this_object = I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogAddFeatureWithImageArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "feature", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->feature ? ((GByteArray *) this_object->feature)->data : NULL, this_object->feature ? ((GByteArray *) this_object->feature)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "featureVersion", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->featureVersion, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "asIdPhotoIfAbsent", T_BOOL, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->asIdPhotoIfAbsent, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "featurePhoto", T_STRING, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->featurePhoto ? ((GByteArray *) this_object->featurePhoto)->data : NULL, this_object->featurePhoto ? ((GByteArray *) this_object->featurePhoto)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "faceBean", T_STRUCT, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->faceBean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_add_feature_with_image_args_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogAddFeatureWithImageArgs *self = I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_FEATURE:
      if (self->feature != NULL)
        g_byte_array_unref (self->feature);
      self->feature = g_value_dup_boxed (value);
      self->__isset_feature = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_FEATURE_VERSION:
      if (self->featureVersion != NULL)
        g_free (self->featureVersion);
      self->featureVersion = g_value_dup_string (value);
      self->__isset_featureVersion = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_PERSON_ID:
      self->personId = g_value_get_int (value);
      self->__isset_personId = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_AS_ID_PHOTO_IF_ABSENT:
      self->asIdPhotoIfAbsent = g_value_get_boolean (value);
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_FEATURE_PHOTO:
      if (self->featurePhoto != NULL)
        g_byte_array_unref (self->featurePhoto);
      self->featurePhoto = g_value_dup_boxed (value);
      self->__isset_featurePhoto = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_FACE_BEAN:
      if (self->faceBean != NULL)
        g_object_unref (self->faceBean);
      self->faceBean = g_value_dup_object (value);
      self->__isset_faceBean = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_add_feature_with_image_args_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogAddFeatureWithImageArgs *self = I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_FEATURE:
      g_value_set_boxed (value, self->feature);
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_FEATURE_VERSION:
      g_value_set_string (value, self->featureVersion);
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_AS_ID_PHOTO_IF_ABSENT:
      g_value_set_boolean (value, self->asIdPhotoIfAbsent);
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_FEATURE_PHOTO:
      g_value_set_boxed (value, self->featurePhoto);
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_FACE_BEAN:
      g_value_set_object (value, self->faceBean);
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_add_feature_with_image_args_instance_init (IFaceLogAddFeatureWithImageArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->feature = NULL;
  object->__isset_feature = FALSE;
  object->featureVersion = NULL;
  object->__isset_featureVersion = FALSE;
  object->personId = 0;
  object->__isset_personId = FALSE;
  object->asIdPhotoIfAbsent = 0;
  object->featurePhoto = NULL;
  object->__isset_featurePhoto = FALSE;
  object->faceBean = g_object_new (TYPE_FACE_BEAN, NULL);
  object->__isset_faceBean = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_add_feature_with_image_args_finalize (GObject *object)
{
  IFaceLogAddFeatureWithImageArgs *tobject = I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->feature != NULL)
  {
    thrift_string_free(tobject->feature);
    tobject->feature = NULL;
  }
  if (tobject->featureVersion != NULL)
  {
    g_free(tobject->featureVersion);
    tobject->featureVersion = NULL;
  }
  if (tobject->featurePhoto != NULL)
  {
    thrift_string_free(tobject->featurePhoto);
    tobject->featurePhoto = NULL;
  }
  if (tobject->faceBean != NULL)
  {
    g_object_unref(tobject->faceBean);
    tobject->faceBean = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_add_feature_with_image_args_class_init (IFaceLogAddFeatureWithImageArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_add_feature_with_image_args_read;
  struct_class->write = i_face_log_add_feature_with_image_args_write;

  gobject_class->finalize = i_face_log_add_feature_with_image_args_finalize;
  gobject_class->get_property = i_face_log_add_feature_with_image_args_get_property;
  gobject_class->set_property = i_face_log_add_feature_with_image_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_FEATURE,
     g_param_spec_boxed ("feature",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_FEATURE_VERSION,
     g_param_spec_string ("featureVersion",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_AS_ID_PHOTO_IF_ABSENT,
     g_param_spec_boolean ("asIdPhotoIfAbsent",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_FEATURE_PHOTO,
     g_param_spec_boxed ("featurePhoto",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_FACE_BEAN,
     g_param_spec_object ("faceBean",
                         NULL,
                         NULL,
                         TYPE_FACE_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_add_feature_with_image_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogAddFeatureWithImageArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_add_feature_with_image_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogAddFeatureWithImageArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_add_feature_with_image_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogAddFeatureWithImageArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogAddFeatureWithImageResultProperties
{
  PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_RESULT_0,
  PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_RESULT_EX1,
  PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_RESULT_EX2
};

/* reads a i_face_log_add_feature_with_image_result object */
static gint32
i_face_log_add_feature_with_image_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogAddFeatureWithImageResult * this_object = I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_DUPLICATE_RECORD_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex2 != NULL)
          {
            g_object_unref (this_object->ex2);
          }
          this_object->ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex2);
            this_object->ex2 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_add_feature_with_image_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogAddFeatureWithImageResult * this_object = I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogAddFeatureWithImageResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex2", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_add_feature_with_image_result_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  IFaceLogAddFeatureWithImageResult *self = I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_RESULT_EX2:
      if (self->ex2 != NULL)
        g_object_unref (self->ex2);
      self->ex2 = g_value_dup_object (value);
      self->__isset_ex2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_add_feature_with_image_result_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  IFaceLogAddFeatureWithImageResult *self = I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    case PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_RESULT_EX2:
      g_value_set_object (value, self->ex2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_add_feature_with_image_result_instance_init (IFaceLogAddFeatureWithImageResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_FEATURE_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
  object->ex2 = NULL;
  object->__isset_ex2 = FALSE;
}

static void 
i_face_log_add_feature_with_image_result_finalize (GObject *object)
{
  IFaceLogAddFeatureWithImageResult *tobject = I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
  if (tobject->ex2 != NULL)
  {
    g_object_unref(tobject->ex2);
    tobject->ex2 = NULL;
  }
}

static void
i_face_log_add_feature_with_image_result_class_init (IFaceLogAddFeatureWithImageResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_add_feature_with_image_result_read;
  struct_class->write = i_face_log_add_feature_with_image_result_write;

  gobject_class->finalize = i_face_log_add_feature_with_image_result_finalize;
  gobject_class->get_property = i_face_log_add_feature_with_image_result_get_property;
  gobject_class->set_property = i_face_log_add_feature_with_image_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_FEATURE_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_DUPLICATE_RECORD_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_RESULT_EX2,
     g_param_spec_object ("ex2",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_add_feature_with_image_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogAddFeatureWithImageResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_add_feature_with_image_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogAddFeatureWithImageResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_add_feature_with_image_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogAddFeatureWithImageResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogAddImageArgsProperties
{
  PROP_I_FACE_LOG_ADD_IMAGE_ARGS_0,
  PROP_I_FACE_LOG_ADD_IMAGE_ARGS_IMAGE_DATA,
  PROP_I_FACE_LOG_ADD_IMAGE_ARGS_DEVICE_ID,
  PROP_I_FACE_LOG_ADD_IMAGE_ARGS_FACE_BEAN,
  PROP_I_FACE_LOG_ADD_IMAGE_ARGS_PERSON_ID,
  PROP_I_FACE_LOG_ADD_IMAGE_ARGS_TOKEN
};

/* reads a i_face_log_add_image_args object */
static gint32
i_face_log_add_image_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogAddImageArgs * this_object = I_FACE_LOG_ADD_IMAGE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->imageData != NULL)
          {
            g_free(this_object->imageData);
            this_object->imageData = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->imageData = g_byte_array_new();
          g_byte_array_append (this_object->imageData, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_imageData = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_deviceId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->faceBean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_faceBean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_add_image_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogAddImageArgs * this_object = I_FACE_LOG_ADD_IMAGE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogAddImageArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "imageData", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->imageData ? ((GByteArray *) this_object->imageData)->data : NULL, this_object->imageData ? ((GByteArray *) this_object->imageData)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceId", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "faceBean", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->faceBean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_add_image_args_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  IFaceLogAddImageArgs *self = I_FACE_LOG_ADD_IMAGE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_IMAGE_ARGS_IMAGE_DATA:
      if (self->imageData != NULL)
        g_byte_array_unref (self->imageData);
      self->imageData = g_value_dup_boxed (value);
      self->__isset_imageData = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_IMAGE_ARGS_DEVICE_ID:
      self->deviceId = g_value_get_int (value);
      self->__isset_deviceId = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_IMAGE_ARGS_FACE_BEAN:
      if (self->faceBean != NULL)
        g_object_unref (self->faceBean);
      self->faceBean = g_value_dup_object (value);
      self->__isset_faceBean = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_IMAGE_ARGS_PERSON_ID:
      self->personId = g_value_get_int (value);
      self->__isset_personId = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_IMAGE_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_add_image_args_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  IFaceLogAddImageArgs *self = I_FACE_LOG_ADD_IMAGE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_IMAGE_ARGS_IMAGE_DATA:
      g_value_set_boxed (value, self->imageData);
      break;

    case PROP_I_FACE_LOG_ADD_IMAGE_ARGS_DEVICE_ID:
      g_value_set_int (value, self->deviceId);
      break;

    case PROP_I_FACE_LOG_ADD_IMAGE_ARGS_FACE_BEAN:
      g_value_set_object (value, self->faceBean);
      break;

    case PROP_I_FACE_LOG_ADD_IMAGE_ARGS_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    case PROP_I_FACE_LOG_ADD_IMAGE_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_add_image_args_instance_init (IFaceLogAddImageArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->imageData = NULL;
  object->__isset_imageData = FALSE;
  object->deviceId = 0;
  object->__isset_deviceId = FALSE;
  object->faceBean = g_object_new (TYPE_FACE_BEAN, NULL);
  object->__isset_faceBean = FALSE;
  object->personId = 0;
  object->__isset_personId = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_add_image_args_finalize (GObject *object)
{
  IFaceLogAddImageArgs *tobject = I_FACE_LOG_ADD_IMAGE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->imageData != NULL)
  {
    thrift_string_free(tobject->imageData);
    tobject->imageData = NULL;
  }
  if (tobject->faceBean != NULL)
  {
    g_object_unref(tobject->faceBean);
    tobject->faceBean = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_add_image_args_class_init (IFaceLogAddImageArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_add_image_args_read;
  struct_class->write = i_face_log_add_image_args_write;

  gobject_class->finalize = i_face_log_add_image_args_finalize;
  gobject_class->get_property = i_face_log_add_image_args_get_property;
  gobject_class->set_property = i_face_log_add_image_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_IMAGE_ARGS_IMAGE_DATA,
     g_param_spec_boxed ("imageData",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_IMAGE_ARGS_DEVICE_ID,
     g_param_spec_int ("deviceId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_IMAGE_ARGS_FACE_BEAN,
     g_param_spec_object ("faceBean",
                         NULL,
                         NULL,
                         TYPE_FACE_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_IMAGE_ARGS_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_IMAGE_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_add_image_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogAddImageArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_add_image_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogAddImageArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_add_image_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogAddImageArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogAddImageResultProperties
{
  PROP_I_FACE_LOG_ADD_IMAGE_RESULT_0,
  PROP_I_FACE_LOG_ADD_IMAGE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_ADD_IMAGE_RESULT_EX1,
  PROP_I_FACE_LOG_ADD_IMAGE_RESULT_EX2
};

/* reads a i_face_log_add_image_result object */
static gint32
i_face_log_add_image_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogAddImageResult * this_object = I_FACE_LOG_ADD_IMAGE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_DUPLICATE_RECORD_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex2 != NULL)
          {
            g_object_unref (this_object->ex2);
          }
          this_object->ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex2);
            this_object->ex2 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_add_image_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogAddImageResult * this_object = I_FACE_LOG_ADD_IMAGE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogAddImageResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex2", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_add_image_result_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  IFaceLogAddImageResult *self = I_FACE_LOG_ADD_IMAGE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_IMAGE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_IMAGE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_IMAGE_RESULT_EX2:
      if (self->ex2 != NULL)
        g_object_unref (self->ex2);
      self->ex2 = g_value_dup_object (value);
      self->__isset_ex2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_add_image_result_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  IFaceLogAddImageResult *self = I_FACE_LOG_ADD_IMAGE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_IMAGE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_ADD_IMAGE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    case PROP_I_FACE_LOG_ADD_IMAGE_RESULT_EX2:
      g_value_set_object (value, self->ex2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_add_image_result_instance_init (IFaceLogAddImageResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_IMAGE_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
  object->ex2 = NULL;
  object->__isset_ex2 = FALSE;
}

static void 
i_face_log_add_image_result_finalize (GObject *object)
{
  IFaceLogAddImageResult *tobject = I_FACE_LOG_ADD_IMAGE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
  if (tobject->ex2 != NULL)
  {
    g_object_unref(tobject->ex2);
    tobject->ex2 = NULL;
  }
}

static void
i_face_log_add_image_result_class_init (IFaceLogAddImageResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_add_image_result_read;
  struct_class->write = i_face_log_add_image_result_write;

  gobject_class->finalize = i_face_log_add_image_result_finalize;
  gobject_class->get_property = i_face_log_add_image_result_get_property;
  gobject_class->set_property = i_face_log_add_image_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_IMAGE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_IMAGE_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_IMAGE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_DUPLICATE_RECORD_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_IMAGE_RESULT_EX2,
     g_param_spec_object ("ex2",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_add_image_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogAddImageResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_add_image_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogAddImageResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_add_image_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogAddImageResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogAddLogArgsProperties
{
  PROP_I_FACE_LOG_ADD_LOG_ARGS_0,
  PROP_I_FACE_LOG_ADD_LOG_ARGS_LOG_BEAN,
  PROP_I_FACE_LOG_ADD_LOG_ARGS_TOKEN
};

/* reads a i_face_log_add_log_args object */
static gint32
i_face_log_add_log_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogAddLogArgs * this_object = I_FACE_LOG_ADD_LOG_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->logBean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_logBean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_add_log_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogAddLogArgs * this_object = I_FACE_LOG_ADD_LOG_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogAddLogArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "logBean", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->logBean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_add_log_args_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  IFaceLogAddLogArgs *self = I_FACE_LOG_ADD_LOG_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_LOG_ARGS_LOG_BEAN:
      if (self->logBean != NULL)
        g_object_unref (self->logBean);
      self->logBean = g_value_dup_object (value);
      self->__isset_logBean = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_LOG_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_add_log_args_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  IFaceLogAddLogArgs *self = I_FACE_LOG_ADD_LOG_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_LOG_ARGS_LOG_BEAN:
      g_value_set_object (value, self->logBean);
      break;

    case PROP_I_FACE_LOG_ADD_LOG_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_add_log_args_instance_init (IFaceLogAddLogArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->logBean = g_object_new (TYPE_LOG_BEAN, NULL);
  object->__isset_logBean = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_add_log_args_finalize (GObject *object)
{
  IFaceLogAddLogArgs *tobject = I_FACE_LOG_ADD_LOG_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->logBean != NULL)
  {
    g_object_unref(tobject->logBean);
    tobject->logBean = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_add_log_args_class_init (IFaceLogAddLogArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_add_log_args_read;
  struct_class->write = i_face_log_add_log_args_write;

  gobject_class->finalize = i_face_log_add_log_args_finalize;
  gobject_class->get_property = i_face_log_add_log_args_get_property;
  gobject_class->set_property = i_face_log_add_log_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_LOG_ARGS_LOG_BEAN,
     g_param_spec_object ("logBean",
                         NULL,
                         NULL,
                         TYPE_LOG_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_LOG_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_add_log_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogAddLogArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_add_log_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogAddLogArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_add_log_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogAddLogArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogAddLogResultProperties
{
  PROP_I_FACE_LOG_ADD_LOG_RESULT_0,
  PROP_I_FACE_LOG_ADD_LOG_RESULT_EX1,
  PROP_I_FACE_LOG_ADD_LOG_RESULT_EX2
};

/* reads a i_face_log_add_log_result object */
static gint32
i_face_log_add_log_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogAddLogResult * this_object = I_FACE_LOG_ADD_LOG_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_DUPLICATE_RECORD_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex2 != NULL)
          {
            g_object_unref (this_object->ex2);
          }
          this_object->ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex2);
            this_object->ex2 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_add_log_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogAddLogResult * this_object = I_FACE_LOG_ADD_LOG_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogAddLogResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex2", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_add_log_result_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  IFaceLogAddLogResult *self = I_FACE_LOG_ADD_LOG_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_LOG_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_LOG_RESULT_EX2:
      if (self->ex2 != NULL)
        g_object_unref (self->ex2);
      self->ex2 = g_value_dup_object (value);
      self->__isset_ex2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_add_log_result_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  IFaceLogAddLogResult *self = I_FACE_LOG_ADD_LOG_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_LOG_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    case PROP_I_FACE_LOG_ADD_LOG_RESULT_EX2:
      g_value_set_object (value, self->ex2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_add_log_result_instance_init (IFaceLogAddLogResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
  object->ex2 = NULL;
  object->__isset_ex2 = FALSE;
}

static void 
i_face_log_add_log_result_finalize (GObject *object)
{
  IFaceLogAddLogResult *tobject = I_FACE_LOG_ADD_LOG_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
  if (tobject->ex2 != NULL)
  {
    g_object_unref(tobject->ex2);
    tobject->ex2 = NULL;
  }
}

static void
i_face_log_add_log_result_class_init (IFaceLogAddLogResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_add_log_result_read;
  struct_class->write = i_face_log_add_log_result_write;

  gobject_class->finalize = i_face_log_add_log_result_finalize;
  gobject_class->get_property = i_face_log_add_log_result_get_property;
  gobject_class->set_property = i_face_log_add_log_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_LOG_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_DUPLICATE_RECORD_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_LOG_RESULT_EX2,
     g_param_spec_object ("ex2",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_add_log_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogAddLogResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_add_log_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogAddLogResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_add_log_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogAddLogResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogAddLogFullArgsProperties
{
  PROP_I_FACE_LOG_ADD_LOG_FULL_ARGS_0,
  PROP_I_FACE_LOG_ADD_LOG_FULL_ARGS_LOG_BEAN,
  PROP_I_FACE_LOG_ADD_LOG_FULL_ARGS_FACE_BEAN,
  PROP_I_FACE_LOG_ADD_LOG_FULL_ARGS_FEATURE_IMAGE,
  PROP_I_FACE_LOG_ADD_LOG_FULL_ARGS_TOKEN
};

/* reads a i_face_log_add_log_full_args object */
static gint32
i_face_log_add_log_full_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogAddLogFullArgs * this_object = I_FACE_LOG_ADD_LOG_FULL_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->logBean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_logBean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->faceBean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_faceBean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->featureImage != NULL)
          {
            g_free(this_object->featureImage);
            this_object->featureImage = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->featureImage = g_byte_array_new();
          g_byte_array_append (this_object->featureImage, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_featureImage = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_add_log_full_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogAddLogFullArgs * this_object = I_FACE_LOG_ADD_LOG_FULL_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogAddLogFullArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "logBean", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->logBean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "faceBean", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->faceBean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "featureImage", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->featureImage ? ((GByteArray *) this_object->featureImage)->data : NULL, this_object->featureImage ? ((GByteArray *) this_object->featureImage)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_add_log_full_args_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogAddLogFullArgs *self = I_FACE_LOG_ADD_LOG_FULL_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_LOG_FULL_ARGS_LOG_BEAN:
      if (self->logBean != NULL)
        g_object_unref (self->logBean);
      self->logBean = g_value_dup_object (value);
      self->__isset_logBean = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_LOG_FULL_ARGS_FACE_BEAN:
      if (self->faceBean != NULL)
        g_object_unref (self->faceBean);
      self->faceBean = g_value_dup_object (value);
      self->__isset_faceBean = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_LOG_FULL_ARGS_FEATURE_IMAGE:
      if (self->featureImage != NULL)
        g_byte_array_unref (self->featureImage);
      self->featureImage = g_value_dup_boxed (value);
      self->__isset_featureImage = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_LOG_FULL_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_add_log_full_args_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogAddLogFullArgs *self = I_FACE_LOG_ADD_LOG_FULL_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_LOG_FULL_ARGS_LOG_BEAN:
      g_value_set_object (value, self->logBean);
      break;

    case PROP_I_FACE_LOG_ADD_LOG_FULL_ARGS_FACE_BEAN:
      g_value_set_object (value, self->faceBean);
      break;

    case PROP_I_FACE_LOG_ADD_LOG_FULL_ARGS_FEATURE_IMAGE:
      g_value_set_boxed (value, self->featureImage);
      break;

    case PROP_I_FACE_LOG_ADD_LOG_FULL_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_add_log_full_args_instance_init (IFaceLogAddLogFullArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->logBean = g_object_new (TYPE_LOG_BEAN, NULL);
  object->__isset_logBean = FALSE;
  object->faceBean = g_object_new (TYPE_FACE_BEAN, NULL);
  object->__isset_faceBean = FALSE;
  object->featureImage = NULL;
  object->__isset_featureImage = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_add_log_full_args_finalize (GObject *object)
{
  IFaceLogAddLogFullArgs *tobject = I_FACE_LOG_ADD_LOG_FULL_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->logBean != NULL)
  {
    g_object_unref(tobject->logBean);
    tobject->logBean = NULL;
  }
  if (tobject->faceBean != NULL)
  {
    g_object_unref(tobject->faceBean);
    tobject->faceBean = NULL;
  }
  if (tobject->featureImage != NULL)
  {
    thrift_string_free(tobject->featureImage);
    tobject->featureImage = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_add_log_full_args_class_init (IFaceLogAddLogFullArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_add_log_full_args_read;
  struct_class->write = i_face_log_add_log_full_args_write;

  gobject_class->finalize = i_face_log_add_log_full_args_finalize;
  gobject_class->get_property = i_face_log_add_log_full_args_get_property;
  gobject_class->set_property = i_face_log_add_log_full_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_LOG_FULL_ARGS_LOG_BEAN,
     g_param_spec_object ("logBean",
                         NULL,
                         NULL,
                         TYPE_LOG_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_LOG_FULL_ARGS_FACE_BEAN,
     g_param_spec_object ("faceBean",
                         NULL,
                         NULL,
                         TYPE_FACE_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_LOG_FULL_ARGS_FEATURE_IMAGE,
     g_param_spec_boxed ("featureImage",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_LOG_FULL_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_add_log_full_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogAddLogFullArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_add_log_full_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogAddLogFullArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_add_log_full_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogAddLogFullArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogAddLogFullResultProperties
{
  PROP_I_FACE_LOG_ADD_LOG_FULL_RESULT_0,
  PROP_I_FACE_LOG_ADD_LOG_FULL_RESULT_EX1,
  PROP_I_FACE_LOG_ADD_LOG_FULL_RESULT_EX2
};

/* reads a i_face_log_add_log_full_result object */
static gint32
i_face_log_add_log_full_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogAddLogFullResult * this_object = I_FACE_LOG_ADD_LOG_FULL_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_DUPLICATE_RECORD_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex2 != NULL)
          {
            g_object_unref (this_object->ex2);
          }
          this_object->ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex2);
            this_object->ex2 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_add_log_full_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogAddLogFullResult * this_object = I_FACE_LOG_ADD_LOG_FULL_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogAddLogFullResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex2", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_add_log_full_result_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogAddLogFullResult *self = I_FACE_LOG_ADD_LOG_FULL_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_LOG_FULL_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_LOG_FULL_RESULT_EX2:
      if (self->ex2 != NULL)
        g_object_unref (self->ex2);
      self->ex2 = g_value_dup_object (value);
      self->__isset_ex2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_add_log_full_result_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogAddLogFullResult *self = I_FACE_LOG_ADD_LOG_FULL_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_LOG_FULL_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    case PROP_I_FACE_LOG_ADD_LOG_FULL_RESULT_EX2:
      g_value_set_object (value, self->ex2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_add_log_full_result_instance_init (IFaceLogAddLogFullResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
  object->ex2 = NULL;
  object->__isset_ex2 = FALSE;
}

static void 
i_face_log_add_log_full_result_finalize (GObject *object)
{
  IFaceLogAddLogFullResult *tobject = I_FACE_LOG_ADD_LOG_FULL_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
  if (tobject->ex2 != NULL)
  {
    g_object_unref(tobject->ex2);
    tobject->ex2 = NULL;
  }
}

static void
i_face_log_add_log_full_result_class_init (IFaceLogAddLogFullResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_add_log_full_result_read;
  struct_class->write = i_face_log_add_log_full_result_write;

  gobject_class->finalize = i_face_log_add_log_full_result_finalize;
  gobject_class->get_property = i_face_log_add_log_full_result_get_property;
  gobject_class->set_property = i_face_log_add_log_full_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_LOG_FULL_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_DUPLICATE_RECORD_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_LOG_FULL_RESULT_EX2,
     g_param_spec_object ("ex2",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_add_log_full_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogAddLogFullResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_add_log_full_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogAddLogFullResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_add_log_full_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogAddLogFullResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogAddLogsArgsProperties
{
  PROP_I_FACE_LOG_ADD_LOGS_ARGS_0,
  PROP_I_FACE_LOG_ADD_LOGS_ARGS_BEANS,
  PROP_I_FACE_LOG_ADD_LOGS_ARGS_TOKEN
};

/* reads a i_face_log_add_logs_args object */
static gint32
i_face_log_add_logs_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogAddLogsArgs * this_object = I_FACE_LOG_ADD_LOGS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              LogBean * _elem8 = NULL;
              if ( _elem8 != NULL)
              {
                g_object_unref (_elem8);
              }
              _elem8 = g_object_new (TYPE_LOG_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem8), protocol, error)) < 0)
              {
                g_object_unref (_elem8);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->beans, _elem8);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_beans = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_add_logs_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogAddLogsArgs * this_object = I_FACE_LOG_ADD_LOGS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogAddLogsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "beans", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i9;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->beans ? this_object->beans->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i9 = 0; i9 < (this_object->beans ? this_object->beans->len : 0); i9++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->beans, i9))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_add_logs_args_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  IFaceLogAddLogsArgs *self = I_FACE_LOG_ADD_LOGS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_LOGS_ARGS_BEANS:
      if (self->beans != NULL)
        g_ptr_array_unref (self->beans);
      self->beans = g_value_dup_boxed (value);
      self->__isset_beans = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_LOGS_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_add_logs_args_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  IFaceLogAddLogsArgs *self = I_FACE_LOG_ADD_LOGS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_LOGS_ARGS_BEANS:
      g_value_set_boxed (value, self->beans);
      break;

    case PROP_I_FACE_LOG_ADD_LOGS_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_add_logs_args_instance_init (IFaceLogAddLogsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->beans = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_beans = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_add_logs_args_finalize (GObject *object)
{
  IFaceLogAddLogsArgs *tobject = I_FACE_LOG_ADD_LOGS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->beans != NULL)
  {
    g_ptr_array_unref (tobject->beans);
    tobject->beans = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_add_logs_args_class_init (IFaceLogAddLogsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_add_logs_args_read;
  struct_class->write = i_face_log_add_logs_args_write;

  gobject_class->finalize = i_face_log_add_logs_args_finalize;
  gobject_class->get_property = i_face_log_add_logs_args_get_property;
  gobject_class->set_property = i_face_log_add_logs_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_LOGS_ARGS_BEANS,
     g_param_spec_boxed ("beans",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_LOGS_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_add_logs_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogAddLogsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_add_logs_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogAddLogsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_add_logs_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogAddLogsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogAddLogsResultProperties
{
  PROP_I_FACE_LOG_ADD_LOGS_RESULT_0,
  PROP_I_FACE_LOG_ADD_LOGS_RESULT_EX1,
  PROP_I_FACE_LOG_ADD_LOGS_RESULT_EX2
};

/* reads a i_face_log_add_logs_result object */
static gint32
i_face_log_add_logs_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogAddLogsResult * this_object = I_FACE_LOG_ADD_LOGS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_DUPLICATE_RECORD_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex2 != NULL)
          {
            g_object_unref (this_object->ex2);
          }
          this_object->ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex2);
            this_object->ex2 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_add_logs_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogAddLogsResult * this_object = I_FACE_LOG_ADD_LOGS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogAddLogsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex2", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_add_logs_result_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  IFaceLogAddLogsResult *self = I_FACE_LOG_ADD_LOGS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_LOGS_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_LOGS_RESULT_EX2:
      if (self->ex2 != NULL)
        g_object_unref (self->ex2);
      self->ex2 = g_value_dup_object (value);
      self->__isset_ex2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_add_logs_result_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  IFaceLogAddLogsResult *self = I_FACE_LOG_ADD_LOGS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_LOGS_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    case PROP_I_FACE_LOG_ADD_LOGS_RESULT_EX2:
      g_value_set_object (value, self->ex2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_add_logs_result_instance_init (IFaceLogAddLogsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
  object->ex2 = NULL;
  object->__isset_ex2 = FALSE;
}

static void 
i_face_log_add_logs_result_finalize (GObject *object)
{
  IFaceLogAddLogsResult *tobject = I_FACE_LOG_ADD_LOGS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
  if (tobject->ex2 != NULL)
  {
    g_object_unref(tobject->ex2);
    tobject->ex2 = NULL;
  }
}

static void
i_face_log_add_logs_result_class_init (IFaceLogAddLogsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_add_logs_result_read;
  struct_class->write = i_face_log_add_logs_result_write;

  gobject_class->finalize = i_face_log_add_logs_result_finalize;
  gobject_class->get_property = i_face_log_add_logs_result_get_property;
  gobject_class->set_property = i_face_log_add_logs_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_LOGS_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_DUPLICATE_RECORD_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_LOGS_RESULT_EX2,
     g_param_spec_object ("ex2",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_add_logs_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogAddLogsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_add_logs_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogAddLogsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_add_logs_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogAddLogsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogAddLogsFullArgsProperties
{
  PROP_I_FACE_LOG_ADD_LOGS_FULL_ARGS_0,
  PROP_I_FACE_LOG_ADD_LOGS_FULL_ARGS_LOG_BEANS,
  PROP_I_FACE_LOG_ADD_LOGS_FULL_ARGS_FACE_BEANS,
  PROP_I_FACE_LOG_ADD_LOGS_FULL_ARGS_FEATURE_IMAGES,
  PROP_I_FACE_LOG_ADD_LOGS_FULL_ARGS_TOKEN
};

/* reads a i_face_log_add_logs_full_args object */
static gint32
i_face_log_add_logs_full_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogAddLogsFullArgs * this_object = I_FACE_LOG_ADD_LOGS_FULL_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              LogBean * _elem10 = NULL;
              if ( _elem10 != NULL)
              {
                g_object_unref (_elem10);
              }
              _elem10 = g_object_new (TYPE_LOG_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem10), protocol, error)) < 0)
              {
                g_object_unref (_elem10);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->logBeans, _elem10);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_logBeans = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              FaceBean * _elem11 = NULL;
              if ( _elem11 != NULL)
              {
                g_object_unref (_elem11);
              }
              _elem11 = g_object_new (TYPE_FACE_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem11), protocol, error)) < 0)
              {
                g_object_unref (_elem11);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->faceBeans, _elem11);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_faceBeans = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem12 = NULL;
              if (_elem12 != NULL)
              {
                g_free(_elem12);
                _elem12 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem12 = g_byte_array_new();
              g_byte_array_append (_elem12, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->featureImages, _elem12);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_featureImages = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_add_logs_full_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogAddLogsFullArgs * this_object = I_FACE_LOG_ADD_LOGS_FULL_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogAddLogsFullArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "logBeans", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i13;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->logBeans ? this_object->logBeans->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i13 = 0; i13 < (this_object->logBeans ? this_object->logBeans->len : 0); i13++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->logBeans, i13))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "faceBeans", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i14;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->faceBeans ? this_object->faceBeans->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i14 = 0; i14 < (this_object->faceBeans ? this_object->faceBeans->len : 0); i14++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->faceBeans, i14))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "featureImages", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i15;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->featureImages ? this_object->featureImages->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i15 = 0; i15 < (this_object->featureImages ? this_object->featureImages->len : 0); i15++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->featureImages, i15)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->featureImages, i15)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->featureImages, i15)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->featureImages, i15)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_add_logs_full_args_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogAddLogsFullArgs *self = I_FACE_LOG_ADD_LOGS_FULL_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_LOGS_FULL_ARGS_LOG_BEANS:
      if (self->logBeans != NULL)
        g_ptr_array_unref (self->logBeans);
      self->logBeans = g_value_dup_boxed (value);
      self->__isset_logBeans = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_LOGS_FULL_ARGS_FACE_BEANS:
      if (self->faceBeans != NULL)
        g_ptr_array_unref (self->faceBeans);
      self->faceBeans = g_value_dup_boxed (value);
      self->__isset_faceBeans = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_LOGS_FULL_ARGS_FEATURE_IMAGES:
      if (self->featureImages != NULL)
        g_ptr_array_unref (self->featureImages);
      self->featureImages = g_value_dup_boxed (value);
      self->__isset_featureImages = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_LOGS_FULL_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_add_logs_full_args_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogAddLogsFullArgs *self = I_FACE_LOG_ADD_LOGS_FULL_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_LOGS_FULL_ARGS_LOG_BEANS:
      g_value_set_boxed (value, self->logBeans);
      break;

    case PROP_I_FACE_LOG_ADD_LOGS_FULL_ARGS_FACE_BEANS:
      g_value_set_boxed (value, self->faceBeans);
      break;

    case PROP_I_FACE_LOG_ADD_LOGS_FULL_ARGS_FEATURE_IMAGES:
      g_value_set_boxed (value, self->featureImages);
      break;

    case PROP_I_FACE_LOG_ADD_LOGS_FULL_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_add_logs_full_args_instance_init (IFaceLogAddLogsFullArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->logBeans = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_logBeans = FALSE;
  object->faceBeans = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_faceBeans = FALSE;
  object->featureImages = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_featureImages = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_add_logs_full_args_finalize (GObject *object)
{
  IFaceLogAddLogsFullArgs *tobject = I_FACE_LOG_ADD_LOGS_FULL_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->logBeans != NULL)
  {
    g_ptr_array_unref (tobject->logBeans);
    tobject->logBeans = NULL;
  }
  if (tobject->faceBeans != NULL)
  {
    g_ptr_array_unref (tobject->faceBeans);
    tobject->faceBeans = NULL;
  }
  if (tobject->featureImages != NULL)
  {
    g_ptr_array_unref (tobject->featureImages);
    tobject->featureImages = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_add_logs_full_args_class_init (IFaceLogAddLogsFullArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_add_logs_full_args_read;
  struct_class->write = i_face_log_add_logs_full_args_write;

  gobject_class->finalize = i_face_log_add_logs_full_args_finalize;
  gobject_class->get_property = i_face_log_add_logs_full_args_get_property;
  gobject_class->set_property = i_face_log_add_logs_full_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_LOGS_FULL_ARGS_LOG_BEANS,
     g_param_spec_boxed ("logBeans",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_LOGS_FULL_ARGS_FACE_BEANS,
     g_param_spec_boxed ("faceBeans",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_LOGS_FULL_ARGS_FEATURE_IMAGES,
     g_param_spec_boxed ("featureImages",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_LOGS_FULL_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_add_logs_full_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogAddLogsFullArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_add_logs_full_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogAddLogsFullArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_add_logs_full_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogAddLogsFullArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogAddLogsFullResultProperties
{
  PROP_I_FACE_LOG_ADD_LOGS_FULL_RESULT_0,
  PROP_I_FACE_LOG_ADD_LOGS_FULL_RESULT_EX1,
  PROP_I_FACE_LOG_ADD_LOGS_FULL_RESULT_EX2
};

/* reads a i_face_log_add_logs_full_result object */
static gint32
i_face_log_add_logs_full_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogAddLogsFullResult * this_object = I_FACE_LOG_ADD_LOGS_FULL_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_DUPLICATE_RECORD_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex2 != NULL)
          {
            g_object_unref (this_object->ex2);
          }
          this_object->ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex2);
            this_object->ex2 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_add_logs_full_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogAddLogsFullResult * this_object = I_FACE_LOG_ADD_LOGS_FULL_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogAddLogsFullResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex2", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_add_logs_full_result_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogAddLogsFullResult *self = I_FACE_LOG_ADD_LOGS_FULL_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_LOGS_FULL_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    case PROP_I_FACE_LOG_ADD_LOGS_FULL_RESULT_EX2:
      if (self->ex2 != NULL)
        g_object_unref (self->ex2);
      self->ex2 = g_value_dup_object (value);
      self->__isset_ex2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_add_logs_full_result_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogAddLogsFullResult *self = I_FACE_LOG_ADD_LOGS_FULL_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ADD_LOGS_FULL_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    case PROP_I_FACE_LOG_ADD_LOGS_FULL_RESULT_EX2:
      g_value_set_object (value, self->ex2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_add_logs_full_result_instance_init (IFaceLogAddLogsFullResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
  object->ex2 = NULL;
  object->__isset_ex2 = FALSE;
}

static void 
i_face_log_add_logs_full_result_finalize (GObject *object)
{
  IFaceLogAddLogsFullResult *tobject = I_FACE_LOG_ADD_LOGS_FULL_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
  if (tobject->ex2 != NULL)
  {
    g_object_unref(tobject->ex2);
    tobject->ex2 = NULL;
  }
}

static void
i_face_log_add_logs_full_result_class_init (IFaceLogAddLogsFullResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_add_logs_full_result_read;
  struct_class->write = i_face_log_add_logs_full_result_write;

  gobject_class->finalize = i_face_log_add_logs_full_result_finalize;
  gobject_class->get_property = i_face_log_add_logs_full_result_get_property;
  gobject_class->set_property = i_face_log_add_logs_full_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_LOGS_FULL_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_DUPLICATE_RECORD_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ADD_LOGS_FULL_RESULT_EX2,
     g_param_spec_object ("ex2",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_add_logs_full_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogAddLogsFullResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_add_logs_full_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogAddLogsFullResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_add_logs_full_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogAddLogsFullResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogApplyAckChannelArgsProperties
{
  PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_ARGS_0,
  PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_ARGS_TOKEN
};

/* reads a i_face_log_apply_ack_channel_args object */
static gint32
i_face_log_apply_ack_channel_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogApplyAckChannelArgs * this_object = I_FACE_LOG_APPLY_ACK_CHANNEL_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_apply_ack_channel_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogApplyAckChannelArgs * this_object = I_FACE_LOG_APPLY_ACK_CHANNEL_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogApplyAckChannelArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_apply_ack_channel_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogApplyAckChannelArgs *self = I_FACE_LOG_APPLY_ACK_CHANNEL_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_apply_ack_channel_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogApplyAckChannelArgs *self = I_FACE_LOG_APPLY_ACK_CHANNEL_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_apply_ack_channel_args_instance_init (IFaceLogApplyAckChannelArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_apply_ack_channel_args_finalize (GObject *object)
{
  IFaceLogApplyAckChannelArgs *tobject = I_FACE_LOG_APPLY_ACK_CHANNEL_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_apply_ack_channel_args_class_init (IFaceLogApplyAckChannelArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_apply_ack_channel_args_read;
  struct_class->write = i_face_log_apply_ack_channel_args_write;

  gobject_class->finalize = i_face_log_apply_ack_channel_args_finalize;
  gobject_class->get_property = i_face_log_apply_ack_channel_args_get_property;
  gobject_class->set_property = i_face_log_apply_ack_channel_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_apply_ack_channel_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogApplyAckChannelArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_apply_ack_channel_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogApplyAckChannelArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_apply_ack_channel_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogApplyAckChannelArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogApplyAckChannelResultProperties
{
  PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_RESULT_0,
  PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_RESULT_SUCCESS,
  PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_RESULT_EX1
};

/* reads a i_face_log_apply_ack_channel_result object */
static gint32
i_face_log_apply_ack_channel_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogApplyAckChannelResult * this_object = I_FACE_LOG_APPLY_ACK_CHANNEL_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_apply_ack_channel_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogApplyAckChannelResult * this_object = I_FACE_LOG_APPLY_ACK_CHANNEL_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogApplyAckChannelResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_apply_ack_channel_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogApplyAckChannelResult *self = I_FACE_LOG_APPLY_ACK_CHANNEL_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_RESULT_SUCCESS:
      if (self->success != NULL)
        g_free (self->success);
      self->success = g_value_dup_string (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_apply_ack_channel_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogApplyAckChannelResult *self = I_FACE_LOG_APPLY_ACK_CHANNEL_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_RESULT_SUCCESS:
      g_value_set_string (value, self->success);
      break;

    case PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_apply_ack_channel_result_instance_init (IFaceLogApplyAckChannelResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_apply_ack_channel_result_finalize (GObject *object)
{
  IFaceLogApplyAckChannelResult *tobject = I_FACE_LOG_APPLY_ACK_CHANNEL_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_apply_ack_channel_result_class_init (IFaceLogApplyAckChannelResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_apply_ack_channel_result_read;
  struct_class->write = i_face_log_apply_ack_channel_result_write;

  gobject_class->finalize = i_face_log_apply_ack_channel_result_finalize;
  gobject_class->get_property = i_face_log_apply_ack_channel_result_get_property;
  gobject_class->set_property = i_face_log_apply_ack_channel_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_RESULT_SUCCESS,
     g_param_spec_string ("success",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_apply_ack_channel_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogApplyAckChannelResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_apply_ack_channel_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogApplyAckChannelResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_apply_ack_channel_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogApplyAckChannelResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogApplyAckChannelWithDurationArgsProperties
{
  PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_ARGS_0,
  PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_ARGS_DURATION,
  PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_ARGS_TOKEN
};

/* reads a i_face_log_apply_ack_channel_with_duration_args object */
static gint32
i_face_log_apply_ack_channel_with_duration_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogApplyAckChannelWithDurationArgs * this_object = I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_ARGS(object);
  gboolean isset_duration = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->duration, error)) < 0)
            return -1;
          xfer += ret;
          isset_duration = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_duration)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_apply_ack_channel_with_duration_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogApplyAckChannelWithDurationArgs * this_object = I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogApplyAckChannelWithDurationArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "duration", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->duration, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_apply_ack_channel_with_duration_args_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  IFaceLogApplyAckChannelWithDurationArgs *self = I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_ARGS_DURATION:
      self->duration = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_apply_ack_channel_with_duration_args_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  IFaceLogApplyAckChannelWithDurationArgs *self = I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_ARGS_DURATION:
      g_value_set_int (value, self->duration);
      break;

    case PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_apply_ack_channel_with_duration_args_instance_init (IFaceLogApplyAckChannelWithDurationArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->duration = 0;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_apply_ack_channel_with_duration_args_finalize (GObject *object)
{
  IFaceLogApplyAckChannelWithDurationArgs *tobject = I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_apply_ack_channel_with_duration_args_class_init (IFaceLogApplyAckChannelWithDurationArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_apply_ack_channel_with_duration_args_read;
  struct_class->write = i_face_log_apply_ack_channel_with_duration_args_write;

  gobject_class->finalize = i_face_log_apply_ack_channel_with_duration_args_finalize;
  gobject_class->get_property = i_face_log_apply_ack_channel_with_duration_args_get_property;
  gobject_class->set_property = i_face_log_apply_ack_channel_with_duration_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_ARGS_DURATION,
     g_param_spec_int ("duration",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_apply_ack_channel_with_duration_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogApplyAckChannelWithDurationArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_apply_ack_channel_with_duration_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogApplyAckChannelWithDurationArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_apply_ack_channel_with_duration_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogApplyAckChannelWithDurationArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogApplyAckChannelWithDurationResultProperties
{
  PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_RESULT_0,
  PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_RESULT_SUCCESS,
  PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_RESULT_EX1
};

/* reads a i_face_log_apply_ack_channel_with_duration_result object */
static gint32
i_face_log_apply_ack_channel_with_duration_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogApplyAckChannelWithDurationResult * this_object = I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_apply_ack_channel_with_duration_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogApplyAckChannelWithDurationResult * this_object = I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogApplyAckChannelWithDurationResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_apply_ack_channel_with_duration_result_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  IFaceLogApplyAckChannelWithDurationResult *self = I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_RESULT_SUCCESS:
      if (self->success != NULL)
        g_free (self->success);
      self->success = g_value_dup_string (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_apply_ack_channel_with_duration_result_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  IFaceLogApplyAckChannelWithDurationResult *self = I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_RESULT_SUCCESS:
      g_value_set_string (value, self->success);
      break;

    case PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_apply_ack_channel_with_duration_result_instance_init (IFaceLogApplyAckChannelWithDurationResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_apply_ack_channel_with_duration_result_finalize (GObject *object)
{
  IFaceLogApplyAckChannelWithDurationResult *tobject = I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_apply_ack_channel_with_duration_result_class_init (IFaceLogApplyAckChannelWithDurationResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_apply_ack_channel_with_duration_result_read;
  struct_class->write = i_face_log_apply_ack_channel_with_duration_result_write;

  gobject_class->finalize = i_face_log_apply_ack_channel_with_duration_result_finalize;
  gobject_class->get_property = i_face_log_apply_ack_channel_with_duration_result_get_property;
  gobject_class->set_property = i_face_log_apply_ack_channel_with_duration_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_RESULT_SUCCESS,
     g_param_spec_string ("success",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_apply_ack_channel_with_duration_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogApplyAckChannelWithDurationResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_apply_ack_channel_with_duration_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogApplyAckChannelWithDurationResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_apply_ack_channel_with_duration_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogApplyAckChannelWithDurationResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogApplyCmdSnArgsProperties
{
  PROP_I_FACE_LOG_APPLY_CMD_SN_ARGS_0,
  PROP_I_FACE_LOG_APPLY_CMD_SN_ARGS_TOKEN
};

/* reads a i_face_log_apply_cmd_sn_args object */
static gint32
i_face_log_apply_cmd_sn_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogApplyCmdSnArgs * this_object = I_FACE_LOG_APPLY_CMD_SN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_apply_cmd_sn_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogApplyCmdSnArgs * this_object = I_FACE_LOG_APPLY_CMD_SN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogApplyCmdSnArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_apply_cmd_sn_args_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogApplyCmdSnArgs *self = I_FACE_LOG_APPLY_CMD_SN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_CMD_SN_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_apply_cmd_sn_args_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogApplyCmdSnArgs *self = I_FACE_LOG_APPLY_CMD_SN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_CMD_SN_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_apply_cmd_sn_args_instance_init (IFaceLogApplyCmdSnArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_apply_cmd_sn_args_finalize (GObject *object)
{
  IFaceLogApplyCmdSnArgs *tobject = I_FACE_LOG_APPLY_CMD_SN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_apply_cmd_sn_args_class_init (IFaceLogApplyCmdSnArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_apply_cmd_sn_args_read;
  struct_class->write = i_face_log_apply_cmd_sn_args_write;

  gobject_class->finalize = i_face_log_apply_cmd_sn_args_finalize;
  gobject_class->get_property = i_face_log_apply_cmd_sn_args_get_property;
  gobject_class->set_property = i_face_log_apply_cmd_sn_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_CMD_SN_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_apply_cmd_sn_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogApplyCmdSnArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_apply_cmd_sn_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogApplyCmdSnArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_apply_cmd_sn_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogApplyCmdSnArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogApplyCmdSnResultProperties
{
  PROP_I_FACE_LOG_APPLY_CMD_SN_RESULT_0,
  PROP_I_FACE_LOG_APPLY_CMD_SN_RESULT_SUCCESS,
  PROP_I_FACE_LOG_APPLY_CMD_SN_RESULT_EX1
};

/* reads a i_face_log_apply_cmd_sn_result object */
static gint32
i_face_log_apply_cmd_sn_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogApplyCmdSnResult * this_object = I_FACE_LOG_APPLY_CMD_SN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_apply_cmd_sn_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogApplyCmdSnResult * this_object = I_FACE_LOG_APPLY_CMD_SN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogApplyCmdSnResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_apply_cmd_sn_result_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogApplyCmdSnResult *self = I_FACE_LOG_APPLY_CMD_SN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_CMD_SN_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_APPLY_CMD_SN_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_apply_cmd_sn_result_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogApplyCmdSnResult *self = I_FACE_LOG_APPLY_CMD_SN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_CMD_SN_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_APPLY_CMD_SN_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_apply_cmd_sn_result_instance_init (IFaceLogApplyCmdSnResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_apply_cmd_sn_result_finalize (GObject *object)
{
  IFaceLogApplyCmdSnResult *tobject = I_FACE_LOG_APPLY_CMD_SN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_apply_cmd_sn_result_class_init (IFaceLogApplyCmdSnResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_apply_cmd_sn_result_read;
  struct_class->write = i_face_log_apply_cmd_sn_result_write;

  gobject_class->finalize = i_face_log_apply_cmd_sn_result_finalize;
  gobject_class->get_property = i_face_log_apply_cmd_sn_result_get_property;
  gobject_class->set_property = i_face_log_apply_cmd_sn_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_CMD_SN_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_CMD_SN_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_apply_cmd_sn_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogApplyCmdSnResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_apply_cmd_sn_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogApplyCmdSnResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_apply_cmd_sn_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogApplyCmdSnResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogApplyPersonTokenArgsProperties
{
  PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_ARGS_0,
  PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_ARGS_PERSON_ID,
  PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_ARGS_PASSWORD,
  PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_ARGS_IS_MD5
};

/* reads a i_face_log_apply_person_token_args object */
static gint32
i_face_log_apply_person_token_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogApplyPersonTokenArgs * this_object = I_FACE_LOG_APPLY_PERSON_TOKEN_ARGS(object);
  gboolean isset_personId = FALSE;
  gboolean isset_isMd5 = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->password != NULL)
          {
            g_free(this_object->password);
            this_object->password = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->password, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_password = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->isMd5, error)) < 0)
            return -1;
          xfer += ret;
          isset_isMd5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_isMd5)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_apply_person_token_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogApplyPersonTokenArgs * this_object = I_FACE_LOG_APPLY_PERSON_TOKEN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogApplyPersonTokenArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "password", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->password, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "isMd5", T_BOOL, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->isMd5, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_apply_person_token_args_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogApplyPersonTokenArgs *self = I_FACE_LOG_APPLY_PERSON_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_ARGS_PERSON_ID:
      self->personId = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_ARGS_PASSWORD:
      if (self->password != NULL)
        g_free (self->password);
      self->password = g_value_dup_string (value);
      self->__isset_password = TRUE;
      break;

    case PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_ARGS_IS_MD5:
      self->isMd5 = g_value_get_boolean (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_apply_person_token_args_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogApplyPersonTokenArgs *self = I_FACE_LOG_APPLY_PERSON_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_ARGS_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    case PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_ARGS_PASSWORD:
      g_value_set_string (value, self->password);
      break;

    case PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_ARGS_IS_MD5:
      g_value_set_boolean (value, self->isMd5);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_apply_person_token_args_instance_init (IFaceLogApplyPersonTokenArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personId = 0;
  object->password = NULL;
  object->__isset_password = FALSE;
  object->isMd5 = 0;
}

static void 
i_face_log_apply_person_token_args_finalize (GObject *object)
{
  IFaceLogApplyPersonTokenArgs *tobject = I_FACE_LOG_APPLY_PERSON_TOKEN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->password != NULL)
  {
    g_free(tobject->password);
    tobject->password = NULL;
  }
}

static void
i_face_log_apply_person_token_args_class_init (IFaceLogApplyPersonTokenArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_apply_person_token_args_read;
  struct_class->write = i_face_log_apply_person_token_args_write;

  gobject_class->finalize = i_face_log_apply_person_token_args_finalize;
  gobject_class->get_property = i_face_log_apply_person_token_args_get_property;
  gobject_class->set_property = i_face_log_apply_person_token_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_ARGS_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_ARGS_PASSWORD,
     g_param_spec_string ("password",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_ARGS_IS_MD5,
     g_param_spec_boolean ("isMd5",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
i_face_log_apply_person_token_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogApplyPersonTokenArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_apply_person_token_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogApplyPersonTokenArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_apply_person_token_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogApplyPersonTokenArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogApplyPersonTokenResultProperties
{
  PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_RESULT_0,
  PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_RESULT_SUCCESS,
  PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_RESULT_EX1,
  PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_RESULT_EX2
};

/* reads a i_face_log_apply_person_token_result object */
static gint32
i_face_log_apply_person_token_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogApplyPersonTokenResult * this_object = I_FACE_LOG_APPLY_PERSON_TOKEN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_SECURITY_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex2 != NULL)
          {
            g_object_unref (this_object->ex2);
          }
          this_object->ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex2);
            this_object->ex2 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_apply_person_token_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogApplyPersonTokenResult * this_object = I_FACE_LOG_APPLY_PERSON_TOKEN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogApplyPersonTokenResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex2", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_apply_person_token_result_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogApplyPersonTokenResult *self = I_FACE_LOG_APPLY_PERSON_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    case PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_RESULT_EX2:
      if (self->ex2 != NULL)
        g_object_unref (self->ex2);
      self->ex2 = g_value_dup_object (value);
      self->__isset_ex2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_apply_person_token_result_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogApplyPersonTokenResult *self = I_FACE_LOG_APPLY_PERSON_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    case PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_RESULT_EX2:
      g_value_set_object (value, self->ex2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_apply_person_token_result_instance_init (IFaceLogApplyPersonTokenResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
  object->ex2 = NULL;
  object->__isset_ex2 = FALSE;
}

static void 
i_face_log_apply_person_token_result_finalize (GObject *object)
{
  IFaceLogApplyPersonTokenResult *tobject = I_FACE_LOG_APPLY_PERSON_TOKEN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
  if (tobject->ex2 != NULL)
  {
    g_object_unref(tobject->ex2);
    tobject->ex2 = NULL;
  }
}

static void
i_face_log_apply_person_token_result_class_init (IFaceLogApplyPersonTokenResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_apply_person_token_result_read;
  struct_class->write = i_face_log_apply_person_token_result_write;

  gobject_class->finalize = i_face_log_apply_person_token_result_finalize;
  gobject_class->get_property = i_face_log_apply_person_token_result_get_property;
  gobject_class->set_property = i_face_log_apply_person_token_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_SECURITY_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_PERSON_TOKEN_RESULT_EX2,
     g_param_spec_object ("ex2",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_apply_person_token_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogApplyPersonTokenResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_apply_person_token_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogApplyPersonTokenResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_apply_person_token_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogApplyPersonTokenResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogApplyRootTokenArgsProperties
{
  PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_ARGS_0,
  PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_ARGS_PASSWORD,
  PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_ARGS_IS_MD5
};

/* reads a i_face_log_apply_root_token_args object */
static gint32
i_face_log_apply_root_token_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogApplyRootTokenArgs * this_object = I_FACE_LOG_APPLY_ROOT_TOKEN_ARGS(object);
  gboolean isset_isMd5 = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->password != NULL)
          {
            g_free(this_object->password);
            this_object->password = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->password, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_password = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->isMd5, error)) < 0)
            return -1;
          xfer += ret;
          isset_isMd5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_isMd5)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_apply_root_token_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogApplyRootTokenArgs * this_object = I_FACE_LOG_APPLY_ROOT_TOKEN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogApplyRootTokenArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "password", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->password, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "isMd5", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->isMd5, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_apply_root_token_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogApplyRootTokenArgs *self = I_FACE_LOG_APPLY_ROOT_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_ARGS_PASSWORD:
      if (self->password != NULL)
        g_free (self->password);
      self->password = g_value_dup_string (value);
      self->__isset_password = TRUE;
      break;

    case PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_ARGS_IS_MD5:
      self->isMd5 = g_value_get_boolean (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_apply_root_token_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogApplyRootTokenArgs *self = I_FACE_LOG_APPLY_ROOT_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_ARGS_PASSWORD:
      g_value_set_string (value, self->password);
      break;

    case PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_ARGS_IS_MD5:
      g_value_set_boolean (value, self->isMd5);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_apply_root_token_args_instance_init (IFaceLogApplyRootTokenArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->password = NULL;
  object->__isset_password = FALSE;
  object->isMd5 = 0;
}

static void 
i_face_log_apply_root_token_args_finalize (GObject *object)
{
  IFaceLogApplyRootTokenArgs *tobject = I_FACE_LOG_APPLY_ROOT_TOKEN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->password != NULL)
  {
    g_free(tobject->password);
    tobject->password = NULL;
  }
}

static void
i_face_log_apply_root_token_args_class_init (IFaceLogApplyRootTokenArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_apply_root_token_args_read;
  struct_class->write = i_face_log_apply_root_token_args_write;

  gobject_class->finalize = i_face_log_apply_root_token_args_finalize;
  gobject_class->get_property = i_face_log_apply_root_token_args_get_property;
  gobject_class->set_property = i_face_log_apply_root_token_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_ARGS_PASSWORD,
     g_param_spec_string ("password",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_ARGS_IS_MD5,
     g_param_spec_boolean ("isMd5",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
i_face_log_apply_root_token_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogApplyRootTokenArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_apply_root_token_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogApplyRootTokenArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_apply_root_token_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogApplyRootTokenArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogApplyRootTokenResultProperties
{
  PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_RESULT_0,
  PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_RESULT_SUCCESS,
  PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_RESULT_EX1,
  PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_RESULT_EX2
};

/* reads a i_face_log_apply_root_token_result object */
static gint32
i_face_log_apply_root_token_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogApplyRootTokenResult * this_object = I_FACE_LOG_APPLY_ROOT_TOKEN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_SECURITY_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex2 != NULL)
          {
            g_object_unref (this_object->ex2);
          }
          this_object->ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex2);
            this_object->ex2 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_apply_root_token_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogApplyRootTokenResult * this_object = I_FACE_LOG_APPLY_ROOT_TOKEN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogApplyRootTokenResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex2", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_apply_root_token_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogApplyRootTokenResult *self = I_FACE_LOG_APPLY_ROOT_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    case PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_RESULT_EX2:
      if (self->ex2 != NULL)
        g_object_unref (self->ex2);
      self->ex2 = g_value_dup_object (value);
      self->__isset_ex2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_apply_root_token_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogApplyRootTokenResult *self = I_FACE_LOG_APPLY_ROOT_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    case PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_RESULT_EX2:
      g_value_set_object (value, self->ex2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_apply_root_token_result_instance_init (IFaceLogApplyRootTokenResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
  object->ex2 = NULL;
  object->__isset_ex2 = FALSE;
}

static void 
i_face_log_apply_root_token_result_finalize (GObject *object)
{
  IFaceLogApplyRootTokenResult *tobject = I_FACE_LOG_APPLY_ROOT_TOKEN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
  if (tobject->ex2 != NULL)
  {
    g_object_unref(tobject->ex2);
    tobject->ex2 = NULL;
  }
}

static void
i_face_log_apply_root_token_result_class_init (IFaceLogApplyRootTokenResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_apply_root_token_result_read;
  struct_class->write = i_face_log_apply_root_token_result_write;

  gobject_class->finalize = i_face_log_apply_root_token_result_finalize;
  gobject_class->get_property = i_face_log_apply_root_token_result_get_property;
  gobject_class->set_property = i_face_log_apply_root_token_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_SECURITY_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_ROOT_TOKEN_RESULT_EX2,
     g_param_spec_object ("ex2",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_apply_root_token_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogApplyRootTokenResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_apply_root_token_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogApplyRootTokenResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_apply_root_token_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogApplyRootTokenResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogApplyUserTokenArgsProperties
{
  PROP_I_FACE_LOG_APPLY_USER_TOKEN_ARGS_0,
  PROP_I_FACE_LOG_APPLY_USER_TOKEN_ARGS_USERID,
  PROP_I_FACE_LOG_APPLY_USER_TOKEN_ARGS_PASSWORD,
  PROP_I_FACE_LOG_APPLY_USER_TOKEN_ARGS_IS_MD5
};

/* reads a i_face_log_apply_user_token_args object */
static gint32
i_face_log_apply_user_token_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogApplyUserTokenArgs * this_object = I_FACE_LOG_APPLY_USER_TOKEN_ARGS(object);
  gboolean isset_userid = FALSE;
  gboolean isset_isMd5 = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->userid, error)) < 0)
            return -1;
          xfer += ret;
          isset_userid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->password != NULL)
          {
            g_free(this_object->password);
            this_object->password = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->password, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_password = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->isMd5, error)) < 0)
            return -1;
          xfer += ret;
          isset_isMd5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_userid)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_isMd5)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_apply_user_token_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogApplyUserTokenArgs * this_object = I_FACE_LOG_APPLY_USER_TOKEN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogApplyUserTokenArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "userid", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->userid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "password", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->password, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "isMd5", T_BOOL, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->isMd5, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_apply_user_token_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogApplyUserTokenArgs *self = I_FACE_LOG_APPLY_USER_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_USER_TOKEN_ARGS_USERID:
      self->userid = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_APPLY_USER_TOKEN_ARGS_PASSWORD:
      if (self->password != NULL)
        g_free (self->password);
      self->password = g_value_dup_string (value);
      self->__isset_password = TRUE;
      break;

    case PROP_I_FACE_LOG_APPLY_USER_TOKEN_ARGS_IS_MD5:
      self->isMd5 = g_value_get_boolean (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_apply_user_token_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogApplyUserTokenArgs *self = I_FACE_LOG_APPLY_USER_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_USER_TOKEN_ARGS_USERID:
      g_value_set_int (value, self->userid);
      break;

    case PROP_I_FACE_LOG_APPLY_USER_TOKEN_ARGS_PASSWORD:
      g_value_set_string (value, self->password);
      break;

    case PROP_I_FACE_LOG_APPLY_USER_TOKEN_ARGS_IS_MD5:
      g_value_set_boolean (value, self->isMd5);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_apply_user_token_args_instance_init (IFaceLogApplyUserTokenArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->userid = 0;
  object->password = NULL;
  object->__isset_password = FALSE;
  object->isMd5 = 0;
}

static void 
i_face_log_apply_user_token_args_finalize (GObject *object)
{
  IFaceLogApplyUserTokenArgs *tobject = I_FACE_LOG_APPLY_USER_TOKEN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->password != NULL)
  {
    g_free(tobject->password);
    tobject->password = NULL;
  }
}

static void
i_face_log_apply_user_token_args_class_init (IFaceLogApplyUserTokenArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_apply_user_token_args_read;
  struct_class->write = i_face_log_apply_user_token_args_write;

  gobject_class->finalize = i_face_log_apply_user_token_args_finalize;
  gobject_class->get_property = i_face_log_apply_user_token_args_get_property;
  gobject_class->set_property = i_face_log_apply_user_token_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_USER_TOKEN_ARGS_USERID,
     g_param_spec_int ("userid",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_USER_TOKEN_ARGS_PASSWORD,
     g_param_spec_string ("password",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_USER_TOKEN_ARGS_IS_MD5,
     g_param_spec_boolean ("isMd5",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
i_face_log_apply_user_token_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogApplyUserTokenArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_apply_user_token_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogApplyUserTokenArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_apply_user_token_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogApplyUserTokenArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogApplyUserTokenResultProperties
{
  PROP_I_FACE_LOG_APPLY_USER_TOKEN_RESULT_0,
  PROP_I_FACE_LOG_APPLY_USER_TOKEN_RESULT_SUCCESS,
  PROP_I_FACE_LOG_APPLY_USER_TOKEN_RESULT_EX1,
  PROP_I_FACE_LOG_APPLY_USER_TOKEN_RESULT_EX2
};

/* reads a i_face_log_apply_user_token_result object */
static gint32
i_face_log_apply_user_token_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogApplyUserTokenResult * this_object = I_FACE_LOG_APPLY_USER_TOKEN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_SECURITY_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex2 != NULL)
          {
            g_object_unref (this_object->ex2);
          }
          this_object->ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex2);
            this_object->ex2 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_apply_user_token_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogApplyUserTokenResult * this_object = I_FACE_LOG_APPLY_USER_TOKEN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogApplyUserTokenResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex2", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_apply_user_token_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogApplyUserTokenResult *self = I_FACE_LOG_APPLY_USER_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_USER_TOKEN_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_APPLY_USER_TOKEN_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    case PROP_I_FACE_LOG_APPLY_USER_TOKEN_RESULT_EX2:
      if (self->ex2 != NULL)
        g_object_unref (self->ex2);
      self->ex2 = g_value_dup_object (value);
      self->__isset_ex2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_apply_user_token_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogApplyUserTokenResult *self = I_FACE_LOG_APPLY_USER_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_APPLY_USER_TOKEN_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_APPLY_USER_TOKEN_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    case PROP_I_FACE_LOG_APPLY_USER_TOKEN_RESULT_EX2:
      g_value_set_object (value, self->ex2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_apply_user_token_result_instance_init (IFaceLogApplyUserTokenResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
  object->ex2 = NULL;
  object->__isset_ex2 = FALSE;
}

static void 
i_face_log_apply_user_token_result_finalize (GObject *object)
{
  IFaceLogApplyUserTokenResult *tobject = I_FACE_LOG_APPLY_USER_TOKEN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
  if (tobject->ex2 != NULL)
  {
    g_object_unref(tobject->ex2);
    tobject->ex2 = NULL;
  }
}

static void
i_face_log_apply_user_token_result_class_init (IFaceLogApplyUserTokenResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_apply_user_token_result_read;
  struct_class->write = i_face_log_apply_user_token_result_write;

  gobject_class->finalize = i_face_log_apply_user_token_result_finalize;
  gobject_class->get_property = i_face_log_apply_user_token_result_get_property;
  gobject_class->set_property = i_face_log_apply_user_token_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_USER_TOKEN_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_USER_TOKEN_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_SECURITY_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_APPLY_USER_TOKEN_RESULT_EX2,
     g_param_spec_object ("ex2",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_apply_user_token_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogApplyUserTokenResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_apply_user_token_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogApplyUserTokenResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_apply_user_token_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogApplyUserTokenResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogBindBorderArgsProperties
{
  PROP_I_FACE_LOG_BIND_BORDER_ARGS_0,
  PROP_I_FACE_LOG_BIND_BORDER_ARGS_PERSON_GROUP_ID,
  PROP_I_FACE_LOG_BIND_BORDER_ARGS_DEVICE_GROUP_ID,
  PROP_I_FACE_LOG_BIND_BORDER_ARGS_TOKEN
};

/* reads a i_face_log_bind_border_args object */
static gint32
i_face_log_bind_border_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogBindBorderArgs * this_object = I_FACE_LOG_BIND_BORDER_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personGroupId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_personGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceGroupId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_deviceGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_bind_border_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogBindBorderArgs * this_object = I_FACE_LOG_BIND_BORDER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogBindBorderArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_bind_border_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  IFaceLogBindBorderArgs *self = I_FACE_LOG_BIND_BORDER_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_BIND_BORDER_ARGS_PERSON_GROUP_ID:
      self->personGroupId = g_value_get_int (value);
      self->__isset_personGroupId = TRUE;
      break;

    case PROP_I_FACE_LOG_BIND_BORDER_ARGS_DEVICE_GROUP_ID:
      self->deviceGroupId = g_value_get_int (value);
      self->__isset_deviceGroupId = TRUE;
      break;

    case PROP_I_FACE_LOG_BIND_BORDER_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_bind_border_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  IFaceLogBindBorderArgs *self = I_FACE_LOG_BIND_BORDER_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_BIND_BORDER_ARGS_PERSON_GROUP_ID:
      g_value_set_int (value, self->personGroupId);
      break;

    case PROP_I_FACE_LOG_BIND_BORDER_ARGS_DEVICE_GROUP_ID:
      g_value_set_int (value, self->deviceGroupId);
      break;

    case PROP_I_FACE_LOG_BIND_BORDER_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_bind_border_args_instance_init (IFaceLogBindBorderArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personGroupId = 0;
  object->__isset_personGroupId = FALSE;
  object->deviceGroupId = 0;
  object->__isset_deviceGroupId = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_bind_border_args_finalize (GObject *object)
{
  IFaceLogBindBorderArgs *tobject = I_FACE_LOG_BIND_BORDER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_bind_border_args_class_init (IFaceLogBindBorderArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_bind_border_args_read;
  struct_class->write = i_face_log_bind_border_args_write;

  gobject_class->finalize = i_face_log_bind_border_args_finalize;
  gobject_class->get_property = i_face_log_bind_border_args_get_property;
  gobject_class->set_property = i_face_log_bind_border_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_BIND_BORDER_ARGS_PERSON_GROUP_ID,
     g_param_spec_int ("personGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_BIND_BORDER_ARGS_DEVICE_GROUP_ID,
     g_param_spec_int ("deviceGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_BIND_BORDER_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_bind_border_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogBindBorderArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_bind_border_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogBindBorderArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_bind_border_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogBindBorderArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogBindBorderResultProperties
{
  PROP_I_FACE_LOG_BIND_BORDER_RESULT_0,
  PROP_I_FACE_LOG_BIND_BORDER_RESULT_EX1
};

/* reads a i_face_log_bind_border_result object */
static gint32
i_face_log_bind_border_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogBindBorderResult * this_object = I_FACE_LOG_BIND_BORDER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_bind_border_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogBindBorderResult * this_object = I_FACE_LOG_BIND_BORDER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogBindBorderResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_bind_border_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogBindBorderResult *self = I_FACE_LOG_BIND_BORDER_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_BIND_BORDER_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_bind_border_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogBindBorderResult *self = I_FACE_LOG_BIND_BORDER_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_BIND_BORDER_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_bind_border_result_instance_init (IFaceLogBindBorderResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_bind_border_result_finalize (GObject *object)
{
  IFaceLogBindBorderResult *tobject = I_FACE_LOG_BIND_BORDER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_bind_border_result_class_init (IFaceLogBindBorderResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_bind_border_result_read;
  struct_class->write = i_face_log_bind_border_result_write;

  gobject_class->finalize = i_face_log_bind_border_result_finalize;
  gobject_class->get_property = i_face_log_bind_border_result_get_property;
  gobject_class->set_property = i_face_log_bind_border_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_BIND_BORDER_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_bind_border_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogBindBorderResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_bind_border_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogBindBorderResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_bind_border_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogBindBorderResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogChildListForDeviceGroupArgsProperties
{
  PROP_I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_ARGS_0,
  PROP_I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID
};

/* reads a i_face_log_child_list_for_device_group_args object */
static gint32
i_face_log_child_list_for_device_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogChildListForDeviceGroupArgs * this_object = I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_ARGS(object);
  gboolean isset_deviceGroupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_deviceGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_deviceGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_child_list_for_device_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogChildListForDeviceGroupArgs * this_object = I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogChildListForDeviceGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_child_list_for_device_group_args_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  IFaceLogChildListForDeviceGroupArgs *self = I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID:
      self->deviceGroupId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_child_list_for_device_group_args_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  IFaceLogChildListForDeviceGroupArgs *self = I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID:
      g_value_set_int (value, self->deviceGroupId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_child_list_for_device_group_args_instance_init (IFaceLogChildListForDeviceGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->deviceGroupId = 0;
}

static void 
i_face_log_child_list_for_device_group_args_finalize (GObject *object)
{
  IFaceLogChildListForDeviceGroupArgs *tobject = I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_child_list_for_device_group_args_class_init (IFaceLogChildListForDeviceGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_child_list_for_device_group_args_read;
  struct_class->write = i_face_log_child_list_for_device_group_args_write;

  gobject_class->finalize = i_face_log_child_list_for_device_group_args_finalize;
  gobject_class->get_property = i_face_log_child_list_for_device_group_args_get_property;
  gobject_class->set_property = i_face_log_child_list_for_device_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID,
     g_param_spec_int ("deviceGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_child_list_for_device_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogChildListForDeviceGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_child_list_for_device_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogChildListForDeviceGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_child_list_for_device_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogChildListForDeviceGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogChildListForDeviceGroupResultProperties
{
  PROP_I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_RESULT_0,
  PROP_I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_RESULT_SUCCESS,
  PROP_I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_RESULT_EX1
};

/* reads a i_face_log_child_list_for_device_group_result object */
static gint32
i_face_log_child_list_for_device_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogChildListForDeviceGroupResult * this_object = I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem16 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem16, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem16, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_child_list_for_device_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogChildListForDeviceGroupResult * this_object = I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogChildListForDeviceGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i17;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i17 = 0; i17 < (this_object->success ? this_object->success->len : 0); i17++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i17)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_child_list_for_device_group_result_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogChildListForDeviceGroupResult *self = I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_child_list_for_device_group_result_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogChildListForDeviceGroupResult *self = I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_child_list_for_device_group_result_instance_init (IFaceLogChildListForDeviceGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_child_list_for_device_group_result_finalize (GObject *object)
{
  IFaceLogChildListForDeviceGroupResult *tobject = I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_child_list_for_device_group_result_class_init (IFaceLogChildListForDeviceGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_child_list_for_device_group_result_read;
  struct_class->write = i_face_log_child_list_for_device_group_result_write;

  gobject_class->finalize = i_face_log_child_list_for_device_group_result_finalize;
  gobject_class->get_property = i_face_log_child_list_for_device_group_result_get_property;
  gobject_class->set_property = i_face_log_child_list_for_device_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_child_list_for_device_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogChildListForDeviceGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_child_list_for_device_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogChildListForDeviceGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_child_list_for_device_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogChildListForDeviceGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogChildListForPersonGroupArgsProperties
{
  PROP_I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_ARGS_0,
  PROP_I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_ARGS_PERSON_GROUP_ID
};

/* reads a i_face_log_child_list_for_person_group_args object */
static gint32
i_face_log_child_list_for_person_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogChildListForPersonGroupArgs * this_object = I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_ARGS(object);
  gboolean isset_personGroupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_child_list_for_person_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogChildListForPersonGroupArgs * this_object = I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogChildListForPersonGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_child_list_for_person_group_args_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  IFaceLogChildListForPersonGroupArgs *self = I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_ARGS_PERSON_GROUP_ID:
      self->personGroupId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_child_list_for_person_group_args_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  IFaceLogChildListForPersonGroupArgs *self = I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_ARGS_PERSON_GROUP_ID:
      g_value_set_int (value, self->personGroupId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_child_list_for_person_group_args_instance_init (IFaceLogChildListForPersonGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personGroupId = 0;
}

static void 
i_face_log_child_list_for_person_group_args_finalize (GObject *object)
{
  IFaceLogChildListForPersonGroupArgs *tobject = I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_child_list_for_person_group_args_class_init (IFaceLogChildListForPersonGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_child_list_for_person_group_args_read;
  struct_class->write = i_face_log_child_list_for_person_group_args_write;

  gobject_class->finalize = i_face_log_child_list_for_person_group_args_finalize;
  gobject_class->get_property = i_face_log_child_list_for_person_group_args_get_property;
  gobject_class->set_property = i_face_log_child_list_for_person_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_ARGS_PERSON_GROUP_ID,
     g_param_spec_int ("personGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_child_list_for_person_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogChildListForPersonGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_child_list_for_person_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogChildListForPersonGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_child_list_for_person_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogChildListForPersonGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogChildListForPersonGroupResultProperties
{
  PROP_I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_RESULT_0,
  PROP_I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_RESULT_SUCCESS,
  PROP_I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_RESULT_EX1
};

/* reads a i_face_log_child_list_for_person_group_result object */
static gint32
i_face_log_child_list_for_person_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogChildListForPersonGroupResult * this_object = I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem18 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem18, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem18, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_child_list_for_person_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogChildListForPersonGroupResult * this_object = I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogChildListForPersonGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i19;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i19 = 0; i19 < (this_object->success ? this_object->success->len : 0); i19++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i19)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_child_list_for_person_group_result_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogChildListForPersonGroupResult *self = I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_child_list_for_person_group_result_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogChildListForPersonGroupResult *self = I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_child_list_for_person_group_result_instance_init (IFaceLogChildListForPersonGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_child_list_for_person_group_result_finalize (GObject *object)
{
  IFaceLogChildListForPersonGroupResult *tobject = I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_child_list_for_person_group_result_class_init (IFaceLogChildListForPersonGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_child_list_for_person_group_result_read;
  struct_class->write = i_face_log_child_list_for_person_group_result_write;

  gobject_class->finalize = i_face_log_child_list_for_person_group_result_finalize;
  gobject_class->get_property = i_face_log_child_list_for_person_group_result_get_property;
  gobject_class->set_property = i_face_log_child_list_for_person_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_child_list_for_person_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogChildListForPersonGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_child_list_for_person_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogChildListForPersonGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_child_list_for_person_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogChildListForPersonGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogCountDeviceByWhereArgsProperties
{
  PROP_I_FACE_LOG_COUNT_DEVICE_BY_WHERE_ARGS_0,
  PROP_I_FACE_LOG_COUNT_DEVICE_BY_WHERE_ARGS_WHERE
};

/* reads a i_face_log_count_device_by_where_args object */
static gint32
i_face_log_count_device_by_where_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogCountDeviceByWhereArgs * this_object = I_FACE_LOG_COUNT_DEVICE_BY_WHERE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->where != NULL)
          {
            g_free(this_object->where);
            this_object->where = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->where, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_where = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_count_device_by_where_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogCountDeviceByWhereArgs * this_object = I_FACE_LOG_COUNT_DEVICE_BY_WHERE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogCountDeviceByWhereArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->where, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_count_device_by_where_args_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogCountDeviceByWhereArgs *self = I_FACE_LOG_COUNT_DEVICE_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_DEVICE_BY_WHERE_ARGS_WHERE:
      if (self->where != NULL)
        g_free (self->where);
      self->where = g_value_dup_string (value);
      self->__isset_where = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_count_device_by_where_args_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogCountDeviceByWhereArgs *self = I_FACE_LOG_COUNT_DEVICE_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_DEVICE_BY_WHERE_ARGS_WHERE:
      g_value_set_string (value, self->where);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_count_device_by_where_args_instance_init (IFaceLogCountDeviceByWhereArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->where = NULL;
  object->__isset_where = FALSE;
}

static void 
i_face_log_count_device_by_where_args_finalize (GObject *object)
{
  IFaceLogCountDeviceByWhereArgs *tobject = I_FACE_LOG_COUNT_DEVICE_BY_WHERE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->where != NULL)
  {
    g_free(tobject->where);
    tobject->where = NULL;
  }
}

static void
i_face_log_count_device_by_where_args_class_init (IFaceLogCountDeviceByWhereArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_count_device_by_where_args_read;
  struct_class->write = i_face_log_count_device_by_where_args_write;

  gobject_class->finalize = i_face_log_count_device_by_where_args_finalize;
  gobject_class->get_property = i_face_log_count_device_by_where_args_get_property;
  gobject_class->set_property = i_face_log_count_device_by_where_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_DEVICE_BY_WHERE_ARGS_WHERE,
     g_param_spec_string ("where",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_count_device_by_where_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogCountDeviceByWhereArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_count_device_by_where_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogCountDeviceByWhereArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_count_device_by_where_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogCountDeviceByWhereArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogCountDeviceByWhereResultProperties
{
  PROP_I_FACE_LOG_COUNT_DEVICE_BY_WHERE_RESULT_0,
  PROP_I_FACE_LOG_COUNT_DEVICE_BY_WHERE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_COUNT_DEVICE_BY_WHERE_RESULT_EX1
};

/* reads a i_face_log_count_device_by_where_result object */
static gint32
i_face_log_count_device_by_where_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogCountDeviceByWhereResult * this_object = I_FACE_LOG_COUNT_DEVICE_BY_WHERE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_count_device_by_where_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogCountDeviceByWhereResult * this_object = I_FACE_LOG_COUNT_DEVICE_BY_WHERE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogCountDeviceByWhereResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_count_device_by_where_result_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  IFaceLogCountDeviceByWhereResult *self = I_FACE_LOG_COUNT_DEVICE_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_DEVICE_BY_WHERE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_COUNT_DEVICE_BY_WHERE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_count_device_by_where_result_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  IFaceLogCountDeviceByWhereResult *self = I_FACE_LOG_COUNT_DEVICE_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_DEVICE_BY_WHERE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_COUNT_DEVICE_BY_WHERE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_count_device_by_where_result_instance_init (IFaceLogCountDeviceByWhereResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_count_device_by_where_result_finalize (GObject *object)
{
  IFaceLogCountDeviceByWhereResult *tobject = I_FACE_LOG_COUNT_DEVICE_BY_WHERE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_count_device_by_where_result_class_init (IFaceLogCountDeviceByWhereResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_count_device_by_where_result_read;
  struct_class->write = i_face_log_count_device_by_where_result_write;

  gobject_class->finalize = i_face_log_count_device_by_where_result_finalize;
  gobject_class->get_property = i_face_log_count_device_by_where_result_get_property;
  gobject_class->set_property = i_face_log_count_device_by_where_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_DEVICE_BY_WHERE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_DEVICE_BY_WHERE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_count_device_by_where_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogCountDeviceByWhereResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_count_device_by_where_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogCountDeviceByWhereResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_count_device_by_where_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogCountDeviceByWhereResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogCountDeviceGroupByWhereArgsProperties
{
  PROP_I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_ARGS_0,
  PROP_I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_ARGS_WHERE
};

/* reads a i_face_log_count_device_group_by_where_args object */
static gint32
i_face_log_count_device_group_by_where_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogCountDeviceGroupByWhereArgs * this_object = I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->where != NULL)
          {
            g_free(this_object->where);
            this_object->where = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->where, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_where = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_count_device_group_by_where_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogCountDeviceGroupByWhereArgs * this_object = I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogCountDeviceGroupByWhereArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->where, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_count_device_group_by_where_args_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  IFaceLogCountDeviceGroupByWhereArgs *self = I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_ARGS_WHERE:
      if (self->where != NULL)
        g_free (self->where);
      self->where = g_value_dup_string (value);
      self->__isset_where = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_count_device_group_by_where_args_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  IFaceLogCountDeviceGroupByWhereArgs *self = I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_ARGS_WHERE:
      g_value_set_string (value, self->where);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_count_device_group_by_where_args_instance_init (IFaceLogCountDeviceGroupByWhereArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->where = NULL;
  object->__isset_where = FALSE;
}

static void 
i_face_log_count_device_group_by_where_args_finalize (GObject *object)
{
  IFaceLogCountDeviceGroupByWhereArgs *tobject = I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->where != NULL)
  {
    g_free(tobject->where);
    tobject->where = NULL;
  }
}

static void
i_face_log_count_device_group_by_where_args_class_init (IFaceLogCountDeviceGroupByWhereArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_count_device_group_by_where_args_read;
  struct_class->write = i_face_log_count_device_group_by_where_args_write;

  gobject_class->finalize = i_face_log_count_device_group_by_where_args_finalize;
  gobject_class->get_property = i_face_log_count_device_group_by_where_args_get_property;
  gobject_class->set_property = i_face_log_count_device_group_by_where_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_ARGS_WHERE,
     g_param_spec_string ("where",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_count_device_group_by_where_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogCountDeviceGroupByWhereArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_count_device_group_by_where_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogCountDeviceGroupByWhereArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_count_device_group_by_where_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogCountDeviceGroupByWhereArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogCountDeviceGroupByWhereResultProperties
{
  PROP_I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_RESULT_0,
  PROP_I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_RESULT_EX1
};

/* reads a i_face_log_count_device_group_by_where_result object */
static gint32
i_face_log_count_device_group_by_where_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogCountDeviceGroupByWhereResult * this_object = I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_count_device_group_by_where_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogCountDeviceGroupByWhereResult * this_object = I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogCountDeviceGroupByWhereResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_count_device_group_by_where_result_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogCountDeviceGroupByWhereResult *self = I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_count_device_group_by_where_result_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogCountDeviceGroupByWhereResult *self = I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_count_device_group_by_where_result_instance_init (IFaceLogCountDeviceGroupByWhereResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_count_device_group_by_where_result_finalize (GObject *object)
{
  IFaceLogCountDeviceGroupByWhereResult *tobject = I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_count_device_group_by_where_result_class_init (IFaceLogCountDeviceGroupByWhereResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_count_device_group_by_where_result_read;
  struct_class->write = i_face_log_count_device_group_by_where_result_write;

  gobject_class->finalize = i_face_log_count_device_group_by_where_result_finalize;
  gobject_class->get_property = i_face_log_count_device_group_by_where_result_get_property;
  gobject_class->set_property = i_face_log_count_device_group_by_where_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_count_device_group_by_where_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogCountDeviceGroupByWhereResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_count_device_group_by_where_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogCountDeviceGroupByWhereResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_count_device_group_by_where_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogCountDeviceGroupByWhereResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogCountLogByWhereArgsProperties
{
  PROP_I_FACE_LOG_COUNT_LOG_BY_WHERE_ARGS_0,
  PROP_I_FACE_LOG_COUNT_LOG_BY_WHERE_ARGS_WHERE
};

/* reads a i_face_log_count_log_by_where_args object */
static gint32
i_face_log_count_log_by_where_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogCountLogByWhereArgs * this_object = I_FACE_LOG_COUNT_LOG_BY_WHERE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->where != NULL)
          {
            g_free(this_object->where);
            this_object->where = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->where, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_where = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_count_log_by_where_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogCountLogByWhereArgs * this_object = I_FACE_LOG_COUNT_LOG_BY_WHERE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogCountLogByWhereArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->where, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_count_log_by_where_args_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogCountLogByWhereArgs *self = I_FACE_LOG_COUNT_LOG_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_LOG_BY_WHERE_ARGS_WHERE:
      if (self->where != NULL)
        g_free (self->where);
      self->where = g_value_dup_string (value);
      self->__isset_where = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_count_log_by_where_args_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogCountLogByWhereArgs *self = I_FACE_LOG_COUNT_LOG_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_LOG_BY_WHERE_ARGS_WHERE:
      g_value_set_string (value, self->where);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_count_log_by_where_args_instance_init (IFaceLogCountLogByWhereArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->where = NULL;
  object->__isset_where = FALSE;
}

static void 
i_face_log_count_log_by_where_args_finalize (GObject *object)
{
  IFaceLogCountLogByWhereArgs *tobject = I_FACE_LOG_COUNT_LOG_BY_WHERE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->where != NULL)
  {
    g_free(tobject->where);
    tobject->where = NULL;
  }
}

static void
i_face_log_count_log_by_where_args_class_init (IFaceLogCountLogByWhereArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_count_log_by_where_args_read;
  struct_class->write = i_face_log_count_log_by_where_args_write;

  gobject_class->finalize = i_face_log_count_log_by_where_args_finalize;
  gobject_class->get_property = i_face_log_count_log_by_where_args_get_property;
  gobject_class->set_property = i_face_log_count_log_by_where_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_LOG_BY_WHERE_ARGS_WHERE,
     g_param_spec_string ("where",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_count_log_by_where_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogCountLogByWhereArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_count_log_by_where_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogCountLogByWhereArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_count_log_by_where_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogCountLogByWhereArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogCountLogByWhereResultProperties
{
  PROP_I_FACE_LOG_COUNT_LOG_BY_WHERE_RESULT_0,
  PROP_I_FACE_LOG_COUNT_LOG_BY_WHERE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_COUNT_LOG_BY_WHERE_RESULT_EX1
};

/* reads a i_face_log_count_log_by_where_result object */
static gint32
i_face_log_count_log_by_where_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogCountLogByWhereResult * this_object = I_FACE_LOG_COUNT_LOG_BY_WHERE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_count_log_by_where_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogCountLogByWhereResult * this_object = I_FACE_LOG_COUNT_LOG_BY_WHERE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogCountLogByWhereResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_count_log_by_where_result_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogCountLogByWhereResult *self = I_FACE_LOG_COUNT_LOG_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_LOG_BY_WHERE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_COUNT_LOG_BY_WHERE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_count_log_by_where_result_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogCountLogByWhereResult *self = I_FACE_LOG_COUNT_LOG_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_LOG_BY_WHERE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_COUNT_LOG_BY_WHERE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_count_log_by_where_result_instance_init (IFaceLogCountLogByWhereResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_count_log_by_where_result_finalize (GObject *object)
{
  IFaceLogCountLogByWhereResult *tobject = I_FACE_LOG_COUNT_LOG_BY_WHERE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_count_log_by_where_result_class_init (IFaceLogCountLogByWhereResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_count_log_by_where_result_read;
  struct_class->write = i_face_log_count_log_by_where_result_write;

  gobject_class->finalize = i_face_log_count_log_by_where_result_finalize;
  gobject_class->get_property = i_face_log_count_log_by_where_result_get_property;
  gobject_class->set_property = i_face_log_count_log_by_where_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_LOG_BY_WHERE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_LOG_BY_WHERE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_count_log_by_where_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogCountLogByWhereResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_count_log_by_where_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogCountLogByWhereResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_count_log_by_where_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogCountLogByWhereResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogCountLogLightByVerifyTimeArgsProperties
{
  PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_ARGS_0,
  PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_ARGS_TIMESTAMP
};

/* reads a i_face_log_count_log_light_by_verify_time_args object */
static gint32
i_face_log_count_log_light_by_verify_time_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogCountLogLightByVerifyTimeArgs * this_object = I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_ARGS(object);
  gboolean isset_timestamp = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_timestamp)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_count_log_light_by_verify_time_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogCountLogLightByVerifyTimeArgs * this_object = I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogCountLogLightByVerifyTimeArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_count_log_light_by_verify_time_args_set_property (GObject *object,
                                                             guint property_id,
                                                             const GValue *value,
                                                             GParamSpec *pspec)
{
  IFaceLogCountLogLightByVerifyTimeArgs *self = I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_ARGS_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_count_log_light_by_verify_time_args_get_property (GObject *object,
                                                             guint property_id,
                                                             GValue *value,
                                                             GParamSpec *pspec)
{
  IFaceLogCountLogLightByVerifyTimeArgs *self = I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_ARGS_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_count_log_light_by_verify_time_args_instance_init (IFaceLogCountLogLightByVerifyTimeArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->timestamp = 0;
}

static void 
i_face_log_count_log_light_by_verify_time_args_finalize (GObject *object)
{
  IFaceLogCountLogLightByVerifyTimeArgs *tobject = I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_count_log_light_by_verify_time_args_class_init (IFaceLogCountLogLightByVerifyTimeArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_count_log_light_by_verify_time_args_read;
  struct_class->write = i_face_log_count_log_light_by_verify_time_args_write;

  gobject_class->finalize = i_face_log_count_log_light_by_verify_time_args_finalize;
  gobject_class->get_property = i_face_log_count_log_light_by_verify_time_args_get_property;
  gobject_class->set_property = i_face_log_count_log_light_by_verify_time_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_ARGS_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
i_face_log_count_log_light_by_verify_time_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogCountLogLightByVerifyTimeArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_count_log_light_by_verify_time_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogCountLogLightByVerifyTimeArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_count_log_light_by_verify_time_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogCountLogLightByVerifyTimeArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogCountLogLightByVerifyTimeResultProperties
{
  PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_RESULT_0,
  PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_RESULT_SUCCESS,
  PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_RESULT_EX1
};

/* reads a i_face_log_count_log_light_by_verify_time_result object */
static gint32
i_face_log_count_log_light_by_verify_time_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogCountLogLightByVerifyTimeResult * this_object = I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_count_log_light_by_verify_time_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogCountLogLightByVerifyTimeResult * this_object = I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogCountLogLightByVerifyTimeResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_count_log_light_by_verify_time_result_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  IFaceLogCountLogLightByVerifyTimeResult *self = I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_count_log_light_by_verify_time_result_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  IFaceLogCountLogLightByVerifyTimeResult *self = I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_count_log_light_by_verify_time_result_instance_init (IFaceLogCountLogLightByVerifyTimeResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_count_log_light_by_verify_time_result_finalize (GObject *object)
{
  IFaceLogCountLogLightByVerifyTimeResult *tobject = I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_count_log_light_by_verify_time_result_class_init (IFaceLogCountLogLightByVerifyTimeResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_count_log_light_by_verify_time_result_read;
  struct_class->write = i_face_log_count_log_light_by_verify_time_result_write;

  gobject_class->finalize = i_face_log_count_log_light_by_verify_time_result_finalize;
  gobject_class->get_property = i_face_log_count_log_light_by_verify_time_result_get_property;
  gobject_class->set_property = i_face_log_count_log_light_by_verify_time_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_count_log_light_by_verify_time_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogCountLogLightByVerifyTimeResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_count_log_light_by_verify_time_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogCountLogLightByVerifyTimeResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_count_log_light_by_verify_time_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogCountLogLightByVerifyTimeResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogCountLogLightByVerifyTimeTimestrArgsProperties
{
  PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS_0,
  PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS_TIMESTAMP
};

/* reads a i_face_log_count_log_light_by_verify_time_timestr_args object */
static gint32
i_face_log_count_log_light_by_verify_time_timestr_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogCountLogLightByVerifyTimeTimestrArgs * this_object = I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->timestamp != NULL)
          {
            g_free(this_object->timestamp);
            this_object->timestamp = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_count_log_light_by_verify_time_timestr_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogCountLogLightByVerifyTimeTimestrArgs * this_object = I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogCountLogLightByVerifyTimeTimestrArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_count_log_light_by_verify_time_timestr_args_set_property (GObject *object,
                                                                     guint property_id,
                                                                     const GValue *value,
                                                                     GParamSpec *pspec)
{
  IFaceLogCountLogLightByVerifyTimeTimestrArgs *self = I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS_TIMESTAMP:
      if (self->timestamp != NULL)
        g_free (self->timestamp);
      self->timestamp = g_value_dup_string (value);
      self->__isset_timestamp = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_count_log_light_by_verify_time_timestr_args_get_property (GObject *object,
                                                                     guint property_id,
                                                                     GValue *value,
                                                                     GParamSpec *pspec)
{
  IFaceLogCountLogLightByVerifyTimeTimestrArgs *self = I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS_TIMESTAMP:
      g_value_set_string (value, self->timestamp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_count_log_light_by_verify_time_timestr_args_instance_init (IFaceLogCountLogLightByVerifyTimeTimestrArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->timestamp = NULL;
  object->__isset_timestamp = FALSE;
}

static void 
i_face_log_count_log_light_by_verify_time_timestr_args_finalize (GObject *object)
{
  IFaceLogCountLogLightByVerifyTimeTimestrArgs *tobject = I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->timestamp != NULL)
  {
    g_free(tobject->timestamp);
    tobject->timestamp = NULL;
  }
}

static void
i_face_log_count_log_light_by_verify_time_timestr_args_class_init (IFaceLogCountLogLightByVerifyTimeTimestrArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_count_log_light_by_verify_time_timestr_args_read;
  struct_class->write = i_face_log_count_log_light_by_verify_time_timestr_args_write;

  gobject_class->finalize = i_face_log_count_log_light_by_verify_time_timestr_args_finalize;
  gobject_class->get_property = i_face_log_count_log_light_by_verify_time_timestr_args_get_property;
  gobject_class->set_property = i_face_log_count_log_light_by_verify_time_timestr_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS_TIMESTAMP,
     g_param_spec_string ("timestamp",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_count_log_light_by_verify_time_timestr_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogCountLogLightByVerifyTimeTimestrArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_count_log_light_by_verify_time_timestr_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogCountLogLightByVerifyTimeTimestrArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_count_log_light_by_verify_time_timestr_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogCountLogLightByVerifyTimeTimestrArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogCountLogLightByVerifyTimeTimestrResultProperties
{
  PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT_0,
  PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT_SUCCESS,
  PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT_EX1
};

/* reads a i_face_log_count_log_light_by_verify_time_timestr_result object */
static gint32
i_face_log_count_log_light_by_verify_time_timestr_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogCountLogLightByVerifyTimeTimestrResult * this_object = I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_count_log_light_by_verify_time_timestr_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogCountLogLightByVerifyTimeTimestrResult * this_object = I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogCountLogLightByVerifyTimeTimestrResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_count_log_light_by_verify_time_timestr_result_set_property (GObject *object,
                                                                       guint property_id,
                                                                       const GValue *value,
                                                                       GParamSpec *pspec)
{
  IFaceLogCountLogLightByVerifyTimeTimestrResult *self = I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_count_log_light_by_verify_time_timestr_result_get_property (GObject *object,
                                                                       guint property_id,
                                                                       GValue *value,
                                                                       GParamSpec *pspec)
{
  IFaceLogCountLogLightByVerifyTimeTimestrResult *self = I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_count_log_light_by_verify_time_timestr_result_instance_init (IFaceLogCountLogLightByVerifyTimeTimestrResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_count_log_light_by_verify_time_timestr_result_finalize (GObject *object)
{
  IFaceLogCountLogLightByVerifyTimeTimestrResult *tobject = I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_count_log_light_by_verify_time_timestr_result_class_init (IFaceLogCountLogLightByVerifyTimeTimestrResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_count_log_light_by_verify_time_timestr_result_read;
  struct_class->write = i_face_log_count_log_light_by_verify_time_timestr_result_write;

  gobject_class->finalize = i_face_log_count_log_light_by_verify_time_timestr_result_finalize;
  gobject_class->get_property = i_face_log_count_log_light_by_verify_time_timestr_result_get_property;
  gobject_class->set_property = i_face_log_count_log_light_by_verify_time_timestr_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_count_log_light_by_verify_time_timestr_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogCountLogLightByVerifyTimeTimestrResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_count_log_light_by_verify_time_timestr_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogCountLogLightByVerifyTimeTimestrResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_count_log_light_by_verify_time_timestr_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogCountLogLightByVerifyTimeTimestrResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogCountLogLightByWhereArgsProperties
{
  PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_ARGS_0,
  PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_ARGS_WHERE
};

/* reads a i_face_log_count_log_light_by_where_args object */
static gint32
i_face_log_count_log_light_by_where_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogCountLogLightByWhereArgs * this_object = I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->where != NULL)
          {
            g_free(this_object->where);
            this_object->where = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->where, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_where = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_count_log_light_by_where_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogCountLogLightByWhereArgs * this_object = I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogCountLogLightByWhereArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->where, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_count_log_light_by_where_args_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  IFaceLogCountLogLightByWhereArgs *self = I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_ARGS_WHERE:
      if (self->where != NULL)
        g_free (self->where);
      self->where = g_value_dup_string (value);
      self->__isset_where = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_count_log_light_by_where_args_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  IFaceLogCountLogLightByWhereArgs *self = I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_ARGS_WHERE:
      g_value_set_string (value, self->where);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_count_log_light_by_where_args_instance_init (IFaceLogCountLogLightByWhereArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->where = NULL;
  object->__isset_where = FALSE;
}

static void 
i_face_log_count_log_light_by_where_args_finalize (GObject *object)
{
  IFaceLogCountLogLightByWhereArgs *tobject = I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->where != NULL)
  {
    g_free(tobject->where);
    tobject->where = NULL;
  }
}

static void
i_face_log_count_log_light_by_where_args_class_init (IFaceLogCountLogLightByWhereArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_count_log_light_by_where_args_read;
  struct_class->write = i_face_log_count_log_light_by_where_args_write;

  gobject_class->finalize = i_face_log_count_log_light_by_where_args_finalize;
  gobject_class->get_property = i_face_log_count_log_light_by_where_args_get_property;
  gobject_class->set_property = i_face_log_count_log_light_by_where_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_ARGS_WHERE,
     g_param_spec_string ("where",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_count_log_light_by_where_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogCountLogLightByWhereArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_count_log_light_by_where_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogCountLogLightByWhereArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_count_log_light_by_where_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogCountLogLightByWhereArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogCountLogLightByWhereResultProperties
{
  PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_RESULT_0,
  PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_RESULT_EX1
};

/* reads a i_face_log_count_log_light_by_where_result object */
static gint32
i_face_log_count_log_light_by_where_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogCountLogLightByWhereResult * this_object = I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_count_log_light_by_where_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogCountLogLightByWhereResult * this_object = I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogCountLogLightByWhereResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_count_log_light_by_where_result_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  IFaceLogCountLogLightByWhereResult *self = I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_count_log_light_by_where_result_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  IFaceLogCountLogLightByWhereResult *self = I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_count_log_light_by_where_result_instance_init (IFaceLogCountLogLightByWhereResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_count_log_light_by_where_result_finalize (GObject *object)
{
  IFaceLogCountLogLightByWhereResult *tobject = I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_count_log_light_by_where_result_class_init (IFaceLogCountLogLightByWhereResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_count_log_light_by_where_result_read;
  struct_class->write = i_face_log_count_log_light_by_where_result_write;

  gobject_class->finalize = i_face_log_count_log_light_by_where_result_finalize;
  gobject_class->get_property = i_face_log_count_log_light_by_where_result_get_property;
  gobject_class->set_property = i_face_log_count_log_light_by_where_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_count_log_light_by_where_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogCountLogLightByWhereResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_count_log_light_by_where_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogCountLogLightByWhereResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_count_log_light_by_where_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogCountLogLightByWhereResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogCountPersonByWhereArgsProperties
{
  PROP_I_FACE_LOG_COUNT_PERSON_BY_WHERE_ARGS_0,
  PROP_I_FACE_LOG_COUNT_PERSON_BY_WHERE_ARGS_WHERE
};

/* reads a i_face_log_count_person_by_where_args object */
static gint32
i_face_log_count_person_by_where_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogCountPersonByWhereArgs * this_object = I_FACE_LOG_COUNT_PERSON_BY_WHERE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->where != NULL)
          {
            g_free(this_object->where);
            this_object->where = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->where, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_where = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_count_person_by_where_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogCountPersonByWhereArgs * this_object = I_FACE_LOG_COUNT_PERSON_BY_WHERE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogCountPersonByWhereArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->where, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_count_person_by_where_args_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogCountPersonByWhereArgs *self = I_FACE_LOG_COUNT_PERSON_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_PERSON_BY_WHERE_ARGS_WHERE:
      if (self->where != NULL)
        g_free (self->where);
      self->where = g_value_dup_string (value);
      self->__isset_where = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_count_person_by_where_args_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogCountPersonByWhereArgs *self = I_FACE_LOG_COUNT_PERSON_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_PERSON_BY_WHERE_ARGS_WHERE:
      g_value_set_string (value, self->where);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_count_person_by_where_args_instance_init (IFaceLogCountPersonByWhereArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->where = NULL;
  object->__isset_where = FALSE;
}

static void 
i_face_log_count_person_by_where_args_finalize (GObject *object)
{
  IFaceLogCountPersonByWhereArgs *tobject = I_FACE_LOG_COUNT_PERSON_BY_WHERE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->where != NULL)
  {
    g_free(tobject->where);
    tobject->where = NULL;
  }
}

static void
i_face_log_count_person_by_where_args_class_init (IFaceLogCountPersonByWhereArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_count_person_by_where_args_read;
  struct_class->write = i_face_log_count_person_by_where_args_write;

  gobject_class->finalize = i_face_log_count_person_by_where_args_finalize;
  gobject_class->get_property = i_face_log_count_person_by_where_args_get_property;
  gobject_class->set_property = i_face_log_count_person_by_where_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_PERSON_BY_WHERE_ARGS_WHERE,
     g_param_spec_string ("where",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_count_person_by_where_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogCountPersonByWhereArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_count_person_by_where_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogCountPersonByWhereArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_count_person_by_where_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogCountPersonByWhereArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogCountPersonByWhereResultProperties
{
  PROP_I_FACE_LOG_COUNT_PERSON_BY_WHERE_RESULT_0,
  PROP_I_FACE_LOG_COUNT_PERSON_BY_WHERE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_COUNT_PERSON_BY_WHERE_RESULT_EX1
};

/* reads a i_face_log_count_person_by_where_result object */
static gint32
i_face_log_count_person_by_where_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogCountPersonByWhereResult * this_object = I_FACE_LOG_COUNT_PERSON_BY_WHERE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_count_person_by_where_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogCountPersonByWhereResult * this_object = I_FACE_LOG_COUNT_PERSON_BY_WHERE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogCountPersonByWhereResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_count_person_by_where_result_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  IFaceLogCountPersonByWhereResult *self = I_FACE_LOG_COUNT_PERSON_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_PERSON_BY_WHERE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_COUNT_PERSON_BY_WHERE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_count_person_by_where_result_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  IFaceLogCountPersonByWhereResult *self = I_FACE_LOG_COUNT_PERSON_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_PERSON_BY_WHERE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_COUNT_PERSON_BY_WHERE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_count_person_by_where_result_instance_init (IFaceLogCountPersonByWhereResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_count_person_by_where_result_finalize (GObject *object)
{
  IFaceLogCountPersonByWhereResult *tobject = I_FACE_LOG_COUNT_PERSON_BY_WHERE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_count_person_by_where_result_class_init (IFaceLogCountPersonByWhereResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_count_person_by_where_result_read;
  struct_class->write = i_face_log_count_person_by_where_result_write;

  gobject_class->finalize = i_face_log_count_person_by_where_result_finalize;
  gobject_class->get_property = i_face_log_count_person_by_where_result_get_property;
  gobject_class->set_property = i_face_log_count_person_by_where_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_PERSON_BY_WHERE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_PERSON_BY_WHERE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_count_person_by_where_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogCountPersonByWhereResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_count_person_by_where_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogCountPersonByWhereResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_count_person_by_where_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogCountPersonByWhereResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogCountPersonGroupByWhereArgsProperties
{
  PROP_I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_ARGS_0,
  PROP_I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_ARGS_WHERE
};

/* reads a i_face_log_count_person_group_by_where_args object */
static gint32
i_face_log_count_person_group_by_where_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogCountPersonGroupByWhereArgs * this_object = I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->where != NULL)
          {
            g_free(this_object->where);
            this_object->where = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->where, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_where = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_count_person_group_by_where_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogCountPersonGroupByWhereArgs * this_object = I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogCountPersonGroupByWhereArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->where, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_count_person_group_by_where_args_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  IFaceLogCountPersonGroupByWhereArgs *self = I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_ARGS_WHERE:
      if (self->where != NULL)
        g_free (self->where);
      self->where = g_value_dup_string (value);
      self->__isset_where = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_count_person_group_by_where_args_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  IFaceLogCountPersonGroupByWhereArgs *self = I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_ARGS_WHERE:
      g_value_set_string (value, self->where);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_count_person_group_by_where_args_instance_init (IFaceLogCountPersonGroupByWhereArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->where = NULL;
  object->__isset_where = FALSE;
}

static void 
i_face_log_count_person_group_by_where_args_finalize (GObject *object)
{
  IFaceLogCountPersonGroupByWhereArgs *tobject = I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->where != NULL)
  {
    g_free(tobject->where);
    tobject->where = NULL;
  }
}

static void
i_face_log_count_person_group_by_where_args_class_init (IFaceLogCountPersonGroupByWhereArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_count_person_group_by_where_args_read;
  struct_class->write = i_face_log_count_person_group_by_where_args_write;

  gobject_class->finalize = i_face_log_count_person_group_by_where_args_finalize;
  gobject_class->get_property = i_face_log_count_person_group_by_where_args_get_property;
  gobject_class->set_property = i_face_log_count_person_group_by_where_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_ARGS_WHERE,
     g_param_spec_string ("where",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_count_person_group_by_where_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogCountPersonGroupByWhereArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_count_person_group_by_where_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogCountPersonGroupByWhereArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_count_person_group_by_where_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogCountPersonGroupByWhereArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogCountPersonGroupByWhereResultProperties
{
  PROP_I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_RESULT_0,
  PROP_I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_RESULT_EX1
};

/* reads a i_face_log_count_person_group_by_where_result object */
static gint32
i_face_log_count_person_group_by_where_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogCountPersonGroupByWhereResult * this_object = I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_count_person_group_by_where_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogCountPersonGroupByWhereResult * this_object = I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogCountPersonGroupByWhereResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_count_person_group_by_where_result_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogCountPersonGroupByWhereResult *self = I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_count_person_group_by_where_result_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogCountPersonGroupByWhereResult *self = I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_count_person_group_by_where_result_instance_init (IFaceLogCountPersonGroupByWhereResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_count_person_group_by_where_result_finalize (GObject *object)
{
  IFaceLogCountPersonGroupByWhereResult *tobject = I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_count_person_group_by_where_result_class_init (IFaceLogCountPersonGroupByWhereResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_count_person_group_by_where_result_read;
  struct_class->write = i_face_log_count_person_group_by_where_result_write;

  gobject_class->finalize = i_face_log_count_person_group_by_where_result_finalize;
  gobject_class->get_property = i_face_log_count_person_group_by_where_result_get_property;
  gobject_class->set_property = i_face_log_count_person_group_by_where_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_count_person_group_by_where_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogCountPersonGroupByWhereResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_count_person_group_by_where_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogCountPersonGroupByWhereResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_count_person_group_by_where_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogCountPersonGroupByWhereResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeleteAllFeaturesByPersonIdArgsProperties
{
  PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_ARGS_0,
  PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_ARGS_PERSON_ID,
  PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_ARGS_DELETE_IMAGE,
  PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_ARGS_TOKEN
};

/* reads a i_face_log_delete_all_features_by_person_id_args object */
static gint32
i_face_log_delete_all_features_by_person_id_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeleteAllFeaturesByPersonIdArgs * this_object = I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_ARGS(object);
  gboolean isset_personId = FALSE;
  gboolean isset_deleteImage = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->deleteImage, error)) < 0)
            return -1;
          xfer += ret;
          isset_deleteImage = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_deleteImage)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_delete_all_features_by_person_id_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeleteAllFeaturesByPersonIdArgs * this_object = I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeleteAllFeaturesByPersonIdArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deleteImage", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->deleteImage, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_all_features_by_person_id_args_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  IFaceLogDeleteAllFeaturesByPersonIdArgs *self = I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_ARGS_PERSON_ID:
      self->personId = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_ARGS_DELETE_IMAGE:
      self->deleteImage = g_value_get_boolean (value);
      break;

    case PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_all_features_by_person_id_args_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  IFaceLogDeleteAllFeaturesByPersonIdArgs *self = I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_ARGS_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    case PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_ARGS_DELETE_IMAGE:
      g_value_set_boolean (value, self->deleteImage);
      break;

    case PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_all_features_by_person_id_args_instance_init (IFaceLogDeleteAllFeaturesByPersonIdArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personId = 0;
  object->deleteImage = 0;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_delete_all_features_by_person_id_args_finalize (GObject *object)
{
  IFaceLogDeleteAllFeaturesByPersonIdArgs *tobject = I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_delete_all_features_by_person_id_args_class_init (IFaceLogDeleteAllFeaturesByPersonIdArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_all_features_by_person_id_args_read;
  struct_class->write = i_face_log_delete_all_features_by_person_id_args_write;

  gobject_class->finalize = i_face_log_delete_all_features_by_person_id_args_finalize;
  gobject_class->get_property = i_face_log_delete_all_features_by_person_id_args_get_property;
  gobject_class->set_property = i_face_log_delete_all_features_by_person_id_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_ARGS_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_ARGS_DELETE_IMAGE,
     g_param_spec_boolean ("deleteImage",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_all_features_by_person_id_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeleteAllFeaturesByPersonIdArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_all_features_by_person_id_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeleteAllFeaturesByPersonIdArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_all_features_by_person_id_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeleteAllFeaturesByPersonIdArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeleteAllFeaturesByPersonIdResultProperties
{
  PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_RESULT_0,
  PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_RESULT_SUCCESS,
  PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_RESULT_EX1
};

/* reads a i_face_log_delete_all_features_by_person_id_result object */
static gint32
i_face_log_delete_all_features_by_person_id_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeleteAllFeaturesByPersonIdResult * this_object = I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_delete_all_features_by_person_id_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeleteAllFeaturesByPersonIdResult * this_object = I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeleteAllFeaturesByPersonIdResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_all_features_by_person_id_result_set_property (GObject *object,
                                                                 guint property_id,
                                                                 const GValue *value,
                                                                 GParamSpec *pspec)
{
  IFaceLogDeleteAllFeaturesByPersonIdResult *self = I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_all_features_by_person_id_result_get_property (GObject *object,
                                                                 guint property_id,
                                                                 GValue *value,
                                                                 GParamSpec *pspec)
{
  IFaceLogDeleteAllFeaturesByPersonIdResult *self = I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_all_features_by_person_id_result_instance_init (IFaceLogDeleteAllFeaturesByPersonIdResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_delete_all_features_by_person_id_result_finalize (GObject *object)
{
  IFaceLogDeleteAllFeaturesByPersonIdResult *tobject = I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_delete_all_features_by_person_id_result_class_init (IFaceLogDeleteAllFeaturesByPersonIdResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_all_features_by_person_id_result_read;
  struct_class->write = i_face_log_delete_all_features_by_person_id_result_write;

  gobject_class->finalize = i_face_log_delete_all_features_by_person_id_result_finalize;
  gobject_class->get_property = i_face_log_delete_all_features_by_person_id_result_get_property;
  gobject_class->set_property = i_face_log_delete_all_features_by_person_id_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_all_features_by_person_id_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeleteAllFeaturesByPersonIdResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_all_features_by_person_id_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeleteAllFeaturesByPersonIdResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_all_features_by_person_id_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeleteAllFeaturesByPersonIdResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeleteDeviceGroupArgsProperties
{
  PROP_I_FACE_LOG_DELETE_DEVICE_GROUP_ARGS_0,
  PROP_I_FACE_LOG_DELETE_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID,
  PROP_I_FACE_LOG_DELETE_DEVICE_GROUP_ARGS_TOKEN
};

/* reads a i_face_log_delete_device_group_args object */
static gint32
i_face_log_delete_device_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeleteDeviceGroupArgs * this_object = I_FACE_LOG_DELETE_DEVICE_GROUP_ARGS(object);
  gboolean isset_deviceGroupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_deviceGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_deviceGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_delete_device_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeleteDeviceGroupArgs * this_object = I_FACE_LOG_DELETE_DEVICE_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeleteDeviceGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_device_group_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogDeleteDeviceGroupArgs *self = I_FACE_LOG_DELETE_DEVICE_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID:
      self->deviceGroupId = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_DELETE_DEVICE_GROUP_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_device_group_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogDeleteDeviceGroupArgs *self = I_FACE_LOG_DELETE_DEVICE_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID:
      g_value_set_int (value, self->deviceGroupId);
      break;

    case PROP_I_FACE_LOG_DELETE_DEVICE_GROUP_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_device_group_args_instance_init (IFaceLogDeleteDeviceGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->deviceGroupId = 0;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_delete_device_group_args_finalize (GObject *object)
{
  IFaceLogDeleteDeviceGroupArgs *tobject = I_FACE_LOG_DELETE_DEVICE_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_delete_device_group_args_class_init (IFaceLogDeleteDeviceGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_device_group_args_read;
  struct_class->write = i_face_log_delete_device_group_args_write;

  gobject_class->finalize = i_face_log_delete_device_group_args_finalize;
  gobject_class->get_property = i_face_log_delete_device_group_args_get_property;
  gobject_class->set_property = i_face_log_delete_device_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID,
     g_param_spec_int ("deviceGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_DEVICE_GROUP_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_device_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeleteDeviceGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_device_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeleteDeviceGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_device_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeleteDeviceGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeleteDeviceGroupResultProperties
{
  PROP_I_FACE_LOG_DELETE_DEVICE_GROUP_RESULT_0,
  PROP_I_FACE_LOG_DELETE_DEVICE_GROUP_RESULT_SUCCESS,
  PROP_I_FACE_LOG_DELETE_DEVICE_GROUP_RESULT_EX1
};

/* reads a i_face_log_delete_device_group_result object */
static gint32
i_face_log_delete_device_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeleteDeviceGroupResult * this_object = I_FACE_LOG_DELETE_DEVICE_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_delete_device_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeleteDeviceGroupResult * this_object = I_FACE_LOG_DELETE_DEVICE_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeleteDeviceGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_device_group_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogDeleteDeviceGroupResult *self = I_FACE_LOG_DELETE_DEVICE_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_DEVICE_GROUP_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_DELETE_DEVICE_GROUP_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_device_group_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogDeleteDeviceGroupResult *self = I_FACE_LOG_DELETE_DEVICE_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_DEVICE_GROUP_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_DELETE_DEVICE_GROUP_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_device_group_result_instance_init (IFaceLogDeleteDeviceGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_delete_device_group_result_finalize (GObject *object)
{
  IFaceLogDeleteDeviceGroupResult *tobject = I_FACE_LOG_DELETE_DEVICE_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_delete_device_group_result_class_init (IFaceLogDeleteDeviceGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_device_group_result_read;
  struct_class->write = i_face_log_delete_device_group_result_write;

  gobject_class->finalize = i_face_log_delete_device_group_result_finalize;
  gobject_class->get_property = i_face_log_delete_device_group_result_get_property;
  gobject_class->set_property = i_face_log_delete_device_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_DEVICE_GROUP_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_DEVICE_GROUP_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_device_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeleteDeviceGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_device_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeleteDeviceGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_device_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeleteDeviceGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeleteFeatureArgsProperties
{
  PROP_I_FACE_LOG_DELETE_FEATURE_ARGS_0,
  PROP_I_FACE_LOG_DELETE_FEATURE_ARGS_FEATURE_MD5,
  PROP_I_FACE_LOG_DELETE_FEATURE_ARGS_DELETE_IMAGE,
  PROP_I_FACE_LOG_DELETE_FEATURE_ARGS_TOKEN
};

/* reads a i_face_log_delete_feature_args object */
static gint32
i_face_log_delete_feature_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeleteFeatureArgs * this_object = I_FACE_LOG_DELETE_FEATURE_ARGS(object);
  gboolean isset_deleteImage = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->featureMd5 != NULL)
          {
            g_free(this_object->featureMd5);
            this_object->featureMd5 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->featureMd5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_featureMd5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->deleteImage, error)) < 0)
            return -1;
          xfer += ret;
          isset_deleteImage = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_deleteImage)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_delete_feature_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeleteFeatureArgs * this_object = I_FACE_LOG_DELETE_FEATURE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeleteFeatureArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "featureMd5", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->featureMd5, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deleteImage", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->deleteImage, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_feature_args_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogDeleteFeatureArgs *self = I_FACE_LOG_DELETE_FEATURE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_FEATURE_ARGS_FEATURE_MD5:
      if (self->featureMd5 != NULL)
        g_free (self->featureMd5);
      self->featureMd5 = g_value_dup_string (value);
      self->__isset_featureMd5 = TRUE;
      break;

    case PROP_I_FACE_LOG_DELETE_FEATURE_ARGS_DELETE_IMAGE:
      self->deleteImage = g_value_get_boolean (value);
      break;

    case PROP_I_FACE_LOG_DELETE_FEATURE_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_feature_args_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogDeleteFeatureArgs *self = I_FACE_LOG_DELETE_FEATURE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_FEATURE_ARGS_FEATURE_MD5:
      g_value_set_string (value, self->featureMd5);
      break;

    case PROP_I_FACE_LOG_DELETE_FEATURE_ARGS_DELETE_IMAGE:
      g_value_set_boolean (value, self->deleteImage);
      break;

    case PROP_I_FACE_LOG_DELETE_FEATURE_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_feature_args_instance_init (IFaceLogDeleteFeatureArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->featureMd5 = NULL;
  object->__isset_featureMd5 = FALSE;
  object->deleteImage = 0;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_delete_feature_args_finalize (GObject *object)
{
  IFaceLogDeleteFeatureArgs *tobject = I_FACE_LOG_DELETE_FEATURE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->featureMd5 != NULL)
  {
    g_free(tobject->featureMd5);
    tobject->featureMd5 = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_delete_feature_args_class_init (IFaceLogDeleteFeatureArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_feature_args_read;
  struct_class->write = i_face_log_delete_feature_args_write;

  gobject_class->finalize = i_face_log_delete_feature_args_finalize;
  gobject_class->get_property = i_face_log_delete_feature_args_get_property;
  gobject_class->set_property = i_face_log_delete_feature_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_FEATURE_ARGS_FEATURE_MD5,
     g_param_spec_string ("featureMd5",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_FEATURE_ARGS_DELETE_IMAGE,
     g_param_spec_boolean ("deleteImage",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_FEATURE_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_feature_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeleteFeatureArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_feature_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeleteFeatureArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_feature_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeleteFeatureArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeleteFeatureResultProperties
{
  PROP_I_FACE_LOG_DELETE_FEATURE_RESULT_0,
  PROP_I_FACE_LOG_DELETE_FEATURE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_DELETE_FEATURE_RESULT_EX1
};

/* reads a i_face_log_delete_feature_result object */
static gint32
i_face_log_delete_feature_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeleteFeatureResult * this_object = I_FACE_LOG_DELETE_FEATURE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem20 = NULL;
              if (_elem20 != NULL)
              {
                g_free(_elem20);
                _elem20 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem20, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem20);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_delete_feature_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeleteFeatureResult * this_object = I_FACE_LOG_DELETE_FEATURE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeleteFeatureResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i21;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i21 = 0; i21 < (this_object->success ? this_object->success->len : 0); i21++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->success, i21)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_feature_result_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogDeleteFeatureResult *self = I_FACE_LOG_DELETE_FEATURE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_FEATURE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_DELETE_FEATURE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_feature_result_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogDeleteFeatureResult *self = I_FACE_LOG_DELETE_FEATURE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_FEATURE_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_DELETE_FEATURE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_feature_result_instance_init (IFaceLogDeleteFeatureResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_free);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_delete_feature_result_finalize (GObject *object)
{
  IFaceLogDeleteFeatureResult *tobject = I_FACE_LOG_DELETE_FEATURE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_delete_feature_result_class_init (IFaceLogDeleteFeatureResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_feature_result_read;
  struct_class->write = i_face_log_delete_feature_result_write;

  gobject_class->finalize = i_face_log_delete_feature_result_finalize;
  gobject_class->get_property = i_face_log_delete_feature_result_get_property;
  gobject_class->set_property = i_face_log_delete_feature_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_FEATURE_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_FEATURE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_feature_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeleteFeatureResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_feature_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeleteFeatureResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_feature_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeleteFeatureResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeleteGroupPermitOnDeviceGroupArgsProperties
{
  PROP_I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS_0,
  PROP_I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID,
  PROP_I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS_TOKEN
};

/* reads a i_face_log_delete_group_permit_on_device_group_args object */
static gint32
i_face_log_delete_group_permit_on_device_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeleteGroupPermitOnDeviceGroupArgs * this_object = I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS(object);
  gboolean isset_deviceGroupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_deviceGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_deviceGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_delete_group_permit_on_device_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeleteGroupPermitOnDeviceGroupArgs * this_object = I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeleteGroupPermitOnDeviceGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_group_permit_on_device_group_args_set_property (GObject *object,
                                                                  guint property_id,
                                                                  const GValue *value,
                                                                  GParamSpec *pspec)
{
  IFaceLogDeleteGroupPermitOnDeviceGroupArgs *self = I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID:
      self->deviceGroupId = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_group_permit_on_device_group_args_get_property (GObject *object,
                                                                  guint property_id,
                                                                  GValue *value,
                                                                  GParamSpec *pspec)
{
  IFaceLogDeleteGroupPermitOnDeviceGroupArgs *self = I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID:
      g_value_set_int (value, self->deviceGroupId);
      break;

    case PROP_I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_group_permit_on_device_group_args_instance_init (IFaceLogDeleteGroupPermitOnDeviceGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->deviceGroupId = 0;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_delete_group_permit_on_device_group_args_finalize (GObject *object)
{
  IFaceLogDeleteGroupPermitOnDeviceGroupArgs *tobject = I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_delete_group_permit_on_device_group_args_class_init (IFaceLogDeleteGroupPermitOnDeviceGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_group_permit_on_device_group_args_read;
  struct_class->write = i_face_log_delete_group_permit_on_device_group_args_write;

  gobject_class->finalize = i_face_log_delete_group_permit_on_device_group_args_finalize;
  gobject_class->get_property = i_face_log_delete_group_permit_on_device_group_args_get_property;
  gobject_class->set_property = i_face_log_delete_group_permit_on_device_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID,
     g_param_spec_int ("deviceGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_group_permit_on_device_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeleteGroupPermitOnDeviceGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_group_permit_on_device_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeleteGroupPermitOnDeviceGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_group_permit_on_device_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeleteGroupPermitOnDeviceGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeleteGroupPermitOnDeviceGroupResultProperties
{
  PROP_I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT_0,
  PROP_I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT_SUCCESS,
  PROP_I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT_EX1
};

/* reads a i_face_log_delete_group_permit_on_device_group_result object */
static gint32
i_face_log_delete_group_permit_on_device_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeleteGroupPermitOnDeviceGroupResult * this_object = I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_delete_group_permit_on_device_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeleteGroupPermitOnDeviceGroupResult * this_object = I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeleteGroupPermitOnDeviceGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_group_permit_on_device_group_result_set_property (GObject *object,
                                                                    guint property_id,
                                                                    const GValue *value,
                                                                    GParamSpec *pspec)
{
  IFaceLogDeleteGroupPermitOnDeviceGroupResult *self = I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_group_permit_on_device_group_result_get_property (GObject *object,
                                                                    guint property_id,
                                                                    GValue *value,
                                                                    GParamSpec *pspec)
{
  IFaceLogDeleteGroupPermitOnDeviceGroupResult *self = I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_group_permit_on_device_group_result_instance_init (IFaceLogDeleteGroupPermitOnDeviceGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_delete_group_permit_on_device_group_result_finalize (GObject *object)
{
  IFaceLogDeleteGroupPermitOnDeviceGroupResult *tobject = I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_delete_group_permit_on_device_group_result_class_init (IFaceLogDeleteGroupPermitOnDeviceGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_group_permit_on_device_group_result_read;
  struct_class->write = i_face_log_delete_group_permit_on_device_group_result_write;

  gobject_class->finalize = i_face_log_delete_group_permit_on_device_group_result_finalize;
  gobject_class->get_property = i_face_log_delete_group_permit_on_device_group_result_get_property;
  gobject_class->set_property = i_face_log_delete_group_permit_on_device_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_group_permit_on_device_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeleteGroupPermitOnDeviceGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_group_permit_on_device_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeleteGroupPermitOnDeviceGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_group_permit_on_device_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeleteGroupPermitOnDeviceGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeleteImageArgsProperties
{
  PROP_I_FACE_LOG_DELETE_IMAGE_ARGS_0,
  PROP_I_FACE_LOG_DELETE_IMAGE_ARGS_IMAGE_MD5,
  PROP_I_FACE_LOG_DELETE_IMAGE_ARGS_TOKEN
};

/* reads a i_face_log_delete_image_args object */
static gint32
i_face_log_delete_image_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeleteImageArgs * this_object = I_FACE_LOG_DELETE_IMAGE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->imageMd5 != NULL)
          {
            g_free(this_object->imageMd5);
            this_object->imageMd5 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->imageMd5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_imageMd5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_delete_image_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeleteImageArgs * this_object = I_FACE_LOG_DELETE_IMAGE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeleteImageArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "imageMd5", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->imageMd5, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_image_args_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogDeleteImageArgs *self = I_FACE_LOG_DELETE_IMAGE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_IMAGE_ARGS_IMAGE_MD5:
      if (self->imageMd5 != NULL)
        g_free (self->imageMd5);
      self->imageMd5 = g_value_dup_string (value);
      self->__isset_imageMd5 = TRUE;
      break;

    case PROP_I_FACE_LOG_DELETE_IMAGE_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_image_args_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogDeleteImageArgs *self = I_FACE_LOG_DELETE_IMAGE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_IMAGE_ARGS_IMAGE_MD5:
      g_value_set_string (value, self->imageMd5);
      break;

    case PROP_I_FACE_LOG_DELETE_IMAGE_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_image_args_instance_init (IFaceLogDeleteImageArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->imageMd5 = NULL;
  object->__isset_imageMd5 = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_delete_image_args_finalize (GObject *object)
{
  IFaceLogDeleteImageArgs *tobject = I_FACE_LOG_DELETE_IMAGE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->imageMd5 != NULL)
  {
    g_free(tobject->imageMd5);
    tobject->imageMd5 = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_delete_image_args_class_init (IFaceLogDeleteImageArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_image_args_read;
  struct_class->write = i_face_log_delete_image_args_write;

  gobject_class->finalize = i_face_log_delete_image_args_finalize;
  gobject_class->get_property = i_face_log_delete_image_args_get_property;
  gobject_class->set_property = i_face_log_delete_image_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_IMAGE_ARGS_IMAGE_MD5,
     g_param_spec_string ("imageMd5",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_IMAGE_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_image_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeleteImageArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_image_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeleteImageArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_image_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeleteImageArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeleteImageResultProperties
{
  PROP_I_FACE_LOG_DELETE_IMAGE_RESULT_0,
  PROP_I_FACE_LOG_DELETE_IMAGE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_DELETE_IMAGE_RESULT_EX1
};

/* reads a i_face_log_delete_image_result object */
static gint32
i_face_log_delete_image_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeleteImageResult * this_object = I_FACE_LOG_DELETE_IMAGE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_delete_image_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeleteImageResult * this_object = I_FACE_LOG_DELETE_IMAGE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeleteImageResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_image_result_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogDeleteImageResult *self = I_FACE_LOG_DELETE_IMAGE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_IMAGE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_DELETE_IMAGE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_image_result_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogDeleteImageResult *self = I_FACE_LOG_DELETE_IMAGE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_IMAGE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_DELETE_IMAGE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_image_result_instance_init (IFaceLogDeleteImageResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_delete_image_result_finalize (GObject *object)
{
  IFaceLogDeleteImageResult *tobject = I_FACE_LOG_DELETE_IMAGE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_delete_image_result_class_init (IFaceLogDeleteImageResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_image_result_read;
  struct_class->write = i_face_log_delete_image_result_write;

  gobject_class->finalize = i_face_log_delete_image_result_finalize;
  gobject_class->get_property = i_face_log_delete_image_result_get_property;
  gobject_class->set_property = i_face_log_delete_image_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_IMAGE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_IMAGE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_image_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeleteImageResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_image_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeleteImageResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_image_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeleteImageResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeletePermitByIdArgsProperties
{
  PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_ARGS_0,
  PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_ARGS_DEVICE_GROUP_ID,
  PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_ARGS_PERSON_GROUP_ID,
  PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_ARGS_TOKEN
};

/* reads a i_face_log_delete_permit_by_id_args object */
static gint32
i_face_log_delete_permit_by_id_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeletePermitByIdArgs * this_object = I_FACE_LOG_DELETE_PERMIT_BY_ID_ARGS(object);
  gboolean isset_deviceGroupId = FALSE;
  gboolean isset_personGroupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_deviceGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_deviceGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_personGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_delete_permit_by_id_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeletePermitByIdArgs * this_object = I_FACE_LOG_DELETE_PERMIT_BY_ID_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeletePermitByIdArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_permit_by_id_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogDeletePermitByIdArgs *self = I_FACE_LOG_DELETE_PERMIT_BY_ID_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_ARGS_DEVICE_GROUP_ID:
      self->deviceGroupId = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_ARGS_PERSON_GROUP_ID:
      self->personGroupId = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_permit_by_id_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogDeletePermitByIdArgs *self = I_FACE_LOG_DELETE_PERMIT_BY_ID_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_ARGS_DEVICE_GROUP_ID:
      g_value_set_int (value, self->deviceGroupId);
      break;

    case PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_ARGS_PERSON_GROUP_ID:
      g_value_set_int (value, self->personGroupId);
      break;

    case PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_permit_by_id_args_instance_init (IFaceLogDeletePermitByIdArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->deviceGroupId = 0;
  object->personGroupId = 0;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_delete_permit_by_id_args_finalize (GObject *object)
{
  IFaceLogDeletePermitByIdArgs *tobject = I_FACE_LOG_DELETE_PERMIT_BY_ID_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_delete_permit_by_id_args_class_init (IFaceLogDeletePermitByIdArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_permit_by_id_args_read;
  struct_class->write = i_face_log_delete_permit_by_id_args_write;

  gobject_class->finalize = i_face_log_delete_permit_by_id_args_finalize;
  gobject_class->get_property = i_face_log_delete_permit_by_id_args_get_property;
  gobject_class->set_property = i_face_log_delete_permit_by_id_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_ARGS_DEVICE_GROUP_ID,
     g_param_spec_int ("deviceGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_ARGS_PERSON_GROUP_ID,
     g_param_spec_int ("personGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_permit_by_id_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeletePermitByIdArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_permit_by_id_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeletePermitByIdArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_permit_by_id_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeletePermitByIdArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeletePermitByIdResultProperties
{
  PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_RESULT_0,
  PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_RESULT_SUCCESS,
  PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_RESULT_EX1
};

/* reads a i_face_log_delete_permit_by_id_result object */
static gint32
i_face_log_delete_permit_by_id_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeletePermitByIdResult * this_object = I_FACE_LOG_DELETE_PERMIT_BY_ID_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_delete_permit_by_id_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeletePermitByIdResult * this_object = I_FACE_LOG_DELETE_PERMIT_BY_ID_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeletePermitByIdResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_permit_by_id_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogDeletePermitByIdResult *self = I_FACE_LOG_DELETE_PERMIT_BY_ID_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_permit_by_id_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogDeletePermitByIdResult *self = I_FACE_LOG_DELETE_PERMIT_BY_ID_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_permit_by_id_result_instance_init (IFaceLogDeletePermitByIdResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_delete_permit_by_id_result_finalize (GObject *object)
{
  IFaceLogDeletePermitByIdResult *tobject = I_FACE_LOG_DELETE_PERMIT_BY_ID_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_delete_permit_by_id_result_class_init (IFaceLogDeletePermitByIdResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_permit_by_id_result_read;
  struct_class->write = i_face_log_delete_permit_by_id_result_write;

  gobject_class->finalize = i_face_log_delete_permit_by_id_result_finalize;
  gobject_class->get_property = i_face_log_delete_permit_by_id_result_get_property;
  gobject_class->set_property = i_face_log_delete_permit_by_id_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERMIT_BY_ID_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_permit_by_id_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeletePermitByIdResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_permit_by_id_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeletePermitByIdResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_permit_by_id_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeletePermitByIdResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeletePersonArgsProperties
{
  PROP_I_FACE_LOG_DELETE_PERSON_ARGS_0,
  PROP_I_FACE_LOG_DELETE_PERSON_ARGS_PERSON_ID,
  PROP_I_FACE_LOG_DELETE_PERSON_ARGS_TOKEN
};

/* reads a i_face_log_delete_person_args object */
static gint32
i_face_log_delete_person_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeletePersonArgs * this_object = I_FACE_LOG_DELETE_PERSON_ARGS(object);
  gboolean isset_personId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_delete_person_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeletePersonArgs * this_object = I_FACE_LOG_DELETE_PERSON_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeletePersonArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_person_args_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogDeletePersonArgs *self = I_FACE_LOG_DELETE_PERSON_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSON_ARGS_PERSON_ID:
      self->personId = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_DELETE_PERSON_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_person_args_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogDeletePersonArgs *self = I_FACE_LOG_DELETE_PERSON_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSON_ARGS_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    case PROP_I_FACE_LOG_DELETE_PERSON_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_person_args_instance_init (IFaceLogDeletePersonArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personId = 0;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_delete_person_args_finalize (GObject *object)
{
  IFaceLogDeletePersonArgs *tobject = I_FACE_LOG_DELETE_PERSON_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_delete_person_args_class_init (IFaceLogDeletePersonArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_person_args_read;
  struct_class->write = i_face_log_delete_person_args_write;

  gobject_class->finalize = i_face_log_delete_person_args_finalize;
  gobject_class->get_property = i_face_log_delete_person_args_get_property;
  gobject_class->set_property = i_face_log_delete_person_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSON_ARGS_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSON_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_person_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeletePersonArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_person_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeletePersonArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_person_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeletePersonArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeletePersonResultProperties
{
  PROP_I_FACE_LOG_DELETE_PERSON_RESULT_0,
  PROP_I_FACE_LOG_DELETE_PERSON_RESULT_SUCCESS,
  PROP_I_FACE_LOG_DELETE_PERSON_RESULT_EX1
};

/* reads a i_face_log_delete_person_result object */
static gint32
i_face_log_delete_person_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeletePersonResult * this_object = I_FACE_LOG_DELETE_PERSON_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_delete_person_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeletePersonResult * this_object = I_FACE_LOG_DELETE_PERSON_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeletePersonResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_person_result_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogDeletePersonResult *self = I_FACE_LOG_DELETE_PERSON_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSON_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_DELETE_PERSON_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_person_result_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogDeletePersonResult *self = I_FACE_LOG_DELETE_PERSON_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSON_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_DELETE_PERSON_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_person_result_instance_init (IFaceLogDeletePersonResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_delete_person_result_finalize (GObject *object)
{
  IFaceLogDeletePersonResult *tobject = I_FACE_LOG_DELETE_PERSON_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_delete_person_result_class_init (IFaceLogDeletePersonResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_person_result_read;
  struct_class->write = i_face_log_delete_person_result_write;

  gobject_class->finalize = i_face_log_delete_person_result_finalize;
  gobject_class->get_property = i_face_log_delete_person_result_get_property;
  gobject_class->set_property = i_face_log_delete_person_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSON_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSON_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_person_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeletePersonResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_person_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeletePersonResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_person_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeletePersonResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeletePersonByPapersNumArgsProperties
{
  PROP_I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_ARGS_0,
  PROP_I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_ARGS_PAPERS_NUM,
  PROP_I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_ARGS_TOKEN
};

/* reads a i_face_log_delete_person_by_papers_num_args object */
static gint32
i_face_log_delete_person_by_papers_num_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeletePersonByPapersNumArgs * this_object = I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->papersNum != NULL)
          {
            g_free(this_object->papersNum);
            this_object->papersNum = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->papersNum, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_papersNum = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_delete_person_by_papers_num_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeletePersonByPapersNumArgs * this_object = I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeletePersonByPapersNumArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "papersNum", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->papersNum, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_person_by_papers_num_args_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  IFaceLogDeletePersonByPapersNumArgs *self = I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_ARGS_PAPERS_NUM:
      if (self->papersNum != NULL)
        g_free (self->papersNum);
      self->papersNum = g_value_dup_string (value);
      self->__isset_papersNum = TRUE;
      break;

    case PROP_I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_person_by_papers_num_args_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  IFaceLogDeletePersonByPapersNumArgs *self = I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_ARGS_PAPERS_NUM:
      g_value_set_string (value, self->papersNum);
      break;

    case PROP_I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_person_by_papers_num_args_instance_init (IFaceLogDeletePersonByPapersNumArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->papersNum = NULL;
  object->__isset_papersNum = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_delete_person_by_papers_num_args_finalize (GObject *object)
{
  IFaceLogDeletePersonByPapersNumArgs *tobject = I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->papersNum != NULL)
  {
    g_free(tobject->papersNum);
    tobject->papersNum = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_delete_person_by_papers_num_args_class_init (IFaceLogDeletePersonByPapersNumArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_person_by_papers_num_args_read;
  struct_class->write = i_face_log_delete_person_by_papers_num_args_write;

  gobject_class->finalize = i_face_log_delete_person_by_papers_num_args_finalize;
  gobject_class->get_property = i_face_log_delete_person_by_papers_num_args_get_property;
  gobject_class->set_property = i_face_log_delete_person_by_papers_num_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_ARGS_PAPERS_NUM,
     g_param_spec_string ("papersNum",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_person_by_papers_num_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeletePersonByPapersNumArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_person_by_papers_num_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeletePersonByPapersNumArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_person_by_papers_num_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeletePersonByPapersNumArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeletePersonByPapersNumResultProperties
{
  PROP_I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_RESULT_0,
  PROP_I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_RESULT_SUCCESS,
  PROP_I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_RESULT_EX1
};

/* reads a i_face_log_delete_person_by_papers_num_result object */
static gint32
i_face_log_delete_person_by_papers_num_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeletePersonByPapersNumResult * this_object = I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_delete_person_by_papers_num_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeletePersonByPapersNumResult * this_object = I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeletePersonByPapersNumResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_person_by_papers_num_result_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogDeletePersonByPapersNumResult *self = I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_person_by_papers_num_result_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogDeletePersonByPapersNumResult *self = I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_person_by_papers_num_result_instance_init (IFaceLogDeletePersonByPapersNumResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_delete_person_by_papers_num_result_finalize (GObject *object)
{
  IFaceLogDeletePersonByPapersNumResult *tobject = I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_delete_person_by_papers_num_result_class_init (IFaceLogDeletePersonByPapersNumResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_person_by_papers_num_result_read;
  struct_class->write = i_face_log_delete_person_by_papers_num_result_write;

  gobject_class->finalize = i_face_log_delete_person_by_papers_num_result_finalize;
  gobject_class->get_property = i_face_log_delete_person_by_papers_num_result_get_property;
  gobject_class->set_property = i_face_log_delete_person_by_papers_num_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_person_by_papers_num_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeletePersonByPapersNumResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_person_by_papers_num_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeletePersonByPapersNumResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_person_by_papers_num_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeletePersonByPapersNumResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeletePersonGroupArgsProperties
{
  PROP_I_FACE_LOG_DELETE_PERSON_GROUP_ARGS_0,
  PROP_I_FACE_LOG_DELETE_PERSON_GROUP_ARGS_PERSON_GROUP_ID,
  PROP_I_FACE_LOG_DELETE_PERSON_GROUP_ARGS_TOKEN
};

/* reads a i_face_log_delete_person_group_args object */
static gint32
i_face_log_delete_person_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeletePersonGroupArgs * this_object = I_FACE_LOG_DELETE_PERSON_GROUP_ARGS(object);
  gboolean isset_personGroupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_delete_person_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeletePersonGroupArgs * this_object = I_FACE_LOG_DELETE_PERSON_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeletePersonGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_person_group_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogDeletePersonGroupArgs *self = I_FACE_LOG_DELETE_PERSON_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSON_GROUP_ARGS_PERSON_GROUP_ID:
      self->personGroupId = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_DELETE_PERSON_GROUP_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_person_group_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogDeletePersonGroupArgs *self = I_FACE_LOG_DELETE_PERSON_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSON_GROUP_ARGS_PERSON_GROUP_ID:
      g_value_set_int (value, self->personGroupId);
      break;

    case PROP_I_FACE_LOG_DELETE_PERSON_GROUP_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_person_group_args_instance_init (IFaceLogDeletePersonGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personGroupId = 0;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_delete_person_group_args_finalize (GObject *object)
{
  IFaceLogDeletePersonGroupArgs *tobject = I_FACE_LOG_DELETE_PERSON_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_delete_person_group_args_class_init (IFaceLogDeletePersonGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_person_group_args_read;
  struct_class->write = i_face_log_delete_person_group_args_write;

  gobject_class->finalize = i_face_log_delete_person_group_args_finalize;
  gobject_class->get_property = i_face_log_delete_person_group_args_get_property;
  gobject_class->set_property = i_face_log_delete_person_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSON_GROUP_ARGS_PERSON_GROUP_ID,
     g_param_spec_int ("personGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSON_GROUP_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_person_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeletePersonGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_person_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeletePersonGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_person_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeletePersonGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeletePersonGroupResultProperties
{
  PROP_I_FACE_LOG_DELETE_PERSON_GROUP_RESULT_0,
  PROP_I_FACE_LOG_DELETE_PERSON_GROUP_RESULT_SUCCESS,
  PROP_I_FACE_LOG_DELETE_PERSON_GROUP_RESULT_EX1
};

/* reads a i_face_log_delete_person_group_result object */
static gint32
i_face_log_delete_person_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeletePersonGroupResult * this_object = I_FACE_LOG_DELETE_PERSON_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_delete_person_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeletePersonGroupResult * this_object = I_FACE_LOG_DELETE_PERSON_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeletePersonGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_person_group_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogDeletePersonGroupResult *self = I_FACE_LOG_DELETE_PERSON_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSON_GROUP_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_DELETE_PERSON_GROUP_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_person_group_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogDeletePersonGroupResult *self = I_FACE_LOG_DELETE_PERSON_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSON_GROUP_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_DELETE_PERSON_GROUP_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_person_group_result_instance_init (IFaceLogDeletePersonGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_delete_person_group_result_finalize (GObject *object)
{
  IFaceLogDeletePersonGroupResult *tobject = I_FACE_LOG_DELETE_PERSON_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_delete_person_group_result_class_init (IFaceLogDeletePersonGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_person_group_result_read;
  struct_class->write = i_face_log_delete_person_group_result_write;

  gobject_class->finalize = i_face_log_delete_person_group_result_finalize;
  gobject_class->get_property = i_face_log_delete_person_group_result_get_property;
  gobject_class->set_property = i_face_log_delete_person_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSON_GROUP_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSON_GROUP_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_person_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeletePersonGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_person_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeletePersonGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_person_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeletePersonGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeletePersonGroupPermitArgsProperties
{
  PROP_I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_ARGS_0,
  PROP_I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_ARGS_PERSON_GROUP_ID,
  PROP_I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_ARGS_TOKEN
};

/* reads a i_face_log_delete_person_group_permit_args object */
static gint32
i_face_log_delete_person_group_permit_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeletePersonGroupPermitArgs * this_object = I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_ARGS(object);
  gboolean isset_personGroupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_delete_person_group_permit_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeletePersonGroupPermitArgs * this_object = I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeletePersonGroupPermitArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_person_group_permit_args_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  IFaceLogDeletePersonGroupPermitArgs *self = I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_ARGS_PERSON_GROUP_ID:
      self->personGroupId = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_person_group_permit_args_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  IFaceLogDeletePersonGroupPermitArgs *self = I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_ARGS_PERSON_GROUP_ID:
      g_value_set_int (value, self->personGroupId);
      break;

    case PROP_I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_person_group_permit_args_instance_init (IFaceLogDeletePersonGroupPermitArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personGroupId = 0;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_delete_person_group_permit_args_finalize (GObject *object)
{
  IFaceLogDeletePersonGroupPermitArgs *tobject = I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_delete_person_group_permit_args_class_init (IFaceLogDeletePersonGroupPermitArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_person_group_permit_args_read;
  struct_class->write = i_face_log_delete_person_group_permit_args_write;

  gobject_class->finalize = i_face_log_delete_person_group_permit_args_finalize;
  gobject_class->get_property = i_face_log_delete_person_group_permit_args_get_property;
  gobject_class->set_property = i_face_log_delete_person_group_permit_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_ARGS_PERSON_GROUP_ID,
     g_param_spec_int ("personGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_person_group_permit_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeletePersonGroupPermitArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_person_group_permit_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeletePersonGroupPermitArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_person_group_permit_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeletePersonGroupPermitArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeletePersonGroupPermitResultProperties
{
  PROP_I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_RESULT_0,
  PROP_I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_RESULT_SUCCESS,
  PROP_I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_RESULT_EX1
};

/* reads a i_face_log_delete_person_group_permit_result object */
static gint32
i_face_log_delete_person_group_permit_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeletePersonGroupPermitResult * this_object = I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_delete_person_group_permit_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeletePersonGroupPermitResult * this_object = I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeletePersonGroupPermitResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_person_group_permit_result_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  IFaceLogDeletePersonGroupPermitResult *self = I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_person_group_permit_result_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  IFaceLogDeletePersonGroupPermitResult *self = I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_person_group_permit_result_instance_init (IFaceLogDeletePersonGroupPermitResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_delete_person_group_permit_result_finalize (GObject *object)
{
  IFaceLogDeletePersonGroupPermitResult *tobject = I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_delete_person_group_permit_result_class_init (IFaceLogDeletePersonGroupPermitResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_person_group_permit_result_read;
  struct_class->write = i_face_log_delete_person_group_permit_result_write;

  gobject_class->finalize = i_face_log_delete_person_group_permit_result_finalize;
  gobject_class->get_property = i_face_log_delete_person_group_permit_result_get_property;
  gobject_class->set_property = i_face_log_delete_person_group_permit_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_person_group_permit_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeletePersonGroupPermitResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_person_group_permit_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeletePersonGroupPermitResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_person_group_permit_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeletePersonGroupPermitResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeletePersonsArgsProperties
{
  PROP_I_FACE_LOG_DELETE_PERSONS_ARGS_0,
  PROP_I_FACE_LOG_DELETE_PERSONS_ARGS_PERSON_ID_LIST,
  PROP_I_FACE_LOG_DELETE_PERSONS_ARGS_TOKEN
};

/* reads a i_face_log_delete_persons_args object */
static gint32
i_face_log_delete_persons_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeletePersonsArgs * this_object = I_FACE_LOG_DELETE_PERSONS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem22 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem22, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->personIdList, _elem22, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_personIdList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_delete_persons_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeletePersonsArgs * this_object = I_FACE_LOG_DELETE_PERSONS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeletePersonsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personIdList", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i23;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->personIdList ? this_object->personIdList->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i23 = 0; i23 < (this_object->personIdList ? this_object->personIdList->len : 0); i23++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->personIdList, gint32, i23)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_persons_args_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogDeletePersonsArgs *self = I_FACE_LOG_DELETE_PERSONS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSONS_ARGS_PERSON_ID_LIST:
      if (self->personIdList != NULL)
        g_array_unref (self->personIdList);
      self->personIdList = g_value_dup_boxed (value);
      self->__isset_personIdList = TRUE;
      break;

    case PROP_I_FACE_LOG_DELETE_PERSONS_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_persons_args_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogDeletePersonsArgs *self = I_FACE_LOG_DELETE_PERSONS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSONS_ARGS_PERSON_ID_LIST:
      g_value_set_boxed (value, self->personIdList);
      break;

    case PROP_I_FACE_LOG_DELETE_PERSONS_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_persons_args_instance_init (IFaceLogDeletePersonsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personIdList = g_array_new (0, 1, sizeof (gint32));
  object->__isset_personIdList = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_delete_persons_args_finalize (GObject *object)
{
  IFaceLogDeletePersonsArgs *tobject = I_FACE_LOG_DELETE_PERSONS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->personIdList != NULL)
  {
    g_array_unref (tobject->personIdList);
    tobject->personIdList = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_delete_persons_args_class_init (IFaceLogDeletePersonsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_persons_args_read;
  struct_class->write = i_face_log_delete_persons_args_write;

  gobject_class->finalize = i_face_log_delete_persons_args_finalize;
  gobject_class->get_property = i_face_log_delete_persons_args_get_property;
  gobject_class->set_property = i_face_log_delete_persons_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSONS_ARGS_PERSON_ID_LIST,
     g_param_spec_boxed ("personIdList",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSONS_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_persons_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeletePersonsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_persons_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeletePersonsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_persons_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeletePersonsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeletePersonsResultProperties
{
  PROP_I_FACE_LOG_DELETE_PERSONS_RESULT_0,
  PROP_I_FACE_LOG_DELETE_PERSONS_RESULT_SUCCESS,
  PROP_I_FACE_LOG_DELETE_PERSONS_RESULT_EX1
};

/* reads a i_face_log_delete_persons_result object */
static gint32
i_face_log_delete_persons_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeletePersonsResult * this_object = I_FACE_LOG_DELETE_PERSONS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_delete_persons_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeletePersonsResult * this_object = I_FACE_LOG_DELETE_PERSONS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeletePersonsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_persons_result_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogDeletePersonsResult *self = I_FACE_LOG_DELETE_PERSONS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSONS_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_DELETE_PERSONS_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_persons_result_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogDeletePersonsResult *self = I_FACE_LOG_DELETE_PERSONS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSONS_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_DELETE_PERSONS_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_persons_result_instance_init (IFaceLogDeletePersonsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_delete_persons_result_finalize (GObject *object)
{
  IFaceLogDeletePersonsResult *tobject = I_FACE_LOG_DELETE_PERSONS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_delete_persons_result_class_init (IFaceLogDeletePersonsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_persons_result_read;
  struct_class->write = i_face_log_delete_persons_result_write;

  gobject_class->finalize = i_face_log_delete_persons_result_finalize;
  gobject_class->get_property = i_face_log_delete_persons_result_get_property;
  gobject_class->set_property = i_face_log_delete_persons_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSONS_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSONS_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_persons_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeletePersonsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_persons_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeletePersonsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_persons_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeletePersonsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeletePersonsByPapersNumArgsProperties
{
  PROP_I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_ARGS_0,
  PROP_I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_ARGS_PAPERS_NUMLIST,
  PROP_I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_ARGS_TOKEN
};

/* reads a i_face_log_delete_persons_by_papers_num_args object */
static gint32
i_face_log_delete_persons_by_papers_num_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeletePersonsByPapersNumArgs * this_object = I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem24 = NULL;
              if (_elem24 != NULL)
              {
                g_free(_elem24);
                _elem24 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem24, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->papersNumlist, _elem24);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_papersNumlist = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_delete_persons_by_papers_num_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeletePersonsByPapersNumArgs * this_object = I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeletePersonsByPapersNumArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "papersNumlist", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i25;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->papersNumlist ? this_object->papersNumlist->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i25 = 0; i25 < (this_object->papersNumlist ? this_object->papersNumlist->len : 0); i25++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->papersNumlist, i25)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_persons_by_papers_num_args_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  IFaceLogDeletePersonsByPapersNumArgs *self = I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_ARGS_PAPERS_NUMLIST:
      if (self->papersNumlist != NULL)
        g_ptr_array_unref (self->papersNumlist);
      self->papersNumlist = g_value_dup_boxed (value);
      self->__isset_papersNumlist = TRUE;
      break;

    case PROP_I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_persons_by_papers_num_args_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  IFaceLogDeletePersonsByPapersNumArgs *self = I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_ARGS_PAPERS_NUMLIST:
      g_value_set_boxed (value, self->papersNumlist);
      break;

    case PROP_I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_persons_by_papers_num_args_instance_init (IFaceLogDeletePersonsByPapersNumArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->papersNumlist = g_ptr_array_new_with_free_func (g_free);
  object->__isset_papersNumlist = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_delete_persons_by_papers_num_args_finalize (GObject *object)
{
  IFaceLogDeletePersonsByPapersNumArgs *tobject = I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->papersNumlist != NULL)
  {
    g_ptr_array_unref (tobject->papersNumlist);
    tobject->papersNumlist = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_delete_persons_by_papers_num_args_class_init (IFaceLogDeletePersonsByPapersNumArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_persons_by_papers_num_args_read;
  struct_class->write = i_face_log_delete_persons_by_papers_num_args_write;

  gobject_class->finalize = i_face_log_delete_persons_by_papers_num_args_finalize;
  gobject_class->get_property = i_face_log_delete_persons_by_papers_num_args_get_property;
  gobject_class->set_property = i_face_log_delete_persons_by_papers_num_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_ARGS_PAPERS_NUMLIST,
     g_param_spec_boxed ("papersNumlist",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_persons_by_papers_num_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeletePersonsByPapersNumArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_persons_by_papers_num_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeletePersonsByPapersNumArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_persons_by_papers_num_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeletePersonsByPapersNumArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDeletePersonsByPapersNumResultProperties
{
  PROP_I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_RESULT_0,
  PROP_I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_RESULT_SUCCESS,
  PROP_I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_RESULT_EX1
};

/* reads a i_face_log_delete_persons_by_papers_num_result object */
static gint32
i_face_log_delete_persons_by_papers_num_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDeletePersonsByPapersNumResult * this_object = I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_delete_persons_by_papers_num_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDeletePersonsByPapersNumResult * this_object = I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDeletePersonsByPapersNumResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_delete_persons_by_papers_num_result_set_property (GObject *object,
                                                             guint property_id,
                                                             const GValue *value,
                                                             GParamSpec *pspec)
{
  IFaceLogDeletePersonsByPapersNumResult *self = I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_delete_persons_by_papers_num_result_get_property (GObject *object,
                                                             guint property_id,
                                                             GValue *value,
                                                             GParamSpec *pspec)
{
  IFaceLogDeletePersonsByPapersNumResult *self = I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_delete_persons_by_papers_num_result_instance_init (IFaceLogDeletePersonsByPapersNumResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_delete_persons_by_papers_num_result_finalize (GObject *object)
{
  IFaceLogDeletePersonsByPapersNumResult *tobject = I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_delete_persons_by_papers_num_result_class_init (IFaceLogDeletePersonsByPapersNumResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_delete_persons_by_papers_num_result_read;
  struct_class->write = i_face_log_delete_persons_by_papers_num_result_write;

  gobject_class->finalize = i_face_log_delete_persons_by_papers_num_result_finalize;
  gobject_class->get_property = i_face_log_delete_persons_by_papers_num_result_get_property;
  gobject_class->set_property = i_face_log_delete_persons_by_papers_num_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_delete_persons_by_papers_num_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDeletePersonsByPapersNumResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_delete_persons_by_papers_num_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDeletePersonsByPapersNumResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_delete_persons_by_papers_num_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDeletePersonsByPapersNumResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDisablePersonArgsProperties
{
  PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_0,
  PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_PERSON_ID,
  PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_MOVE_TO_GROUP_ID,
  PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_DELETE_PHOTO,
  PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_DELETE_FEATURE,
  PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_DELETE_LOG,
  PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_TOKEN
};

/* reads a i_face_log_disable_person_args object */
static gint32
i_face_log_disable_person_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDisablePersonArgs * this_object = I_FACE_LOG_DISABLE_PERSON_ARGS(object);
  gboolean isset_personId = FALSE;
  gboolean isset_deletePhoto = FALSE;
  gboolean isset_deleteFeature = FALSE;
  gboolean isset_deleteLog = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->moveToGroupId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_moveToGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->deletePhoto, error)) < 0)
            return -1;
          xfer += ret;
          isset_deletePhoto = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->deleteFeature, error)) < 0)
            return -1;
          xfer += ret;
          isset_deleteFeature = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->deleteLog, error)) < 0)
            return -1;
          xfer += ret;
          isset_deleteLog = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_deletePhoto)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_deleteFeature)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_deleteLog)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_disable_person_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDisablePersonArgs * this_object = I_FACE_LOG_DISABLE_PERSON_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDisablePersonArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "moveToGroupId", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->moveToGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deletePhoto", T_BOOL, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->deletePhoto, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deleteFeature", T_BOOL, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->deleteFeature, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deleteLog", T_BOOL, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->deleteLog, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_disable_person_args_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogDisablePersonArgs *self = I_FACE_LOG_DISABLE_PERSON_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_PERSON_ID:
      self->personId = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_MOVE_TO_GROUP_ID:
      self->moveToGroupId = g_value_get_int (value);
      self->__isset_moveToGroupId = TRUE;
      break;

    case PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_DELETE_PHOTO:
      self->deletePhoto = g_value_get_boolean (value);
      break;

    case PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_DELETE_FEATURE:
      self->deleteFeature = g_value_get_boolean (value);
      break;

    case PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_DELETE_LOG:
      self->deleteLog = g_value_get_boolean (value);
      break;

    case PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_disable_person_args_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogDisablePersonArgs *self = I_FACE_LOG_DISABLE_PERSON_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    case PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_MOVE_TO_GROUP_ID:
      g_value_set_int (value, self->moveToGroupId);
      break;

    case PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_DELETE_PHOTO:
      g_value_set_boolean (value, self->deletePhoto);
      break;

    case PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_DELETE_FEATURE:
      g_value_set_boolean (value, self->deleteFeature);
      break;

    case PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_DELETE_LOG:
      g_value_set_boolean (value, self->deleteLog);
      break;

    case PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_disable_person_args_instance_init (IFaceLogDisablePersonArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personId = 0;
  object->moveToGroupId = 0;
  object->__isset_moveToGroupId = FALSE;
  object->deletePhoto = 0;
  object->deleteFeature = 0;
  object->deleteLog = 0;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_disable_person_args_finalize (GObject *object)
{
  IFaceLogDisablePersonArgs *tobject = I_FACE_LOG_DISABLE_PERSON_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_disable_person_args_class_init (IFaceLogDisablePersonArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_disable_person_args_read;
  struct_class->write = i_face_log_disable_person_args_write;

  gobject_class->finalize = i_face_log_disable_person_args_finalize;
  gobject_class->get_property = i_face_log_disable_person_args_get_property;
  gobject_class->set_property = i_face_log_disable_person_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_MOVE_TO_GROUP_ID,
     g_param_spec_int ("moveToGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_DELETE_PHOTO,
     g_param_spec_boolean ("deletePhoto",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_DELETE_FEATURE,
     g_param_spec_boolean ("deleteFeature",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_DELETE_LOG,
     g_param_spec_boolean ("deleteLog",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DISABLE_PERSON_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_disable_person_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDisablePersonArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_disable_person_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDisablePersonArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_disable_person_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDisablePersonArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDisablePersonResultProperties
{
  PROP_I_FACE_LOG_DISABLE_PERSON_RESULT_0,
  PROP_I_FACE_LOG_DISABLE_PERSON_RESULT_EX1
};

/* reads a i_face_log_disable_person_result object */
static gint32
i_face_log_disable_person_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDisablePersonResult * this_object = I_FACE_LOG_DISABLE_PERSON_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_disable_person_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDisablePersonResult * this_object = I_FACE_LOG_DISABLE_PERSON_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDisablePersonResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_disable_person_result_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogDisablePersonResult *self = I_FACE_LOG_DISABLE_PERSON_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DISABLE_PERSON_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_disable_person_result_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogDisablePersonResult *self = I_FACE_LOG_DISABLE_PERSON_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DISABLE_PERSON_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_disable_person_result_instance_init (IFaceLogDisablePersonResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_disable_person_result_finalize (GObject *object)
{
  IFaceLogDisablePersonResult *tobject = I_FACE_LOG_DISABLE_PERSON_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_disable_person_result_class_init (IFaceLogDisablePersonResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_disable_person_result_read;
  struct_class->write = i_face_log_disable_person_result_write;

  gobject_class->finalize = i_face_log_disable_person_result_finalize;
  gobject_class->get_property = i_face_log_disable_person_result_get_property;
  gobject_class->set_property = i_face_log_disable_person_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DISABLE_PERSON_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_disable_person_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDisablePersonResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_disable_person_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDisablePersonResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_disable_person_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDisablePersonResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDisablePersonListArgsProperties
{
  PROP_I_FACE_LOG_DISABLE_PERSON_LIST_ARGS_0,
  PROP_I_FACE_LOG_DISABLE_PERSON_LIST_ARGS_PERSON_ID_LIST,
  PROP_I_FACE_LOG_DISABLE_PERSON_LIST_ARGS_TOKEN
};

/* reads a i_face_log_disable_person_list_args object */
static gint32
i_face_log_disable_person_list_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDisablePersonListArgs * this_object = I_FACE_LOG_DISABLE_PERSON_LIST_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem26 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem26, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->personIdList, _elem26, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_personIdList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_disable_person_list_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDisablePersonListArgs * this_object = I_FACE_LOG_DISABLE_PERSON_LIST_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDisablePersonListArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personIdList", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i27;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->personIdList ? this_object->personIdList->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i27 = 0; i27 < (this_object->personIdList ? this_object->personIdList->len : 0); i27++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->personIdList, gint32, i27)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_disable_person_list_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogDisablePersonListArgs *self = I_FACE_LOG_DISABLE_PERSON_LIST_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DISABLE_PERSON_LIST_ARGS_PERSON_ID_LIST:
      if (self->personIdList != NULL)
        g_array_unref (self->personIdList);
      self->personIdList = g_value_dup_boxed (value);
      self->__isset_personIdList = TRUE;
      break;

    case PROP_I_FACE_LOG_DISABLE_PERSON_LIST_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_disable_person_list_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogDisablePersonListArgs *self = I_FACE_LOG_DISABLE_PERSON_LIST_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DISABLE_PERSON_LIST_ARGS_PERSON_ID_LIST:
      g_value_set_boxed (value, self->personIdList);
      break;

    case PROP_I_FACE_LOG_DISABLE_PERSON_LIST_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_disable_person_list_args_instance_init (IFaceLogDisablePersonListArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personIdList = g_array_new (0, 1, sizeof (gint32));
  object->__isset_personIdList = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_disable_person_list_args_finalize (GObject *object)
{
  IFaceLogDisablePersonListArgs *tobject = I_FACE_LOG_DISABLE_PERSON_LIST_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->personIdList != NULL)
  {
    g_array_unref (tobject->personIdList);
    tobject->personIdList = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_disable_person_list_args_class_init (IFaceLogDisablePersonListArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_disable_person_list_args_read;
  struct_class->write = i_face_log_disable_person_list_args_write;

  gobject_class->finalize = i_face_log_disable_person_list_args_finalize;
  gobject_class->get_property = i_face_log_disable_person_list_args_get_property;
  gobject_class->set_property = i_face_log_disable_person_list_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DISABLE_PERSON_LIST_ARGS_PERSON_ID_LIST,
     g_param_spec_boxed ("personIdList",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DISABLE_PERSON_LIST_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_disable_person_list_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDisablePersonListArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_disable_person_list_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDisablePersonListArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_disable_person_list_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDisablePersonListArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogDisablePersonListResultProperties
{
  PROP_I_FACE_LOG_DISABLE_PERSON_LIST_RESULT_0,
  PROP_I_FACE_LOG_DISABLE_PERSON_LIST_RESULT_EX1
};

/* reads a i_face_log_disable_person_list_result object */
static gint32
i_face_log_disable_person_list_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogDisablePersonListResult * this_object = I_FACE_LOG_DISABLE_PERSON_LIST_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_disable_person_list_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogDisablePersonListResult * this_object = I_FACE_LOG_DISABLE_PERSON_LIST_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogDisablePersonListResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_disable_person_list_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogDisablePersonListResult *self = I_FACE_LOG_DISABLE_PERSON_LIST_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DISABLE_PERSON_LIST_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_disable_person_list_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogDisablePersonListResult *self = I_FACE_LOG_DISABLE_PERSON_LIST_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_DISABLE_PERSON_LIST_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_disable_person_list_result_instance_init (IFaceLogDisablePersonListResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_disable_person_list_result_finalize (GObject *object)
{
  IFaceLogDisablePersonListResult *tobject = I_FACE_LOG_DISABLE_PERSON_LIST_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_disable_person_list_result_class_init (IFaceLogDisablePersonListResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_disable_person_list_result_read;
  struct_class->write = i_face_log_disable_person_list_result_write;

  gobject_class->finalize = i_face_log_disable_person_list_result_finalize;
  gobject_class->get_property = i_face_log_disable_person_list_result_get_property;
  gobject_class->set_property = i_face_log_disable_person_list_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_DISABLE_PERSON_LIST_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_disable_person_list_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogDisablePersonListResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_disable_person_list_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogDisablePersonListResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_disable_person_list_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogDisablePersonListResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogExistsDeviceArgsProperties
{
  PROP_I_FACE_LOG_EXISTS_DEVICE_ARGS_0,
  PROP_I_FACE_LOG_EXISTS_DEVICE_ARGS_ID
};

/* reads a i_face_log_exists_device_args object */
static gint32
i_face_log_exists_device_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogExistsDeviceArgs * this_object = I_FACE_LOG_EXISTS_DEVICE_ARGS(object);
  gboolean isset_id = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_id)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_exists_device_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogExistsDeviceArgs * this_object = I_FACE_LOG_EXISTS_DEVICE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogExistsDeviceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->id, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_exists_device_args_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogExistsDeviceArgs *self = I_FACE_LOG_EXISTS_DEVICE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_EXISTS_DEVICE_ARGS_ID:
      self->id = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_exists_device_args_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogExistsDeviceArgs *self = I_FACE_LOG_EXISTS_DEVICE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_EXISTS_DEVICE_ARGS_ID:
      g_value_set_int (value, self->id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_exists_device_args_instance_init (IFaceLogExistsDeviceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = 0;
}

static void 
i_face_log_exists_device_args_finalize (GObject *object)
{
  IFaceLogExistsDeviceArgs *tobject = I_FACE_LOG_EXISTS_DEVICE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_exists_device_args_class_init (IFaceLogExistsDeviceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_exists_device_args_read;
  struct_class->write = i_face_log_exists_device_args_write;

  gobject_class->finalize = i_face_log_exists_device_args_finalize;
  gobject_class->get_property = i_face_log_exists_device_args_get_property;
  gobject_class->set_property = i_face_log_exists_device_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_EXISTS_DEVICE_ARGS_ID,
     g_param_spec_int ("id",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_exists_device_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogExistsDeviceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_exists_device_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogExistsDeviceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_exists_device_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogExistsDeviceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogExistsDeviceResultProperties
{
  PROP_I_FACE_LOG_EXISTS_DEVICE_RESULT_0,
  PROP_I_FACE_LOG_EXISTS_DEVICE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_EXISTS_DEVICE_RESULT_EX1
};

/* reads a i_face_log_exists_device_result object */
static gint32
i_face_log_exists_device_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogExistsDeviceResult * this_object = I_FACE_LOG_EXISTS_DEVICE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_exists_device_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogExistsDeviceResult * this_object = I_FACE_LOG_EXISTS_DEVICE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogExistsDeviceResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_exists_device_result_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogExistsDeviceResult *self = I_FACE_LOG_EXISTS_DEVICE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_EXISTS_DEVICE_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_EXISTS_DEVICE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_exists_device_result_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogExistsDeviceResult *self = I_FACE_LOG_EXISTS_DEVICE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_EXISTS_DEVICE_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_I_FACE_LOG_EXISTS_DEVICE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_exists_device_result_instance_init (IFaceLogExistsDeviceResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_exists_device_result_finalize (GObject *object)
{
  IFaceLogExistsDeviceResult *tobject = I_FACE_LOG_EXISTS_DEVICE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_exists_device_result_class_init (IFaceLogExistsDeviceResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_exists_device_result_read;
  struct_class->write = i_face_log_exists_device_result_write;

  gobject_class->finalize = i_face_log_exists_device_result_finalize;
  gobject_class->get_property = i_face_log_exists_device_result_get_property;
  gobject_class->set_property = i_face_log_exists_device_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_EXISTS_DEVICE_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_EXISTS_DEVICE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_exists_device_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogExistsDeviceResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_exists_device_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogExistsDeviceResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_exists_device_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogExistsDeviceResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogExistsFeatureArgsProperties
{
  PROP_I_FACE_LOG_EXISTS_FEATURE_ARGS_0,
  PROP_I_FACE_LOG_EXISTS_FEATURE_ARGS_MD5
};

/* reads a i_face_log_exists_feature_args object */
static gint32
i_face_log_exists_feature_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogExistsFeatureArgs * this_object = I_FACE_LOG_EXISTS_FEATURE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->md5 != NULL)
          {
            g_free(this_object->md5);
            this_object->md5 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->md5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_md5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_exists_feature_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogExistsFeatureArgs * this_object = I_FACE_LOG_EXISTS_FEATURE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogExistsFeatureArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "md5", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->md5, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_exists_feature_args_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogExistsFeatureArgs *self = I_FACE_LOG_EXISTS_FEATURE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_EXISTS_FEATURE_ARGS_MD5:
      if (self->md5 != NULL)
        g_free (self->md5);
      self->md5 = g_value_dup_string (value);
      self->__isset_md5 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_exists_feature_args_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogExistsFeatureArgs *self = I_FACE_LOG_EXISTS_FEATURE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_EXISTS_FEATURE_ARGS_MD5:
      g_value_set_string (value, self->md5);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_exists_feature_args_instance_init (IFaceLogExistsFeatureArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->md5 = NULL;
  object->__isset_md5 = FALSE;
}

static void 
i_face_log_exists_feature_args_finalize (GObject *object)
{
  IFaceLogExistsFeatureArgs *tobject = I_FACE_LOG_EXISTS_FEATURE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->md5 != NULL)
  {
    g_free(tobject->md5);
    tobject->md5 = NULL;
  }
}

static void
i_face_log_exists_feature_args_class_init (IFaceLogExistsFeatureArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_exists_feature_args_read;
  struct_class->write = i_face_log_exists_feature_args_write;

  gobject_class->finalize = i_face_log_exists_feature_args_finalize;
  gobject_class->get_property = i_face_log_exists_feature_args_get_property;
  gobject_class->set_property = i_face_log_exists_feature_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_EXISTS_FEATURE_ARGS_MD5,
     g_param_spec_string ("md5",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_exists_feature_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogExistsFeatureArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_exists_feature_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogExistsFeatureArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_exists_feature_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogExistsFeatureArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogExistsFeatureResultProperties
{
  PROP_I_FACE_LOG_EXISTS_FEATURE_RESULT_0,
  PROP_I_FACE_LOG_EXISTS_FEATURE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_EXISTS_FEATURE_RESULT_EX1
};

/* reads a i_face_log_exists_feature_result object */
static gint32
i_face_log_exists_feature_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogExistsFeatureResult * this_object = I_FACE_LOG_EXISTS_FEATURE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_exists_feature_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogExistsFeatureResult * this_object = I_FACE_LOG_EXISTS_FEATURE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogExistsFeatureResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_exists_feature_result_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogExistsFeatureResult *self = I_FACE_LOG_EXISTS_FEATURE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_EXISTS_FEATURE_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_EXISTS_FEATURE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_exists_feature_result_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogExistsFeatureResult *self = I_FACE_LOG_EXISTS_FEATURE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_EXISTS_FEATURE_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_I_FACE_LOG_EXISTS_FEATURE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_exists_feature_result_instance_init (IFaceLogExistsFeatureResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_exists_feature_result_finalize (GObject *object)
{
  IFaceLogExistsFeatureResult *tobject = I_FACE_LOG_EXISTS_FEATURE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_exists_feature_result_class_init (IFaceLogExistsFeatureResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_exists_feature_result_read;
  struct_class->write = i_face_log_exists_feature_result_write;

  gobject_class->finalize = i_face_log_exists_feature_result_finalize;
  gobject_class->get_property = i_face_log_exists_feature_result_get_property;
  gobject_class->set_property = i_face_log_exists_feature_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_EXISTS_FEATURE_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_EXISTS_FEATURE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_exists_feature_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogExistsFeatureResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_exists_feature_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogExistsFeatureResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_exists_feature_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogExistsFeatureResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogExistsImageArgsProperties
{
  PROP_I_FACE_LOG_EXISTS_IMAGE_ARGS_0,
  PROP_I_FACE_LOG_EXISTS_IMAGE_ARGS_MD5
};

/* reads a i_face_log_exists_image_args object */
static gint32
i_face_log_exists_image_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogExistsImageArgs * this_object = I_FACE_LOG_EXISTS_IMAGE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->md5 != NULL)
          {
            g_free(this_object->md5);
            this_object->md5 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->md5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_md5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_exists_image_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogExistsImageArgs * this_object = I_FACE_LOG_EXISTS_IMAGE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogExistsImageArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "md5", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->md5, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_exists_image_args_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogExistsImageArgs *self = I_FACE_LOG_EXISTS_IMAGE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_EXISTS_IMAGE_ARGS_MD5:
      if (self->md5 != NULL)
        g_free (self->md5);
      self->md5 = g_value_dup_string (value);
      self->__isset_md5 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_exists_image_args_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogExistsImageArgs *self = I_FACE_LOG_EXISTS_IMAGE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_EXISTS_IMAGE_ARGS_MD5:
      g_value_set_string (value, self->md5);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_exists_image_args_instance_init (IFaceLogExistsImageArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->md5 = NULL;
  object->__isset_md5 = FALSE;
}

static void 
i_face_log_exists_image_args_finalize (GObject *object)
{
  IFaceLogExistsImageArgs *tobject = I_FACE_LOG_EXISTS_IMAGE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->md5 != NULL)
  {
    g_free(tobject->md5);
    tobject->md5 = NULL;
  }
}

static void
i_face_log_exists_image_args_class_init (IFaceLogExistsImageArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_exists_image_args_read;
  struct_class->write = i_face_log_exists_image_args_write;

  gobject_class->finalize = i_face_log_exists_image_args_finalize;
  gobject_class->get_property = i_face_log_exists_image_args_get_property;
  gobject_class->set_property = i_face_log_exists_image_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_EXISTS_IMAGE_ARGS_MD5,
     g_param_spec_string ("md5",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_exists_image_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogExistsImageArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_exists_image_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogExistsImageArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_exists_image_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogExistsImageArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogExistsImageResultProperties
{
  PROP_I_FACE_LOG_EXISTS_IMAGE_RESULT_0,
  PROP_I_FACE_LOG_EXISTS_IMAGE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_EXISTS_IMAGE_RESULT_EX1
};

/* reads a i_face_log_exists_image_result object */
static gint32
i_face_log_exists_image_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogExistsImageResult * this_object = I_FACE_LOG_EXISTS_IMAGE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_exists_image_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogExistsImageResult * this_object = I_FACE_LOG_EXISTS_IMAGE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogExistsImageResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_exists_image_result_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogExistsImageResult *self = I_FACE_LOG_EXISTS_IMAGE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_EXISTS_IMAGE_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_EXISTS_IMAGE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_exists_image_result_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogExistsImageResult *self = I_FACE_LOG_EXISTS_IMAGE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_EXISTS_IMAGE_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_I_FACE_LOG_EXISTS_IMAGE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_exists_image_result_instance_init (IFaceLogExistsImageResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_exists_image_result_finalize (GObject *object)
{
  IFaceLogExistsImageResult *tobject = I_FACE_LOG_EXISTS_IMAGE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_exists_image_result_class_init (IFaceLogExistsImageResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_exists_image_result_read;
  struct_class->write = i_face_log_exists_image_result_write;

  gobject_class->finalize = i_face_log_exists_image_result_finalize;
  gobject_class->get_property = i_face_log_exists_image_result_get_property;
  gobject_class->set_property = i_face_log_exists_image_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_EXISTS_IMAGE_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_EXISTS_IMAGE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_exists_image_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogExistsImageResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_exists_image_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogExistsImageResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_exists_image_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogExistsImageResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogExistsPersonArgsProperties
{
  PROP_I_FACE_LOG_EXISTS_PERSON_ARGS_0,
  PROP_I_FACE_LOG_EXISTS_PERSON_ARGS_PERSION_ID
};

/* reads a i_face_log_exists_person_args object */
static gint32
i_face_log_exists_person_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogExistsPersonArgs * this_object = I_FACE_LOG_EXISTS_PERSON_ARGS(object);
  gboolean isset_persionId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->persionId, error)) < 0)
            return -1;
          xfer += ret;
          isset_persionId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_persionId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_exists_person_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogExistsPersonArgs * this_object = I_FACE_LOG_EXISTS_PERSON_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogExistsPersonArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "persionId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->persionId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_exists_person_args_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogExistsPersonArgs *self = I_FACE_LOG_EXISTS_PERSON_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_EXISTS_PERSON_ARGS_PERSION_ID:
      self->persionId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_exists_person_args_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogExistsPersonArgs *self = I_FACE_LOG_EXISTS_PERSON_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_EXISTS_PERSON_ARGS_PERSION_ID:
      g_value_set_int (value, self->persionId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_exists_person_args_instance_init (IFaceLogExistsPersonArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->persionId = 0;
}

static void 
i_face_log_exists_person_args_finalize (GObject *object)
{
  IFaceLogExistsPersonArgs *tobject = I_FACE_LOG_EXISTS_PERSON_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_exists_person_args_class_init (IFaceLogExistsPersonArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_exists_person_args_read;
  struct_class->write = i_face_log_exists_person_args_write;

  gobject_class->finalize = i_face_log_exists_person_args_finalize;
  gobject_class->get_property = i_face_log_exists_person_args_get_property;
  gobject_class->set_property = i_face_log_exists_person_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_EXISTS_PERSON_ARGS_PERSION_ID,
     g_param_spec_int ("persionId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_exists_person_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogExistsPersonArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_exists_person_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogExistsPersonArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_exists_person_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogExistsPersonArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogExistsPersonResultProperties
{
  PROP_I_FACE_LOG_EXISTS_PERSON_RESULT_0,
  PROP_I_FACE_LOG_EXISTS_PERSON_RESULT_SUCCESS,
  PROP_I_FACE_LOG_EXISTS_PERSON_RESULT_EX1
};

/* reads a i_face_log_exists_person_result object */
static gint32
i_face_log_exists_person_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogExistsPersonResult * this_object = I_FACE_LOG_EXISTS_PERSON_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_exists_person_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogExistsPersonResult * this_object = I_FACE_LOG_EXISTS_PERSON_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogExistsPersonResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_exists_person_result_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogExistsPersonResult *self = I_FACE_LOG_EXISTS_PERSON_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_EXISTS_PERSON_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_EXISTS_PERSON_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_exists_person_result_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogExistsPersonResult *self = I_FACE_LOG_EXISTS_PERSON_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_EXISTS_PERSON_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_I_FACE_LOG_EXISTS_PERSON_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_exists_person_result_instance_init (IFaceLogExistsPersonResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_exists_person_result_finalize (GObject *object)
{
  IFaceLogExistsPersonResult *tobject = I_FACE_LOG_EXISTS_PERSON_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_exists_person_result_class_init (IFaceLogExistsPersonResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_exists_person_result_read;
  struct_class->write = i_face_log_exists_person_result_write;

  gobject_class->finalize = i_face_log_exists_person_result_finalize;
  gobject_class->get_property = i_face_log_exists_person_result_get_property;
  gobject_class->set_property = i_face_log_exists_person_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_EXISTS_PERSON_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_EXISTS_PERSON_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_exists_person_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogExistsPersonResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_exists_person_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogExistsPersonResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_exists_person_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogExistsPersonResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetDeviceArgsProperties
{
  PROP_I_FACE_LOG_GET_DEVICE_ARGS_0,
  PROP_I_FACE_LOG_GET_DEVICE_ARGS_DEVICE_ID
};

/* reads a i_face_log_get_device_args object */
static gint32
i_face_log_get_device_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetDeviceArgs * this_object = I_FACE_LOG_GET_DEVICE_ARGS(object);
  gboolean isset_deviceId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceId, error)) < 0)
            return -1;
          xfer += ret;
          isset_deviceId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_deviceId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_device_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetDeviceArgs * this_object = I_FACE_LOG_GET_DEVICE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetDeviceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_device_args_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  IFaceLogGetDeviceArgs *self = I_FACE_LOG_GET_DEVICE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_ARGS_DEVICE_ID:
      self->deviceId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_device_args_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  IFaceLogGetDeviceArgs *self = I_FACE_LOG_GET_DEVICE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_ARGS_DEVICE_ID:
      g_value_set_int (value, self->deviceId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_device_args_instance_init (IFaceLogGetDeviceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->deviceId = 0;
}

static void 
i_face_log_get_device_args_finalize (GObject *object)
{
  IFaceLogGetDeviceArgs *tobject = I_FACE_LOG_GET_DEVICE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_get_device_args_class_init (IFaceLogGetDeviceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_device_args_read;
  struct_class->write = i_face_log_get_device_args_write;

  gobject_class->finalize = i_face_log_get_device_args_finalize;
  gobject_class->get_property = i_face_log_get_device_args_get_property;
  gobject_class->set_property = i_face_log_get_device_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICE_ARGS_DEVICE_ID,
     g_param_spec_int ("deviceId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_get_device_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetDeviceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_device_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetDeviceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_device_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetDeviceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetDeviceResultProperties
{
  PROP_I_FACE_LOG_GET_DEVICE_RESULT_0,
  PROP_I_FACE_LOG_GET_DEVICE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_DEVICE_RESULT_EX1
};

/* reads a i_face_log_get_device_result object */
static gint32
i_face_log_get_device_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetDeviceResult * this_object = I_FACE_LOG_GET_DEVICE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_device_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetDeviceResult * this_object = I_FACE_LOG_GET_DEVICE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetDeviceResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_device_result_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogGetDeviceResult *self = I_FACE_LOG_GET_DEVICE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_DEVICE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_device_result_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogGetDeviceResult *self = I_FACE_LOG_GET_DEVICE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_DEVICE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_device_result_instance_init (IFaceLogGetDeviceResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_DEVICE_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_device_result_finalize (GObject *object)
{
  IFaceLogGetDeviceResult *tobject = I_FACE_LOG_GET_DEVICE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_device_result_class_init (IFaceLogGetDeviceResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_device_result_read;
  struct_class->write = i_face_log_get_device_result_write;

  gobject_class->finalize = i_face_log_get_device_result_finalize;
  gobject_class->get_property = i_face_log_get_device_result_get_property;
  gobject_class->set_property = i_face_log_get_device_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_DEVICE_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_device_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetDeviceResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_device_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetDeviceResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_device_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetDeviceResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetDeviceGroupArgsProperties
{
  PROP_I_FACE_LOG_GET_DEVICE_GROUP_ARGS_0,
  PROP_I_FACE_LOG_GET_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID
};

/* reads a i_face_log_get_device_group_args object */
static gint32
i_face_log_get_device_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetDeviceGroupArgs * this_object = I_FACE_LOG_GET_DEVICE_GROUP_ARGS(object);
  gboolean isset_deviceGroupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_deviceGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_deviceGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_device_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetDeviceGroupArgs * this_object = I_FACE_LOG_GET_DEVICE_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetDeviceGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_device_group_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogGetDeviceGroupArgs *self = I_FACE_LOG_GET_DEVICE_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID:
      self->deviceGroupId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_device_group_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogGetDeviceGroupArgs *self = I_FACE_LOG_GET_DEVICE_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID:
      g_value_set_int (value, self->deviceGroupId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_device_group_args_instance_init (IFaceLogGetDeviceGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->deviceGroupId = 0;
}

static void 
i_face_log_get_device_group_args_finalize (GObject *object)
{
  IFaceLogGetDeviceGroupArgs *tobject = I_FACE_LOG_GET_DEVICE_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_get_device_group_args_class_init (IFaceLogGetDeviceGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_device_group_args_read;
  struct_class->write = i_face_log_get_device_group_args_write;

  gobject_class->finalize = i_face_log_get_device_group_args_finalize;
  gobject_class->get_property = i_face_log_get_device_group_args_get_property;
  gobject_class->set_property = i_face_log_get_device_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID,
     g_param_spec_int ("deviceGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_get_device_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetDeviceGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_device_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetDeviceGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_device_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetDeviceGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetDeviceGroupResultProperties
{
  PROP_I_FACE_LOG_GET_DEVICE_GROUP_RESULT_0,
  PROP_I_FACE_LOG_GET_DEVICE_GROUP_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_DEVICE_GROUP_RESULT_EX1
};

/* reads a i_face_log_get_device_group_result object */
static gint32
i_face_log_get_device_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetDeviceGroupResult * this_object = I_FACE_LOG_GET_DEVICE_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_device_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetDeviceGroupResult * this_object = I_FACE_LOG_GET_DEVICE_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetDeviceGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_device_group_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogGetDeviceGroupResult *self = I_FACE_LOG_GET_DEVICE_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_GROUP_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_DEVICE_GROUP_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_device_group_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogGetDeviceGroupResult *self = I_FACE_LOG_GET_DEVICE_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_GROUP_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_DEVICE_GROUP_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_device_group_result_instance_init (IFaceLogGetDeviceGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_DEVICE_GROUP_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_device_group_result_finalize (GObject *object)
{
  IFaceLogGetDeviceGroupResult *tobject = I_FACE_LOG_GET_DEVICE_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_device_group_result_class_init (IFaceLogGetDeviceGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_device_group_result_read;
  struct_class->write = i_face_log_get_device_group_result_write;

  gobject_class->finalize = i_face_log_get_device_group_result_finalize;
  gobject_class->get_property = i_face_log_get_device_group_result_get_property;
  gobject_class->set_property = i_face_log_get_device_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICE_GROUP_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_DEVICE_GROUP_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICE_GROUP_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_device_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetDeviceGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_device_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetDeviceGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_device_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetDeviceGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetDeviceGroupsArgsProperties
{
  PROP_I_FACE_LOG_GET_DEVICE_GROUPS_ARGS_0,
  PROP_I_FACE_LOG_GET_DEVICE_GROUPS_ARGS_GROUP_ID_LIST
};

/* reads a i_face_log_get_device_groups_args object */
static gint32
i_face_log_get_device_groups_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetDeviceGroupsArgs * this_object = I_FACE_LOG_GET_DEVICE_GROUPS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem28 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem28, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->groupIdList, _elem28, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_groupIdList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_device_groups_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetDeviceGroupsArgs * this_object = I_FACE_LOG_GET_DEVICE_GROUPS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetDeviceGroupsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "groupIdList", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i29;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->groupIdList ? this_object->groupIdList->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i29 = 0; i29 < (this_object->groupIdList ? this_object->groupIdList->len : 0); i29++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->groupIdList, gint32, i29)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_device_groups_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogGetDeviceGroupsArgs *self = I_FACE_LOG_GET_DEVICE_GROUPS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_ARGS_GROUP_ID_LIST:
      if (self->groupIdList != NULL)
        g_array_unref (self->groupIdList);
      self->groupIdList = g_value_dup_boxed (value);
      self->__isset_groupIdList = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_device_groups_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogGetDeviceGroupsArgs *self = I_FACE_LOG_GET_DEVICE_GROUPS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_ARGS_GROUP_ID_LIST:
      g_value_set_boxed (value, self->groupIdList);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_device_groups_args_instance_init (IFaceLogGetDeviceGroupsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->groupIdList = g_array_new (0, 1, sizeof (gint32));
  object->__isset_groupIdList = FALSE;
}

static void 
i_face_log_get_device_groups_args_finalize (GObject *object)
{
  IFaceLogGetDeviceGroupsArgs *tobject = I_FACE_LOG_GET_DEVICE_GROUPS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->groupIdList != NULL)
  {
    g_array_unref (tobject->groupIdList);
    tobject->groupIdList = NULL;
  }
}

static void
i_face_log_get_device_groups_args_class_init (IFaceLogGetDeviceGroupsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_device_groups_args_read;
  struct_class->write = i_face_log_get_device_groups_args_write;

  gobject_class->finalize = i_face_log_get_device_groups_args_finalize;
  gobject_class->get_property = i_face_log_get_device_groups_args_get_property;
  gobject_class->set_property = i_face_log_get_device_groups_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICE_GROUPS_ARGS_GROUP_ID_LIST,
     g_param_spec_boxed ("groupIdList",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_device_groups_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetDeviceGroupsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_device_groups_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetDeviceGroupsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_device_groups_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetDeviceGroupsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetDeviceGroupsResultProperties
{
  PROP_I_FACE_LOG_GET_DEVICE_GROUPS_RESULT_0,
  PROP_I_FACE_LOG_GET_DEVICE_GROUPS_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_DEVICE_GROUPS_RESULT_EX1
};

/* reads a i_face_log_get_device_groups_result object */
static gint32
i_face_log_get_device_groups_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetDeviceGroupsResult * this_object = I_FACE_LOG_GET_DEVICE_GROUPS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              DeviceGroupBean * _elem30 = NULL;
              if ( _elem30 != NULL)
              {
                g_object_unref (_elem30);
              }
              _elem30 = g_object_new (TYPE_DEVICE_GROUP_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem30), protocol, error)) < 0)
              {
                g_object_unref (_elem30);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem30);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_device_groups_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetDeviceGroupsResult * this_object = I_FACE_LOG_GET_DEVICE_GROUPS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetDeviceGroupsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i31;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i31 = 0; i31 < (this_object->success ? this_object->success->len : 0); i31++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i31))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_device_groups_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogGetDeviceGroupsResult *self = I_FACE_LOG_GET_DEVICE_GROUPS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_device_groups_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogGetDeviceGroupsResult *self = I_FACE_LOG_GET_DEVICE_GROUPS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_device_groups_result_instance_init (IFaceLogGetDeviceGroupsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_device_groups_result_finalize (GObject *object)
{
  IFaceLogGetDeviceGroupsResult *tobject = I_FACE_LOG_GET_DEVICE_GROUPS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_device_groups_result_class_init (IFaceLogGetDeviceGroupsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_device_groups_result_read;
  struct_class->write = i_face_log_get_device_groups_result_write;

  gobject_class->finalize = i_face_log_get_device_groups_result_finalize;
  gobject_class->get_property = i_face_log_get_device_groups_result_get_property;
  gobject_class->set_property = i_face_log_get_device_groups_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICE_GROUPS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICE_GROUPS_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_device_groups_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetDeviceGroupsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_device_groups_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetDeviceGroupsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_device_groups_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetDeviceGroupsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetDeviceGroupsBelongsArgsProperties
{
  PROP_I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_ARGS_0,
  PROP_I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_ARGS_DEVICE_ID
};

/* reads a i_face_log_get_device_groups_belongs_args object */
static gint32
i_face_log_get_device_groups_belongs_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetDeviceGroupsBelongsArgs * this_object = I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_ARGS(object);
  gboolean isset_deviceId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceId, error)) < 0)
            return -1;
          xfer += ret;
          isset_deviceId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_deviceId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_device_groups_belongs_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetDeviceGroupsBelongsArgs * this_object = I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetDeviceGroupsBelongsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_device_groups_belongs_args_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  IFaceLogGetDeviceGroupsBelongsArgs *self = I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_ARGS_DEVICE_ID:
      self->deviceId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_device_groups_belongs_args_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  IFaceLogGetDeviceGroupsBelongsArgs *self = I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_ARGS_DEVICE_ID:
      g_value_set_int (value, self->deviceId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_device_groups_belongs_args_instance_init (IFaceLogGetDeviceGroupsBelongsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->deviceId = 0;
}

static void 
i_face_log_get_device_groups_belongs_args_finalize (GObject *object)
{
  IFaceLogGetDeviceGroupsBelongsArgs *tobject = I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_get_device_groups_belongs_args_class_init (IFaceLogGetDeviceGroupsBelongsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_device_groups_belongs_args_read;
  struct_class->write = i_face_log_get_device_groups_belongs_args_write;

  gobject_class->finalize = i_face_log_get_device_groups_belongs_args_finalize;
  gobject_class->get_property = i_face_log_get_device_groups_belongs_args_get_property;
  gobject_class->set_property = i_face_log_get_device_groups_belongs_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_ARGS_DEVICE_ID,
     g_param_spec_int ("deviceId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_get_device_groups_belongs_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetDeviceGroupsBelongsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_device_groups_belongs_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetDeviceGroupsBelongsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_device_groups_belongs_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetDeviceGroupsBelongsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetDeviceGroupsBelongsResultProperties
{
  PROP_I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_RESULT_0,
  PROP_I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_RESULT_EX1
};

/* reads a i_face_log_get_device_groups_belongs_result object */
static gint32
i_face_log_get_device_groups_belongs_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetDeviceGroupsBelongsResult * this_object = I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem32 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem32, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem32, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_device_groups_belongs_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetDeviceGroupsBelongsResult * this_object = I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetDeviceGroupsBelongsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i33;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i33 = 0; i33 < (this_object->success ? this_object->success->len : 0); i33++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i33)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_device_groups_belongs_result_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  IFaceLogGetDeviceGroupsBelongsResult *self = I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_device_groups_belongs_result_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  IFaceLogGetDeviceGroupsBelongsResult *self = I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_device_groups_belongs_result_instance_init (IFaceLogGetDeviceGroupsBelongsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_device_groups_belongs_result_finalize (GObject *object)
{
  IFaceLogGetDeviceGroupsBelongsResult *tobject = I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_device_groups_belongs_result_class_init (IFaceLogGetDeviceGroupsBelongsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_device_groups_belongs_result_read;
  struct_class->write = i_face_log_get_device_groups_belongs_result_write;

  gobject_class->finalize = i_face_log_get_device_groups_belongs_result_finalize;
  gobject_class->get_property = i_face_log_get_device_groups_belongs_result_get_property;
  gobject_class->set_property = i_face_log_get_device_groups_belongs_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_device_groups_belongs_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetDeviceGroupsBelongsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_device_groups_belongs_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetDeviceGroupsBelongsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_device_groups_belongs_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetDeviceGroupsBelongsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetDeviceGroupsPermitArgsProperties
{
  PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_ARGS_0,
  PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_ARGS_PERSON_GROUP_ID
};

/* reads a i_face_log_get_device_groups_permit_args object */
static gint32
i_face_log_get_device_groups_permit_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetDeviceGroupsPermitArgs * this_object = I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_ARGS(object);
  gboolean isset_personGroupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_device_groups_permit_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetDeviceGroupsPermitArgs * this_object = I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetDeviceGroupsPermitArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_device_groups_permit_args_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  IFaceLogGetDeviceGroupsPermitArgs *self = I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_ARGS_PERSON_GROUP_ID:
      self->personGroupId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_device_groups_permit_args_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  IFaceLogGetDeviceGroupsPermitArgs *self = I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_ARGS_PERSON_GROUP_ID:
      g_value_set_int (value, self->personGroupId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_device_groups_permit_args_instance_init (IFaceLogGetDeviceGroupsPermitArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personGroupId = 0;
}

static void 
i_face_log_get_device_groups_permit_args_finalize (GObject *object)
{
  IFaceLogGetDeviceGroupsPermitArgs *tobject = I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_get_device_groups_permit_args_class_init (IFaceLogGetDeviceGroupsPermitArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_device_groups_permit_args_read;
  struct_class->write = i_face_log_get_device_groups_permit_args_write;

  gobject_class->finalize = i_face_log_get_device_groups_permit_args_finalize;
  gobject_class->get_property = i_face_log_get_device_groups_permit_args_get_property;
  gobject_class->set_property = i_face_log_get_device_groups_permit_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_ARGS_PERSON_GROUP_ID,
     g_param_spec_int ("personGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_get_device_groups_permit_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetDeviceGroupsPermitArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_device_groups_permit_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetDeviceGroupsPermitArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_device_groups_permit_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetDeviceGroupsPermitArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetDeviceGroupsPermitResultProperties
{
  PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_RESULT_0,
  PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_RESULT_EX1
};

/* reads a i_face_log_get_device_groups_permit_result object */
static gint32
i_face_log_get_device_groups_permit_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetDeviceGroupsPermitResult * this_object = I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem34 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem34, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem34, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_device_groups_permit_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetDeviceGroupsPermitResult * this_object = I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetDeviceGroupsPermitResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i35;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i35 = 0; i35 < (this_object->success ? this_object->success->len : 0); i35++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i35)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_device_groups_permit_result_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  IFaceLogGetDeviceGroupsPermitResult *self = I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_device_groups_permit_result_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  IFaceLogGetDeviceGroupsPermitResult *self = I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_device_groups_permit_result_instance_init (IFaceLogGetDeviceGroupsPermitResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_device_groups_permit_result_finalize (GObject *object)
{
  IFaceLogGetDeviceGroupsPermitResult *tobject = I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_device_groups_permit_result_class_init (IFaceLogGetDeviceGroupsPermitResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_device_groups_permit_result_read;
  struct_class->write = i_face_log_get_device_groups_permit_result_write;

  gobject_class->finalize = i_face_log_get_device_groups_permit_result_finalize;
  gobject_class->get_property = i_face_log_get_device_groups_permit_result_get_property;
  gobject_class->set_property = i_face_log_get_device_groups_permit_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_device_groups_permit_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetDeviceGroupsPermitResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_device_groups_permit_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetDeviceGroupsPermitResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_device_groups_permit_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetDeviceGroupsPermitResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetDeviceGroupsPermittedByArgsProperties
{
  PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_ARGS_0,
  PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_ARGS_PERSON_GROUP_ID
};

/* reads a i_face_log_get_device_groups_permitted_by_args object */
static gint32
i_face_log_get_device_groups_permitted_by_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetDeviceGroupsPermittedByArgs * this_object = I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_ARGS(object);
  gboolean isset_personGroupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_device_groups_permitted_by_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetDeviceGroupsPermittedByArgs * this_object = I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetDeviceGroupsPermittedByArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_device_groups_permitted_by_args_set_property (GObject *object,
                                                             guint property_id,
                                                             const GValue *value,
                                                             GParamSpec *pspec)
{
  IFaceLogGetDeviceGroupsPermittedByArgs *self = I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_ARGS_PERSON_GROUP_ID:
      self->personGroupId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_device_groups_permitted_by_args_get_property (GObject *object,
                                                             guint property_id,
                                                             GValue *value,
                                                             GParamSpec *pspec)
{
  IFaceLogGetDeviceGroupsPermittedByArgs *self = I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_ARGS_PERSON_GROUP_ID:
      g_value_set_int (value, self->personGroupId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_device_groups_permitted_by_args_instance_init (IFaceLogGetDeviceGroupsPermittedByArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personGroupId = 0;
}

static void 
i_face_log_get_device_groups_permitted_by_args_finalize (GObject *object)
{
  IFaceLogGetDeviceGroupsPermittedByArgs *tobject = I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_get_device_groups_permitted_by_args_class_init (IFaceLogGetDeviceGroupsPermittedByArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_device_groups_permitted_by_args_read;
  struct_class->write = i_face_log_get_device_groups_permitted_by_args_write;

  gobject_class->finalize = i_face_log_get_device_groups_permitted_by_args_finalize;
  gobject_class->get_property = i_face_log_get_device_groups_permitted_by_args_get_property;
  gobject_class->set_property = i_face_log_get_device_groups_permitted_by_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_ARGS_PERSON_GROUP_ID,
     g_param_spec_int ("personGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_get_device_groups_permitted_by_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetDeviceGroupsPermittedByArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_device_groups_permitted_by_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetDeviceGroupsPermittedByArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_device_groups_permitted_by_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetDeviceGroupsPermittedByArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetDeviceGroupsPermittedByResultProperties
{
  PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_RESULT_0,
  PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_RESULT_EX1
};

/* reads a i_face_log_get_device_groups_permitted_by_result object */
static gint32
i_face_log_get_device_groups_permitted_by_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetDeviceGroupsPermittedByResult * this_object = I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem36 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem36, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem36, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_device_groups_permitted_by_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetDeviceGroupsPermittedByResult * this_object = I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetDeviceGroupsPermittedByResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i37;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i37 = 0; i37 < (this_object->success ? this_object->success->len : 0); i37++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i37)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_device_groups_permitted_by_result_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  IFaceLogGetDeviceGroupsPermittedByResult *self = I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_device_groups_permitted_by_result_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  IFaceLogGetDeviceGroupsPermittedByResult *self = I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_device_groups_permitted_by_result_instance_init (IFaceLogGetDeviceGroupsPermittedByResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_device_groups_permitted_by_result_finalize (GObject *object)
{
  IFaceLogGetDeviceGroupsPermittedByResult *tobject = I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_device_groups_permitted_by_result_class_init (IFaceLogGetDeviceGroupsPermittedByResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_device_groups_permitted_by_result_read;
  struct_class->write = i_face_log_get_device_groups_permitted_by_result_write;

  gobject_class->finalize = i_face_log_get_device_groups_permitted_by_result_finalize;
  gobject_class->get_property = i_face_log_get_device_groups_permitted_by_result_get_property;
  gobject_class->set_property = i_face_log_get_device_groups_permitted_by_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_device_groups_permitted_by_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetDeviceGroupsPermittedByResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_device_groups_permitted_by_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetDeviceGroupsPermittedByResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_device_groups_permitted_by_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetDeviceGroupsPermittedByResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetDeviceIdOfFeatureArgsProperties
{
  PROP_I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_ARGS_0,
  PROP_I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_ARGS_FEATURE_MD5
};

/* reads a i_face_log_get_device_id_of_feature_args object */
static gint32
i_face_log_get_device_id_of_feature_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetDeviceIdOfFeatureArgs * this_object = I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->featureMd5 != NULL)
          {
            g_free(this_object->featureMd5);
            this_object->featureMd5 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->featureMd5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_featureMd5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_device_id_of_feature_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetDeviceIdOfFeatureArgs * this_object = I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetDeviceIdOfFeatureArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "featureMd5", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->featureMd5, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_device_id_of_feature_args_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  IFaceLogGetDeviceIdOfFeatureArgs *self = I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_ARGS_FEATURE_MD5:
      if (self->featureMd5 != NULL)
        g_free (self->featureMd5);
      self->featureMd5 = g_value_dup_string (value);
      self->__isset_featureMd5 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_device_id_of_feature_args_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  IFaceLogGetDeviceIdOfFeatureArgs *self = I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_ARGS_FEATURE_MD5:
      g_value_set_string (value, self->featureMd5);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_device_id_of_feature_args_instance_init (IFaceLogGetDeviceIdOfFeatureArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->featureMd5 = NULL;
  object->__isset_featureMd5 = FALSE;
}

static void 
i_face_log_get_device_id_of_feature_args_finalize (GObject *object)
{
  IFaceLogGetDeviceIdOfFeatureArgs *tobject = I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->featureMd5 != NULL)
  {
    g_free(tobject->featureMd5);
    tobject->featureMd5 = NULL;
  }
}

static void
i_face_log_get_device_id_of_feature_args_class_init (IFaceLogGetDeviceIdOfFeatureArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_device_id_of_feature_args_read;
  struct_class->write = i_face_log_get_device_id_of_feature_args_write;

  gobject_class->finalize = i_face_log_get_device_id_of_feature_args_finalize;
  gobject_class->get_property = i_face_log_get_device_id_of_feature_args_get_property;
  gobject_class->set_property = i_face_log_get_device_id_of_feature_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_ARGS_FEATURE_MD5,
     g_param_spec_string ("featureMd5",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_get_device_id_of_feature_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetDeviceIdOfFeatureArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_device_id_of_feature_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetDeviceIdOfFeatureArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_device_id_of_feature_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetDeviceIdOfFeatureArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetDeviceIdOfFeatureResultProperties
{
  PROP_I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_RESULT_0,
  PROP_I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_RESULT_EX1
};

/* reads a i_face_log_get_device_id_of_feature_result object */
static gint32
i_face_log_get_device_id_of_feature_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetDeviceIdOfFeatureResult * this_object = I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_device_id_of_feature_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetDeviceIdOfFeatureResult * this_object = I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetDeviceIdOfFeatureResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_device_id_of_feature_result_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  IFaceLogGetDeviceIdOfFeatureResult *self = I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_device_id_of_feature_result_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  IFaceLogGetDeviceIdOfFeatureResult *self = I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_device_id_of_feature_result_instance_init (IFaceLogGetDeviceIdOfFeatureResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_device_id_of_feature_result_finalize (GObject *object)
{
  IFaceLogGetDeviceIdOfFeatureResult *tobject = I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_device_id_of_feature_result_class_init (IFaceLogGetDeviceIdOfFeatureResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_device_id_of_feature_result_read;
  struct_class->write = i_face_log_get_device_id_of_feature_result_write;

  gobject_class->finalize = i_face_log_get_device_id_of_feature_result_finalize;
  gobject_class->get_property = i_face_log_get_device_id_of_feature_result_get_property;
  gobject_class->set_property = i_face_log_get_device_id_of_feature_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_device_id_of_feature_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetDeviceIdOfFeatureResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_device_id_of_feature_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetDeviceIdOfFeatureResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_device_id_of_feature_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetDeviceIdOfFeatureResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetDevicesArgsProperties
{
  PROP_I_FACE_LOG_GET_DEVICES_ARGS_0,
  PROP_I_FACE_LOG_GET_DEVICES_ARGS_ID_LIST
};

/* reads a i_face_log_get_devices_args object */
static gint32
i_face_log_get_devices_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetDevicesArgs * this_object = I_FACE_LOG_GET_DEVICES_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem38 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem38, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->idList, _elem38, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_idList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_devices_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetDevicesArgs * this_object = I_FACE_LOG_GET_DEVICES_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetDevicesArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "idList", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i39;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->idList ? this_object->idList->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i39 = 0; i39 < (this_object->idList ? this_object->idList->len : 0); i39++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->idList, gint32, i39)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_devices_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  IFaceLogGetDevicesArgs *self = I_FACE_LOG_GET_DEVICES_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICES_ARGS_ID_LIST:
      if (self->idList != NULL)
        g_array_unref (self->idList);
      self->idList = g_value_dup_boxed (value);
      self->__isset_idList = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_devices_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  IFaceLogGetDevicesArgs *self = I_FACE_LOG_GET_DEVICES_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICES_ARGS_ID_LIST:
      g_value_set_boxed (value, self->idList);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_devices_args_instance_init (IFaceLogGetDevicesArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->idList = g_array_new (0, 1, sizeof (gint32));
  object->__isset_idList = FALSE;
}

static void 
i_face_log_get_devices_args_finalize (GObject *object)
{
  IFaceLogGetDevicesArgs *tobject = I_FACE_LOG_GET_DEVICES_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->idList != NULL)
  {
    g_array_unref (tobject->idList);
    tobject->idList = NULL;
  }
}

static void
i_face_log_get_devices_args_class_init (IFaceLogGetDevicesArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_devices_args_read;
  struct_class->write = i_face_log_get_devices_args_write;

  gobject_class->finalize = i_face_log_get_devices_args_finalize;
  gobject_class->get_property = i_face_log_get_devices_args_get_property;
  gobject_class->set_property = i_face_log_get_devices_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICES_ARGS_ID_LIST,
     g_param_spec_boxed ("idList",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_devices_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetDevicesArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_devices_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetDevicesArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_devices_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetDevicesArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetDevicesResultProperties
{
  PROP_I_FACE_LOG_GET_DEVICES_RESULT_0,
  PROP_I_FACE_LOG_GET_DEVICES_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_DEVICES_RESULT_EX1
};

/* reads a i_face_log_get_devices_result object */
static gint32
i_face_log_get_devices_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetDevicesResult * this_object = I_FACE_LOG_GET_DEVICES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              DeviceBean * _elem40 = NULL;
              if ( _elem40 != NULL)
              {
                g_object_unref (_elem40);
              }
              _elem40 = g_object_new (TYPE_DEVICE_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem40), protocol, error)) < 0)
              {
                g_object_unref (_elem40);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem40);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_devices_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetDevicesResult * this_object = I_FACE_LOG_GET_DEVICES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetDevicesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i41;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i41 = 0; i41 < (this_object->success ? this_object->success->len : 0); i41++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i41))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_devices_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogGetDevicesResult *self = I_FACE_LOG_GET_DEVICES_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICES_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_DEVICES_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_devices_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogGetDevicesResult *self = I_FACE_LOG_GET_DEVICES_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICES_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_DEVICES_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_devices_result_instance_init (IFaceLogGetDevicesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_devices_result_finalize (GObject *object)
{
  IFaceLogGetDevicesResult *tobject = I_FACE_LOG_GET_DEVICES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_devices_result_class_init (IFaceLogGetDevicesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_devices_result_read;
  struct_class->write = i_face_log_get_devices_result_write;

  gobject_class->finalize = i_face_log_get_devices_result_finalize;
  gobject_class->get_property = i_face_log_get_devices_result_get_property;
  gobject_class->set_property = i_face_log_get_devices_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICES_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICES_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_devices_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetDevicesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_devices_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetDevicesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_devices_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetDevicesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetDevicesOfGroupArgsProperties
{
  PROP_I_FACE_LOG_GET_DEVICES_OF_GROUP_ARGS_0,
  PROP_I_FACE_LOG_GET_DEVICES_OF_GROUP_ARGS_DEVICE_GROUP_ID
};

/* reads a i_face_log_get_devices_of_group_args object */
static gint32
i_face_log_get_devices_of_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetDevicesOfGroupArgs * this_object = I_FACE_LOG_GET_DEVICES_OF_GROUP_ARGS(object);
  gboolean isset_deviceGroupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_deviceGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_deviceGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_devices_of_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetDevicesOfGroupArgs * this_object = I_FACE_LOG_GET_DEVICES_OF_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetDevicesOfGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_devices_of_group_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogGetDevicesOfGroupArgs *self = I_FACE_LOG_GET_DEVICES_OF_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICES_OF_GROUP_ARGS_DEVICE_GROUP_ID:
      self->deviceGroupId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_devices_of_group_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogGetDevicesOfGroupArgs *self = I_FACE_LOG_GET_DEVICES_OF_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICES_OF_GROUP_ARGS_DEVICE_GROUP_ID:
      g_value_set_int (value, self->deviceGroupId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_devices_of_group_args_instance_init (IFaceLogGetDevicesOfGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->deviceGroupId = 0;
}

static void 
i_face_log_get_devices_of_group_args_finalize (GObject *object)
{
  IFaceLogGetDevicesOfGroupArgs *tobject = I_FACE_LOG_GET_DEVICES_OF_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_get_devices_of_group_args_class_init (IFaceLogGetDevicesOfGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_devices_of_group_args_read;
  struct_class->write = i_face_log_get_devices_of_group_args_write;

  gobject_class->finalize = i_face_log_get_devices_of_group_args_finalize;
  gobject_class->get_property = i_face_log_get_devices_of_group_args_get_property;
  gobject_class->set_property = i_face_log_get_devices_of_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICES_OF_GROUP_ARGS_DEVICE_GROUP_ID,
     g_param_spec_int ("deviceGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_get_devices_of_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetDevicesOfGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_devices_of_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetDevicesOfGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_devices_of_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetDevicesOfGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetDevicesOfGroupResultProperties
{
  PROP_I_FACE_LOG_GET_DEVICES_OF_GROUP_RESULT_0,
  PROP_I_FACE_LOG_GET_DEVICES_OF_GROUP_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_DEVICES_OF_GROUP_RESULT_EX1
};

/* reads a i_face_log_get_devices_of_group_result object */
static gint32
i_face_log_get_devices_of_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetDevicesOfGroupResult * this_object = I_FACE_LOG_GET_DEVICES_OF_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem42 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem42, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem42, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_devices_of_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetDevicesOfGroupResult * this_object = I_FACE_LOG_GET_DEVICES_OF_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetDevicesOfGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i43;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i43 = 0; i43 < (this_object->success ? this_object->success->len : 0); i43++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i43)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_devices_of_group_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogGetDevicesOfGroupResult *self = I_FACE_LOG_GET_DEVICES_OF_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICES_OF_GROUP_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_DEVICES_OF_GROUP_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_devices_of_group_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogGetDevicesOfGroupResult *self = I_FACE_LOG_GET_DEVICES_OF_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_DEVICES_OF_GROUP_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_DEVICES_OF_GROUP_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_devices_of_group_result_instance_init (IFaceLogGetDevicesOfGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_devices_of_group_result_finalize (GObject *object)
{
  IFaceLogGetDevicesOfGroupResult *tobject = I_FACE_LOG_GET_DEVICES_OF_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_devices_of_group_result_class_init (IFaceLogGetDevicesOfGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_devices_of_group_result_read;
  struct_class->write = i_face_log_get_devices_of_group_result_write;

  gobject_class->finalize = i_face_log_get_devices_of_group_result_finalize;
  gobject_class->get_property = i_face_log_get_devices_of_group_result_get_property;
  gobject_class->set_property = i_face_log_get_devices_of_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICES_OF_GROUP_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_DEVICES_OF_GROUP_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_devices_of_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetDevicesOfGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_devices_of_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetDevicesOfGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_devices_of_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetDevicesOfGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetFaceArgsProperties
{
  PROP_I_FACE_LOG_GET_FACE_ARGS_0,
  PROP_I_FACE_LOG_GET_FACE_ARGS_FACE_ID
};

/* reads a i_face_log_get_face_args object */
static gint32
i_face_log_get_face_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetFaceArgs * this_object = I_FACE_LOG_GET_FACE_ARGS(object);
  gboolean isset_faceId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->faceId, error)) < 0)
            return -1;
          xfer += ret;
          isset_faceId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_faceId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_face_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetFaceArgs * this_object = I_FACE_LOG_GET_FACE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetFaceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "faceId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->faceId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_face_args_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  IFaceLogGetFaceArgs *self = I_FACE_LOG_GET_FACE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FACE_ARGS_FACE_ID:
      self->faceId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_face_args_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  IFaceLogGetFaceArgs *self = I_FACE_LOG_GET_FACE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FACE_ARGS_FACE_ID:
      g_value_set_int (value, self->faceId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_face_args_instance_init (IFaceLogGetFaceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->faceId = 0;
}

static void 
i_face_log_get_face_args_finalize (GObject *object)
{
  IFaceLogGetFaceArgs *tobject = I_FACE_LOG_GET_FACE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_get_face_args_class_init (IFaceLogGetFaceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_face_args_read;
  struct_class->write = i_face_log_get_face_args_write;

  gobject_class->finalize = i_face_log_get_face_args_finalize;
  gobject_class->get_property = i_face_log_get_face_args_get_property;
  gobject_class->set_property = i_face_log_get_face_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FACE_ARGS_FACE_ID,
     g_param_spec_int ("faceId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_get_face_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetFaceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_face_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetFaceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_face_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetFaceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetFaceResultProperties
{
  PROP_I_FACE_LOG_GET_FACE_RESULT_0,
  PROP_I_FACE_LOG_GET_FACE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_FACE_RESULT_EX1
};

/* reads a i_face_log_get_face_result object */
static gint32
i_face_log_get_face_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetFaceResult * this_object = I_FACE_LOG_GET_FACE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_face_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetFaceResult * this_object = I_FACE_LOG_GET_FACE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetFaceResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_face_result_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  IFaceLogGetFaceResult *self = I_FACE_LOG_GET_FACE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FACE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_FACE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_face_result_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  IFaceLogGetFaceResult *self = I_FACE_LOG_GET_FACE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FACE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_FACE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_face_result_instance_init (IFaceLogGetFaceResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_FACE_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_face_result_finalize (GObject *object)
{
  IFaceLogGetFaceResult *tobject = I_FACE_LOG_GET_FACE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_face_result_class_init (IFaceLogGetFaceResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_face_result_read;
  struct_class->write = i_face_log_get_face_result_write;

  gobject_class->finalize = i_face_log_get_face_result_finalize;
  gobject_class->get_property = i_face_log_get_face_result_get_property;
  gobject_class->set_property = i_face_log_get_face_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FACE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_FACE_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FACE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_face_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetFaceResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_face_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetFaceResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_face_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetFaceResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetFeatureArgsProperties
{
  PROP_I_FACE_LOG_GET_FEATURE_ARGS_0,
  PROP_I_FACE_LOG_GET_FEATURE_ARGS_MD5
};

/* reads a i_face_log_get_feature_args object */
static gint32
i_face_log_get_feature_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetFeatureArgs * this_object = I_FACE_LOG_GET_FEATURE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->md5 != NULL)
          {
            g_free(this_object->md5);
            this_object->md5 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->md5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_md5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_feature_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetFeatureArgs * this_object = I_FACE_LOG_GET_FEATURE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetFeatureArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "md5", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->md5, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_feature_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  IFaceLogGetFeatureArgs *self = I_FACE_LOG_GET_FEATURE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURE_ARGS_MD5:
      if (self->md5 != NULL)
        g_free (self->md5);
      self->md5 = g_value_dup_string (value);
      self->__isset_md5 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_feature_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  IFaceLogGetFeatureArgs *self = I_FACE_LOG_GET_FEATURE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURE_ARGS_MD5:
      g_value_set_string (value, self->md5);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_feature_args_instance_init (IFaceLogGetFeatureArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->md5 = NULL;
  object->__isset_md5 = FALSE;
}

static void 
i_face_log_get_feature_args_finalize (GObject *object)
{
  IFaceLogGetFeatureArgs *tobject = I_FACE_LOG_GET_FEATURE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->md5 != NULL)
  {
    g_free(tobject->md5);
    tobject->md5 = NULL;
  }
}

static void
i_face_log_get_feature_args_class_init (IFaceLogGetFeatureArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_feature_args_read;
  struct_class->write = i_face_log_get_feature_args_write;

  gobject_class->finalize = i_face_log_get_feature_args_finalize;
  gobject_class->get_property = i_face_log_get_feature_args_get_property;
  gobject_class->set_property = i_face_log_get_feature_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FEATURE_ARGS_MD5,
     g_param_spec_string ("md5",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_get_feature_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetFeatureArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_feature_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetFeatureArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_feature_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetFeatureArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetFeatureResultProperties
{
  PROP_I_FACE_LOG_GET_FEATURE_RESULT_0,
  PROP_I_FACE_LOG_GET_FEATURE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_FEATURE_RESULT_EX1
};

/* reads a i_face_log_get_feature_result object */
static gint32
i_face_log_get_feature_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetFeatureResult * this_object = I_FACE_LOG_GET_FEATURE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_feature_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetFeatureResult * this_object = I_FACE_LOG_GET_FEATURE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetFeatureResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_feature_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogGetFeatureResult *self = I_FACE_LOG_GET_FEATURE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_FEATURE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_feature_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogGetFeatureResult *self = I_FACE_LOG_GET_FEATURE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_FEATURE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_feature_result_instance_init (IFaceLogGetFeatureResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_FEATURE_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_feature_result_finalize (GObject *object)
{
  IFaceLogGetFeatureResult *tobject = I_FACE_LOG_GET_FEATURE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_feature_result_class_init (IFaceLogGetFeatureResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_feature_result_read;
  struct_class->write = i_face_log_get_feature_result_write;

  gobject_class->finalize = i_face_log_get_feature_result_finalize;
  gobject_class->get_property = i_face_log_get_feature_result_get_property;
  gobject_class->set_property = i_face_log_get_feature_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FEATURE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_FEATURE_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FEATURE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_feature_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetFeatureResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_feature_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetFeatureResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_feature_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetFeatureResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetFeatureBytesArgsProperties
{
  PROP_I_FACE_LOG_GET_FEATURE_BYTES_ARGS_0,
  PROP_I_FACE_LOG_GET_FEATURE_BYTES_ARGS_MD5
};

/* reads a i_face_log_get_feature_bytes_args object */
static gint32
i_face_log_get_feature_bytes_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetFeatureBytesArgs * this_object = I_FACE_LOG_GET_FEATURE_BYTES_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->md5 != NULL)
          {
            g_free(this_object->md5);
            this_object->md5 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->md5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_md5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_feature_bytes_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetFeatureBytesArgs * this_object = I_FACE_LOG_GET_FEATURE_BYTES_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetFeatureBytesArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "md5", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->md5, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_feature_bytes_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogGetFeatureBytesArgs *self = I_FACE_LOG_GET_FEATURE_BYTES_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURE_BYTES_ARGS_MD5:
      if (self->md5 != NULL)
        g_free (self->md5);
      self->md5 = g_value_dup_string (value);
      self->__isset_md5 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_feature_bytes_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogGetFeatureBytesArgs *self = I_FACE_LOG_GET_FEATURE_BYTES_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURE_BYTES_ARGS_MD5:
      g_value_set_string (value, self->md5);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_feature_bytes_args_instance_init (IFaceLogGetFeatureBytesArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->md5 = NULL;
  object->__isset_md5 = FALSE;
}

static void 
i_face_log_get_feature_bytes_args_finalize (GObject *object)
{
  IFaceLogGetFeatureBytesArgs *tobject = I_FACE_LOG_GET_FEATURE_BYTES_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->md5 != NULL)
  {
    g_free(tobject->md5);
    tobject->md5 = NULL;
  }
}

static void
i_face_log_get_feature_bytes_args_class_init (IFaceLogGetFeatureBytesArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_feature_bytes_args_read;
  struct_class->write = i_face_log_get_feature_bytes_args_write;

  gobject_class->finalize = i_face_log_get_feature_bytes_args_finalize;
  gobject_class->get_property = i_face_log_get_feature_bytes_args_get_property;
  gobject_class->set_property = i_face_log_get_feature_bytes_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FEATURE_BYTES_ARGS_MD5,
     g_param_spec_string ("md5",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_get_feature_bytes_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetFeatureBytesArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_feature_bytes_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetFeatureBytesArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_feature_bytes_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetFeatureBytesArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetFeatureBytesResultProperties
{
  PROP_I_FACE_LOG_GET_FEATURE_BYTES_RESULT_0,
  PROP_I_FACE_LOG_GET_FEATURE_BYTES_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_FEATURE_BYTES_RESULT_EX1
};

/* reads a i_face_log_get_feature_bytes_result object */
static gint32
i_face_log_get_feature_bytes_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetFeatureBytesResult * this_object = I_FACE_LOG_GET_FEATURE_BYTES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->success = g_byte_array_new();
          g_byte_array_append (this_object->success, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_feature_bytes_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetFeatureBytesResult * this_object = I_FACE_LOG_GET_FEATURE_BYTES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetFeatureBytesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->success ? ((GByteArray *) this_object->success)->data : NULL, this_object->success ? ((GByteArray *) this_object->success)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_feature_bytes_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogGetFeatureBytesResult *self = I_FACE_LOG_GET_FEATURE_BYTES_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURE_BYTES_RESULT_SUCCESS:
      if (self->success != NULL)
        g_byte_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_FEATURE_BYTES_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_feature_bytes_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogGetFeatureBytesResult *self = I_FACE_LOG_GET_FEATURE_BYTES_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURE_BYTES_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_FEATURE_BYTES_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_feature_bytes_result_instance_init (IFaceLogGetFeatureBytesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_feature_bytes_result_finalize (GObject *object)
{
  IFaceLogGetFeatureBytesResult *tobject = I_FACE_LOG_GET_FEATURE_BYTES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    thrift_string_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_feature_bytes_result_class_init (IFaceLogGetFeatureBytesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_feature_bytes_result_read;
  struct_class->write = i_face_log_get_feature_bytes_result_write;

  gobject_class->finalize = i_face_log_get_feature_bytes_result_finalize;
  gobject_class->get_property = i_face_log_get_feature_bytes_result_get_property;
  gobject_class->set_property = i_face_log_get_feature_bytes_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FEATURE_BYTES_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FEATURE_BYTES_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_feature_bytes_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetFeatureBytesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_feature_bytes_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetFeatureBytesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_feature_bytes_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetFeatureBytesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetFeaturesArgsProperties
{
  PROP_I_FACE_LOG_GET_FEATURES_ARGS_0,
  PROP_I_FACE_LOG_GET_FEATURES_ARGS_MD5
};

/* reads a i_face_log_get_features_args object */
static gint32
i_face_log_get_features_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetFeaturesArgs * this_object = I_FACE_LOG_GET_FEATURES_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem44 = NULL;
              if (_elem44 != NULL)
              {
                g_free(_elem44);
                _elem44 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem44, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->md5, _elem44);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_md5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_features_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetFeaturesArgs * this_object = I_FACE_LOG_GET_FEATURES_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetFeaturesArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "md5", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i45;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->md5 ? this_object->md5->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i45 = 0; i45 < (this_object->md5 ? this_object->md5->len : 0); i45++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->md5, i45)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_features_args_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogGetFeaturesArgs *self = I_FACE_LOG_GET_FEATURES_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURES_ARGS_MD5:
      if (self->md5 != NULL)
        g_ptr_array_unref (self->md5);
      self->md5 = g_value_dup_boxed (value);
      self->__isset_md5 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_features_args_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogGetFeaturesArgs *self = I_FACE_LOG_GET_FEATURES_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURES_ARGS_MD5:
      g_value_set_boxed (value, self->md5);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_features_args_instance_init (IFaceLogGetFeaturesArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->md5 = g_ptr_array_new_with_free_func (g_free);
  object->__isset_md5 = FALSE;
}

static void 
i_face_log_get_features_args_finalize (GObject *object)
{
  IFaceLogGetFeaturesArgs *tobject = I_FACE_LOG_GET_FEATURES_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->md5 != NULL)
  {
    g_ptr_array_unref (tobject->md5);
    tobject->md5 = NULL;
  }
}

static void
i_face_log_get_features_args_class_init (IFaceLogGetFeaturesArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_features_args_read;
  struct_class->write = i_face_log_get_features_args_write;

  gobject_class->finalize = i_face_log_get_features_args_finalize;
  gobject_class->get_property = i_face_log_get_features_args_get_property;
  gobject_class->set_property = i_face_log_get_features_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FEATURES_ARGS_MD5,
     g_param_spec_boxed ("md5",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_features_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetFeaturesArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_features_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetFeaturesArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_features_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetFeaturesArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetFeaturesResultProperties
{
  PROP_I_FACE_LOG_GET_FEATURES_RESULT_0,
  PROP_I_FACE_LOG_GET_FEATURES_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_FEATURES_RESULT_EX1
};

/* reads a i_face_log_get_features_result object */
static gint32
i_face_log_get_features_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetFeaturesResult * this_object = I_FACE_LOG_GET_FEATURES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              FeatureBean * _elem46 = NULL;
              if ( _elem46 != NULL)
              {
                g_object_unref (_elem46);
              }
              _elem46 = g_object_new (TYPE_FEATURE_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem46), protocol, error)) < 0)
              {
                g_object_unref (_elem46);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem46);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_features_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetFeaturesResult * this_object = I_FACE_LOG_GET_FEATURES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetFeaturesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i47;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i47 = 0; i47 < (this_object->success ? this_object->success->len : 0); i47++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i47))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_features_result_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogGetFeaturesResult *self = I_FACE_LOG_GET_FEATURES_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURES_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_FEATURES_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_features_result_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogGetFeaturesResult *self = I_FACE_LOG_GET_FEATURES_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURES_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_FEATURES_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_features_result_instance_init (IFaceLogGetFeaturesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_features_result_finalize (GObject *object)
{
  IFaceLogGetFeaturesResult *tobject = I_FACE_LOG_GET_FEATURES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_features_result_class_init (IFaceLogGetFeaturesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_features_result_read;
  struct_class->write = i_face_log_get_features_result_write;

  gobject_class->finalize = i_face_log_get_features_result_finalize;
  gobject_class->get_property = i_face_log_get_features_result_get_property;
  gobject_class->set_property = i_face_log_get_features_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FEATURES_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FEATURES_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_features_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetFeaturesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_features_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetFeaturesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_features_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetFeaturesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetFeaturesByPersonIdArgsProperties
{
  PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_ARGS_0,
  PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_ARGS_PERSON_ID
};

/* reads a i_face_log_get_features_by_person_id_args object */
static gint32
i_face_log_get_features_by_person_id_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetFeaturesByPersonIdArgs * this_object = I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_ARGS(object);
  gboolean isset_personId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_features_by_person_id_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetFeaturesByPersonIdArgs * this_object = I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetFeaturesByPersonIdArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_features_by_person_id_args_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  IFaceLogGetFeaturesByPersonIdArgs *self = I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_ARGS_PERSON_ID:
      self->personId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_features_by_person_id_args_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  IFaceLogGetFeaturesByPersonIdArgs *self = I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_ARGS_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_features_by_person_id_args_instance_init (IFaceLogGetFeaturesByPersonIdArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personId = 0;
}

static void 
i_face_log_get_features_by_person_id_args_finalize (GObject *object)
{
  IFaceLogGetFeaturesByPersonIdArgs *tobject = I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_get_features_by_person_id_args_class_init (IFaceLogGetFeaturesByPersonIdArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_features_by_person_id_args_read;
  struct_class->write = i_face_log_get_features_by_person_id_args_write;

  gobject_class->finalize = i_face_log_get_features_by_person_id_args_finalize;
  gobject_class->get_property = i_face_log_get_features_by_person_id_args_get_property;
  gobject_class->set_property = i_face_log_get_features_by_person_id_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_ARGS_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_get_features_by_person_id_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetFeaturesByPersonIdArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_features_by_person_id_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetFeaturesByPersonIdArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_features_by_person_id_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetFeaturesByPersonIdArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetFeaturesByPersonIdResultProperties
{
  PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_RESULT_0,
  PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_RESULT_EX1
};

/* reads a i_face_log_get_features_by_person_id_result object */
static gint32
i_face_log_get_features_by_person_id_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetFeaturesByPersonIdResult * this_object = I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem48 = NULL;
              if (_elem48 != NULL)
              {
                g_free(_elem48);
                _elem48 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem48, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem48);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_features_by_person_id_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetFeaturesByPersonIdResult * this_object = I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetFeaturesByPersonIdResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i49;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i49 = 0; i49 < (this_object->success ? this_object->success->len : 0); i49++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->success, i49)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_features_by_person_id_result_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  IFaceLogGetFeaturesByPersonIdResult *self = I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_features_by_person_id_result_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  IFaceLogGetFeaturesByPersonIdResult *self = I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_features_by_person_id_result_instance_init (IFaceLogGetFeaturesByPersonIdResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_free);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_features_by_person_id_result_finalize (GObject *object)
{
  IFaceLogGetFeaturesByPersonIdResult *tobject = I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_features_by_person_id_result_class_init (IFaceLogGetFeaturesByPersonIdResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_features_by_person_id_result_read;
  struct_class->write = i_face_log_get_features_by_person_id_result_write;

  gobject_class->finalize = i_face_log_get_features_by_person_id_result_finalize;
  gobject_class->get_property = i_face_log_get_features_by_person_id_result_get_property;
  gobject_class->set_property = i_face_log_get_features_by_person_id_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_features_by_person_id_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetFeaturesByPersonIdResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_features_by_person_id_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetFeaturesByPersonIdResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_features_by_person_id_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetFeaturesByPersonIdResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetFeaturesByPersonIdAndSdkVersionArgsProperties
{
  PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_ARGS_0,
  PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_ARGS_PERSON_ID,
  PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_ARGS_SDK_VERSION
};

/* reads a i_face_log_get_features_by_person_id_and_sdk_version_args object */
static gint32
i_face_log_get_features_by_person_id_and_sdk_version_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetFeaturesByPersonIdAndSdkVersionArgs * this_object = I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_ARGS(object);
  gboolean isset_personId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->sdkVersion != NULL)
          {
            g_free(this_object->sdkVersion);
            this_object->sdkVersion = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sdkVersion, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sdkVersion = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_features_by_person_id_and_sdk_version_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetFeaturesByPersonIdAndSdkVersionArgs * this_object = I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetFeaturesByPersonIdAndSdkVersionArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sdkVersion", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sdkVersion, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_features_by_person_id_and_sdk_version_args_set_property (GObject *object,
                                                                        guint property_id,
                                                                        const GValue *value,
                                                                        GParamSpec *pspec)
{
  IFaceLogGetFeaturesByPersonIdAndSdkVersionArgs *self = I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_ARGS_PERSON_ID:
      self->personId = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_ARGS_SDK_VERSION:
      if (self->sdkVersion != NULL)
        g_free (self->sdkVersion);
      self->sdkVersion = g_value_dup_string (value);
      self->__isset_sdkVersion = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_features_by_person_id_and_sdk_version_args_get_property (GObject *object,
                                                                        guint property_id,
                                                                        GValue *value,
                                                                        GParamSpec *pspec)
{
  IFaceLogGetFeaturesByPersonIdAndSdkVersionArgs *self = I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_ARGS_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    case PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_ARGS_SDK_VERSION:
      g_value_set_string (value, self->sdkVersion);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_features_by_person_id_and_sdk_version_args_instance_init (IFaceLogGetFeaturesByPersonIdAndSdkVersionArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personId = 0;
  object->sdkVersion = NULL;
  object->__isset_sdkVersion = FALSE;
}

static void 
i_face_log_get_features_by_person_id_and_sdk_version_args_finalize (GObject *object)
{
  IFaceLogGetFeaturesByPersonIdAndSdkVersionArgs *tobject = I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sdkVersion != NULL)
  {
    g_free(tobject->sdkVersion);
    tobject->sdkVersion = NULL;
  }
}

static void
i_face_log_get_features_by_person_id_and_sdk_version_args_class_init (IFaceLogGetFeaturesByPersonIdAndSdkVersionArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_features_by_person_id_and_sdk_version_args_read;
  struct_class->write = i_face_log_get_features_by_person_id_and_sdk_version_args_write;

  gobject_class->finalize = i_face_log_get_features_by_person_id_and_sdk_version_args_finalize;
  gobject_class->get_property = i_face_log_get_features_by_person_id_and_sdk_version_args_get_property;
  gobject_class->set_property = i_face_log_get_features_by_person_id_and_sdk_version_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_ARGS_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_ARGS_SDK_VERSION,
     g_param_spec_string ("sdkVersion",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_get_features_by_person_id_and_sdk_version_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetFeaturesByPersonIdAndSdkVersionArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_features_by_person_id_and_sdk_version_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetFeaturesByPersonIdAndSdkVersionArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_features_by_person_id_and_sdk_version_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetFeaturesByPersonIdAndSdkVersionArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetFeaturesByPersonIdAndSdkVersionResultProperties
{
  PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_RESULT_0,
  PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_RESULT_EX1
};

/* reads a i_face_log_get_features_by_person_id_and_sdk_version_result object */
static gint32
i_face_log_get_features_by_person_id_and_sdk_version_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetFeaturesByPersonIdAndSdkVersionResult * this_object = I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem50 = NULL;
              if (_elem50 != NULL)
              {
                g_free(_elem50);
                _elem50 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem50, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem50);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_features_by_person_id_and_sdk_version_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetFeaturesByPersonIdAndSdkVersionResult * this_object = I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetFeaturesByPersonIdAndSdkVersionResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i51;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i51 = 0; i51 < (this_object->success ? this_object->success->len : 0); i51++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->success, i51)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_features_by_person_id_and_sdk_version_result_set_property (GObject *object,
                                                                          guint property_id,
                                                                          const GValue *value,
                                                                          GParamSpec *pspec)
{
  IFaceLogGetFeaturesByPersonIdAndSdkVersionResult *self = I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_features_by_person_id_and_sdk_version_result_get_property (GObject *object,
                                                                          guint property_id,
                                                                          GValue *value,
                                                                          GParamSpec *pspec)
{
  IFaceLogGetFeaturesByPersonIdAndSdkVersionResult *self = I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_features_by_person_id_and_sdk_version_result_instance_init (IFaceLogGetFeaturesByPersonIdAndSdkVersionResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_free);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_features_by_person_id_and_sdk_version_result_finalize (GObject *object)
{
  IFaceLogGetFeaturesByPersonIdAndSdkVersionResult *tobject = I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_features_by_person_id_and_sdk_version_result_class_init (IFaceLogGetFeaturesByPersonIdAndSdkVersionResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_features_by_person_id_and_sdk_version_result_read;
  struct_class->write = i_face_log_get_features_by_person_id_and_sdk_version_result_write;

  gobject_class->finalize = i_face_log_get_features_by_person_id_and_sdk_version_result_finalize;
  gobject_class->get_property = i_face_log_get_features_by_person_id_and_sdk_version_result_get_property;
  gobject_class->set_property = i_face_log_get_features_by_person_id_and_sdk_version_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_features_by_person_id_and_sdk_version_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetFeaturesByPersonIdAndSdkVersionResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_features_by_person_id_and_sdk_version_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetFeaturesByPersonIdAndSdkVersionResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_features_by_person_id_and_sdk_version_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetFeaturesByPersonIdAndSdkVersionResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetFeaturesOfPersonArgsProperties
{
  PROP_I_FACE_LOG_GET_FEATURES_OF_PERSON_ARGS_0,
  PROP_I_FACE_LOG_GET_FEATURES_OF_PERSON_ARGS_PERSON_ID
};

/* reads a i_face_log_get_features_of_person_args object */
static gint32
i_face_log_get_features_of_person_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetFeaturesOfPersonArgs * this_object = I_FACE_LOG_GET_FEATURES_OF_PERSON_ARGS(object);
  gboolean isset_personId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_features_of_person_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetFeaturesOfPersonArgs * this_object = I_FACE_LOG_GET_FEATURES_OF_PERSON_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetFeaturesOfPersonArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_features_of_person_args_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogGetFeaturesOfPersonArgs *self = I_FACE_LOG_GET_FEATURES_OF_PERSON_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURES_OF_PERSON_ARGS_PERSON_ID:
      self->personId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_features_of_person_args_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogGetFeaturesOfPersonArgs *self = I_FACE_LOG_GET_FEATURES_OF_PERSON_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURES_OF_PERSON_ARGS_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_features_of_person_args_instance_init (IFaceLogGetFeaturesOfPersonArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personId = 0;
}

static void 
i_face_log_get_features_of_person_args_finalize (GObject *object)
{
  IFaceLogGetFeaturesOfPersonArgs *tobject = I_FACE_LOG_GET_FEATURES_OF_PERSON_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_get_features_of_person_args_class_init (IFaceLogGetFeaturesOfPersonArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_features_of_person_args_read;
  struct_class->write = i_face_log_get_features_of_person_args_write;

  gobject_class->finalize = i_face_log_get_features_of_person_args_finalize;
  gobject_class->get_property = i_face_log_get_features_of_person_args_get_property;
  gobject_class->set_property = i_face_log_get_features_of_person_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FEATURES_OF_PERSON_ARGS_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_get_features_of_person_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetFeaturesOfPersonArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_features_of_person_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetFeaturesOfPersonArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_features_of_person_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetFeaturesOfPersonArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetFeaturesOfPersonResultProperties
{
  PROP_I_FACE_LOG_GET_FEATURES_OF_PERSON_RESULT_0,
  PROP_I_FACE_LOG_GET_FEATURES_OF_PERSON_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_FEATURES_OF_PERSON_RESULT_EX1
};

/* reads a i_face_log_get_features_of_person_result object */
static gint32
i_face_log_get_features_of_person_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetFeaturesOfPersonResult * this_object = I_FACE_LOG_GET_FEATURES_OF_PERSON_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem52 = NULL;
              if (_elem52 != NULL)
              {
                g_free(_elem52);
                _elem52 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem52, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem52);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_features_of_person_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetFeaturesOfPersonResult * this_object = I_FACE_LOG_GET_FEATURES_OF_PERSON_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetFeaturesOfPersonResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i53;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i53 = 0; i53 < (this_object->success ? this_object->success->len : 0); i53++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->success, i53)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_features_of_person_result_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  IFaceLogGetFeaturesOfPersonResult *self = I_FACE_LOG_GET_FEATURES_OF_PERSON_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURES_OF_PERSON_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_FEATURES_OF_PERSON_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_features_of_person_result_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  IFaceLogGetFeaturesOfPersonResult *self = I_FACE_LOG_GET_FEATURES_OF_PERSON_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_FEATURES_OF_PERSON_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_FEATURES_OF_PERSON_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_features_of_person_result_instance_init (IFaceLogGetFeaturesOfPersonResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_free);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_features_of_person_result_finalize (GObject *object)
{
  IFaceLogGetFeaturesOfPersonResult *tobject = I_FACE_LOG_GET_FEATURES_OF_PERSON_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_features_of_person_result_class_init (IFaceLogGetFeaturesOfPersonResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_features_of_person_result_read;
  struct_class->write = i_face_log_get_features_of_person_result_write;

  gobject_class->finalize = i_face_log_get_features_of_person_result_finalize;
  gobject_class->get_property = i_face_log_get_features_of_person_result_get_property;
  gobject_class->set_property = i_face_log_get_features_of_person_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FEATURES_OF_PERSON_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_FEATURES_OF_PERSON_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_features_of_person_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetFeaturesOfPersonResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_features_of_person_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetFeaturesOfPersonResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_features_of_person_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetFeaturesOfPersonResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetGroupPermitArgsProperties
{
  PROP_I_FACE_LOG_GET_GROUP_PERMIT_ARGS_0,
  PROP_I_FACE_LOG_GET_GROUP_PERMIT_ARGS_DEVICE_ID,
  PROP_I_FACE_LOG_GET_GROUP_PERMIT_ARGS_PERSON_GROUP_ID
};

/* reads a i_face_log_get_group_permit_args object */
static gint32
i_face_log_get_group_permit_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetGroupPermitArgs * this_object = I_FACE_LOG_GET_GROUP_PERMIT_ARGS(object);
  gboolean isset_deviceId = FALSE;
  gboolean isset_personGroupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceId, error)) < 0)
            return -1;
          xfer += ret;
          isset_deviceId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_deviceId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_personGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_group_permit_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetGroupPermitArgs * this_object = I_FACE_LOG_GET_GROUP_PERMIT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetGroupPermitArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_group_permit_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogGetGroupPermitArgs *self = I_FACE_LOG_GET_GROUP_PERMIT_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_GROUP_PERMIT_ARGS_DEVICE_ID:
      self->deviceId = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_GET_GROUP_PERMIT_ARGS_PERSON_GROUP_ID:
      self->personGroupId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_group_permit_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogGetGroupPermitArgs *self = I_FACE_LOG_GET_GROUP_PERMIT_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_GROUP_PERMIT_ARGS_DEVICE_ID:
      g_value_set_int (value, self->deviceId);
      break;

    case PROP_I_FACE_LOG_GET_GROUP_PERMIT_ARGS_PERSON_GROUP_ID:
      g_value_set_int (value, self->personGroupId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_group_permit_args_instance_init (IFaceLogGetGroupPermitArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->deviceId = 0;
  object->personGroupId = 0;
}

static void 
i_face_log_get_group_permit_args_finalize (GObject *object)
{
  IFaceLogGetGroupPermitArgs *tobject = I_FACE_LOG_GET_GROUP_PERMIT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_get_group_permit_args_class_init (IFaceLogGetGroupPermitArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_group_permit_args_read;
  struct_class->write = i_face_log_get_group_permit_args_write;

  gobject_class->finalize = i_face_log_get_group_permit_args_finalize;
  gobject_class->get_property = i_face_log_get_group_permit_args_get_property;
  gobject_class->set_property = i_face_log_get_group_permit_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_GROUP_PERMIT_ARGS_DEVICE_ID,
     g_param_spec_int ("deviceId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_GROUP_PERMIT_ARGS_PERSON_GROUP_ID,
     g_param_spec_int ("personGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_get_group_permit_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetGroupPermitArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_group_permit_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetGroupPermitArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_group_permit_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetGroupPermitArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetGroupPermitResultProperties
{
  PROP_I_FACE_LOG_GET_GROUP_PERMIT_RESULT_0,
  PROP_I_FACE_LOG_GET_GROUP_PERMIT_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_GROUP_PERMIT_RESULT_EX1
};

/* reads a i_face_log_get_group_permit_result object */
static gint32
i_face_log_get_group_permit_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetGroupPermitResult * this_object = I_FACE_LOG_GET_GROUP_PERMIT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_group_permit_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetGroupPermitResult * this_object = I_FACE_LOG_GET_GROUP_PERMIT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetGroupPermitResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_group_permit_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogGetGroupPermitResult *self = I_FACE_LOG_GET_GROUP_PERMIT_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_GROUP_PERMIT_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_GROUP_PERMIT_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_group_permit_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogGetGroupPermitResult *self = I_FACE_LOG_GET_GROUP_PERMIT_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_GROUP_PERMIT_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_GROUP_PERMIT_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_group_permit_result_instance_init (IFaceLogGetGroupPermitResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_PERMIT_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_group_permit_result_finalize (GObject *object)
{
  IFaceLogGetGroupPermitResult *tobject = I_FACE_LOG_GET_GROUP_PERMIT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_group_permit_result_class_init (IFaceLogGetGroupPermitResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_group_permit_result_read;
  struct_class->write = i_face_log_get_group_permit_result_write;

  gobject_class->finalize = i_face_log_get_group_permit_result_finalize;
  gobject_class->get_property = i_face_log_get_group_permit_result_get_property;
  gobject_class->set_property = i_face_log_get_group_permit_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_GROUP_PERMIT_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_PERMIT_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_GROUP_PERMIT_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_group_permit_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetGroupPermitResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_group_permit_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetGroupPermitResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_group_permit_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetGroupPermitResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetGroupPermitOnDeviceGroupArgsProperties
{
  PROP_I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS_0,
  PROP_I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID,
  PROP_I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS_PERSON_GROUP_ID
};

/* reads a i_face_log_get_group_permit_on_device_group_args object */
static gint32
i_face_log_get_group_permit_on_device_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetGroupPermitOnDeviceGroupArgs * this_object = I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS(object);
  gboolean isset_deviceGroupId = FALSE;
  gboolean isset_personGroupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_deviceGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_deviceGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_personGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_group_permit_on_device_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetGroupPermitOnDeviceGroupArgs * this_object = I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetGroupPermitOnDeviceGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_group_permit_on_device_group_args_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  IFaceLogGetGroupPermitOnDeviceGroupArgs *self = I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID:
      self->deviceGroupId = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS_PERSON_GROUP_ID:
      self->personGroupId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_group_permit_on_device_group_args_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  IFaceLogGetGroupPermitOnDeviceGroupArgs *self = I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID:
      g_value_set_int (value, self->deviceGroupId);
      break;

    case PROP_I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS_PERSON_GROUP_ID:
      g_value_set_int (value, self->personGroupId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_group_permit_on_device_group_args_instance_init (IFaceLogGetGroupPermitOnDeviceGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->deviceGroupId = 0;
  object->personGroupId = 0;
}

static void 
i_face_log_get_group_permit_on_device_group_args_finalize (GObject *object)
{
  IFaceLogGetGroupPermitOnDeviceGroupArgs *tobject = I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_get_group_permit_on_device_group_args_class_init (IFaceLogGetGroupPermitOnDeviceGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_group_permit_on_device_group_args_read;
  struct_class->write = i_face_log_get_group_permit_on_device_group_args_write;

  gobject_class->finalize = i_face_log_get_group_permit_on_device_group_args_finalize;
  gobject_class->get_property = i_face_log_get_group_permit_on_device_group_args_get_property;
  gobject_class->set_property = i_face_log_get_group_permit_on_device_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID,
     g_param_spec_int ("deviceGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS_PERSON_GROUP_ID,
     g_param_spec_int ("personGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_get_group_permit_on_device_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetGroupPermitOnDeviceGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_group_permit_on_device_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetGroupPermitOnDeviceGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_group_permit_on_device_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetGroupPermitOnDeviceGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetGroupPermitOnDeviceGroupResultProperties
{
  PROP_I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT_0,
  PROP_I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT_EX1
};

/* reads a i_face_log_get_group_permit_on_device_group_result object */
static gint32
i_face_log_get_group_permit_on_device_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetGroupPermitOnDeviceGroupResult * this_object = I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_group_permit_on_device_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetGroupPermitOnDeviceGroupResult * this_object = I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetGroupPermitOnDeviceGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_group_permit_on_device_group_result_set_property (GObject *object,
                                                                 guint property_id,
                                                                 const GValue *value,
                                                                 GParamSpec *pspec)
{
  IFaceLogGetGroupPermitOnDeviceGroupResult *self = I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_group_permit_on_device_group_result_get_property (GObject *object,
                                                                 guint property_id,
                                                                 GValue *value,
                                                                 GParamSpec *pspec)
{
  IFaceLogGetGroupPermitOnDeviceGroupResult *self = I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_group_permit_on_device_group_result_instance_init (IFaceLogGetGroupPermitOnDeviceGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_PERMIT_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_group_permit_on_device_group_result_finalize (GObject *object)
{
  IFaceLogGetGroupPermitOnDeviceGroupResult *tobject = I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_group_permit_on_device_group_result_class_init (IFaceLogGetGroupPermitOnDeviceGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_group_permit_on_device_group_result_read;
  struct_class->write = i_face_log_get_group_permit_on_device_group_result_write;

  gobject_class->finalize = i_face_log_get_group_permit_on_device_group_result_finalize;
  gobject_class->get_property = i_face_log_get_group_permit_on_device_group_result_get_property;
  gobject_class->set_property = i_face_log_get_group_permit_on_device_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_PERMIT_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_group_permit_on_device_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetGroupPermitOnDeviceGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_group_permit_on_device_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetGroupPermitOnDeviceGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_group_permit_on_device_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetGroupPermitOnDeviceGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetGroupPermitsArgsProperties
{
  PROP_I_FACE_LOG_GET_GROUP_PERMITS_ARGS_0,
  PROP_I_FACE_LOG_GET_GROUP_PERMITS_ARGS_DEVICE_ID,
  PROP_I_FACE_LOG_GET_GROUP_PERMITS_ARGS_PERSON_GROUP_ID_LIST
};

/* reads a i_face_log_get_group_permits_args object */
static gint32
i_face_log_get_group_permits_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetGroupPermitsArgs * this_object = I_FACE_LOG_GET_GROUP_PERMITS_ARGS(object);
  gboolean isset_deviceId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceId, error)) < 0)
            return -1;
          xfer += ret;
          isset_deviceId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem54 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem54, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->personGroupIdList, _elem54, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_personGroupIdList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_deviceId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_group_permits_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetGroupPermitsArgs * this_object = I_FACE_LOG_GET_GROUP_PERMITS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetGroupPermitsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupIdList", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i55;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->personGroupIdList ? this_object->personGroupIdList->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i55 = 0; i55 < (this_object->personGroupIdList ? this_object->personGroupIdList->len : 0); i55++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->personGroupIdList, gint32, i55)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_group_permits_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogGetGroupPermitsArgs *self = I_FACE_LOG_GET_GROUP_PERMITS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_GROUP_PERMITS_ARGS_DEVICE_ID:
      self->deviceId = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_GET_GROUP_PERMITS_ARGS_PERSON_GROUP_ID_LIST:
      if (self->personGroupIdList != NULL)
        g_array_unref (self->personGroupIdList);
      self->personGroupIdList = g_value_dup_boxed (value);
      self->__isset_personGroupIdList = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_group_permits_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogGetGroupPermitsArgs *self = I_FACE_LOG_GET_GROUP_PERMITS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_GROUP_PERMITS_ARGS_DEVICE_ID:
      g_value_set_int (value, self->deviceId);
      break;

    case PROP_I_FACE_LOG_GET_GROUP_PERMITS_ARGS_PERSON_GROUP_ID_LIST:
      g_value_set_boxed (value, self->personGroupIdList);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_group_permits_args_instance_init (IFaceLogGetGroupPermitsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->deviceId = 0;
  object->personGroupIdList = g_array_new (0, 1, sizeof (gint32));
  object->__isset_personGroupIdList = FALSE;
}

static void 
i_face_log_get_group_permits_args_finalize (GObject *object)
{
  IFaceLogGetGroupPermitsArgs *tobject = I_FACE_LOG_GET_GROUP_PERMITS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->personGroupIdList != NULL)
  {
    g_array_unref (tobject->personGroupIdList);
    tobject->personGroupIdList = NULL;
  }
}

static void
i_face_log_get_group_permits_args_class_init (IFaceLogGetGroupPermitsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_group_permits_args_read;
  struct_class->write = i_face_log_get_group_permits_args_write;

  gobject_class->finalize = i_face_log_get_group_permits_args_finalize;
  gobject_class->get_property = i_face_log_get_group_permits_args_get_property;
  gobject_class->set_property = i_face_log_get_group_permits_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_GROUP_PERMITS_ARGS_DEVICE_ID,
     g_param_spec_int ("deviceId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_GROUP_PERMITS_ARGS_PERSON_GROUP_ID_LIST,
     g_param_spec_boxed ("personGroupIdList",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_group_permits_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetGroupPermitsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_group_permits_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetGroupPermitsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_group_permits_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetGroupPermitsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetGroupPermitsResultProperties
{
  PROP_I_FACE_LOG_GET_GROUP_PERMITS_RESULT_0,
  PROP_I_FACE_LOG_GET_GROUP_PERMITS_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_GROUP_PERMITS_RESULT_EX1
};

/* reads a i_face_log_get_group_permits_result object */
static gint32
i_face_log_get_group_permits_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetGroupPermitsResult * this_object = I_FACE_LOG_GET_GROUP_PERMITS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              PermitBean * _elem56 = NULL;
              if ( _elem56 != NULL)
              {
                g_object_unref (_elem56);
              }
              _elem56 = g_object_new (TYPE_PERMIT_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem56), protocol, error)) < 0)
              {
                g_object_unref (_elem56);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem56);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_group_permits_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetGroupPermitsResult * this_object = I_FACE_LOG_GET_GROUP_PERMITS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetGroupPermitsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i57;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i57 = 0; i57 < (this_object->success ? this_object->success->len : 0); i57++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i57))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_group_permits_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogGetGroupPermitsResult *self = I_FACE_LOG_GET_GROUP_PERMITS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_GROUP_PERMITS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_GROUP_PERMITS_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_group_permits_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogGetGroupPermitsResult *self = I_FACE_LOG_GET_GROUP_PERMITS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_GROUP_PERMITS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_GROUP_PERMITS_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_group_permits_result_instance_init (IFaceLogGetGroupPermitsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_group_permits_result_finalize (GObject *object)
{
  IFaceLogGetGroupPermitsResult *tobject = I_FACE_LOG_GET_GROUP_PERMITS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_group_permits_result_class_init (IFaceLogGetGroupPermitsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_group_permits_result_read;
  struct_class->write = i_face_log_get_group_permits_result_write;

  gobject_class->finalize = i_face_log_get_group_permits_result_finalize;
  gobject_class->get_property = i_face_log_get_group_permits_result_get_property;
  gobject_class->set_property = i_face_log_get_group_permits_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_GROUP_PERMITS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_GROUP_PERMITS_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_group_permits_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetGroupPermitsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_group_permits_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetGroupPermitsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_group_permits_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetGroupPermitsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetImageArgsProperties
{
  PROP_I_FACE_LOG_GET_IMAGE_ARGS_0,
  PROP_I_FACE_LOG_GET_IMAGE_ARGS_IMAGE_M_D5
};

/* reads a i_face_log_get_image_args object */
static gint32
i_face_log_get_image_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetImageArgs * this_object = I_FACE_LOG_GET_IMAGE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->imageMD5 != NULL)
          {
            g_free(this_object->imageMD5);
            this_object->imageMD5 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->imageMD5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_imageMD5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_image_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetImageArgs * this_object = I_FACE_LOG_GET_IMAGE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetImageArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "imageMD5", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->imageMD5, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_image_args_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  IFaceLogGetImageArgs *self = I_FACE_LOG_GET_IMAGE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_IMAGE_ARGS_IMAGE_M_D5:
      if (self->imageMD5 != NULL)
        g_free (self->imageMD5);
      self->imageMD5 = g_value_dup_string (value);
      self->__isset_imageMD5 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_image_args_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  IFaceLogGetImageArgs *self = I_FACE_LOG_GET_IMAGE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_IMAGE_ARGS_IMAGE_M_D5:
      g_value_set_string (value, self->imageMD5);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_image_args_instance_init (IFaceLogGetImageArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->imageMD5 = NULL;
  object->__isset_imageMD5 = FALSE;
}

static void 
i_face_log_get_image_args_finalize (GObject *object)
{
  IFaceLogGetImageArgs *tobject = I_FACE_LOG_GET_IMAGE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->imageMD5 != NULL)
  {
    g_free(tobject->imageMD5);
    tobject->imageMD5 = NULL;
  }
}

static void
i_face_log_get_image_args_class_init (IFaceLogGetImageArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_image_args_read;
  struct_class->write = i_face_log_get_image_args_write;

  gobject_class->finalize = i_face_log_get_image_args_finalize;
  gobject_class->get_property = i_face_log_get_image_args_get_property;
  gobject_class->set_property = i_face_log_get_image_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_IMAGE_ARGS_IMAGE_M_D5,
     g_param_spec_string ("imageMD5",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_get_image_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetImageArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_image_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetImageArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_image_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetImageArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetImageResultProperties
{
  PROP_I_FACE_LOG_GET_IMAGE_RESULT_0,
  PROP_I_FACE_LOG_GET_IMAGE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_IMAGE_RESULT_EX1
};

/* reads a i_face_log_get_image_result object */
static gint32
i_face_log_get_image_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetImageResult * this_object = I_FACE_LOG_GET_IMAGE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_image_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetImageResult * this_object = I_FACE_LOG_GET_IMAGE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetImageResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_image_result_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  IFaceLogGetImageResult *self = I_FACE_LOG_GET_IMAGE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_IMAGE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_IMAGE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_image_result_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  IFaceLogGetImageResult *self = I_FACE_LOG_GET_IMAGE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_IMAGE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_IMAGE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_image_result_instance_init (IFaceLogGetImageResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_IMAGE_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_image_result_finalize (GObject *object)
{
  IFaceLogGetImageResult *tobject = I_FACE_LOG_GET_IMAGE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_image_result_class_init (IFaceLogGetImageResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_image_result_read;
  struct_class->write = i_face_log_get_image_result_write;

  gobject_class->finalize = i_face_log_get_image_result_finalize;
  gobject_class->get_property = i_face_log_get_image_result_get_property;
  gobject_class->set_property = i_face_log_get_image_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_IMAGE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_IMAGE_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_IMAGE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_image_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetImageResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_image_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetImageResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_image_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetImageResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetImageBytesArgsProperties
{
  PROP_I_FACE_LOG_GET_IMAGE_BYTES_ARGS_0,
  PROP_I_FACE_LOG_GET_IMAGE_BYTES_ARGS_IMAGE_M_D5
};

/* reads a i_face_log_get_image_bytes_args object */
static gint32
i_face_log_get_image_bytes_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetImageBytesArgs * this_object = I_FACE_LOG_GET_IMAGE_BYTES_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->imageMD5 != NULL)
          {
            g_free(this_object->imageMD5);
            this_object->imageMD5 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->imageMD5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_imageMD5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_image_bytes_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetImageBytesArgs * this_object = I_FACE_LOG_GET_IMAGE_BYTES_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetImageBytesArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "imageMD5", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->imageMD5, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_image_bytes_args_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogGetImageBytesArgs *self = I_FACE_LOG_GET_IMAGE_BYTES_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_IMAGE_BYTES_ARGS_IMAGE_M_D5:
      if (self->imageMD5 != NULL)
        g_free (self->imageMD5);
      self->imageMD5 = g_value_dup_string (value);
      self->__isset_imageMD5 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_image_bytes_args_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogGetImageBytesArgs *self = I_FACE_LOG_GET_IMAGE_BYTES_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_IMAGE_BYTES_ARGS_IMAGE_M_D5:
      g_value_set_string (value, self->imageMD5);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_image_bytes_args_instance_init (IFaceLogGetImageBytesArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->imageMD5 = NULL;
  object->__isset_imageMD5 = FALSE;
}

static void 
i_face_log_get_image_bytes_args_finalize (GObject *object)
{
  IFaceLogGetImageBytesArgs *tobject = I_FACE_LOG_GET_IMAGE_BYTES_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->imageMD5 != NULL)
  {
    g_free(tobject->imageMD5);
    tobject->imageMD5 = NULL;
  }
}

static void
i_face_log_get_image_bytes_args_class_init (IFaceLogGetImageBytesArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_image_bytes_args_read;
  struct_class->write = i_face_log_get_image_bytes_args_write;

  gobject_class->finalize = i_face_log_get_image_bytes_args_finalize;
  gobject_class->get_property = i_face_log_get_image_bytes_args_get_property;
  gobject_class->set_property = i_face_log_get_image_bytes_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_IMAGE_BYTES_ARGS_IMAGE_M_D5,
     g_param_spec_string ("imageMD5",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_get_image_bytes_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetImageBytesArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_image_bytes_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetImageBytesArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_image_bytes_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetImageBytesArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetImageBytesResultProperties
{
  PROP_I_FACE_LOG_GET_IMAGE_BYTES_RESULT_0,
  PROP_I_FACE_LOG_GET_IMAGE_BYTES_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_IMAGE_BYTES_RESULT_EX1
};

/* reads a i_face_log_get_image_bytes_result object */
static gint32
i_face_log_get_image_bytes_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetImageBytesResult * this_object = I_FACE_LOG_GET_IMAGE_BYTES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->success = g_byte_array_new();
          g_byte_array_append (this_object->success, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_image_bytes_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetImageBytesResult * this_object = I_FACE_LOG_GET_IMAGE_BYTES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetImageBytesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->success ? ((GByteArray *) this_object->success)->data : NULL, this_object->success ? ((GByteArray *) this_object->success)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_image_bytes_result_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogGetImageBytesResult *self = I_FACE_LOG_GET_IMAGE_BYTES_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_IMAGE_BYTES_RESULT_SUCCESS:
      if (self->success != NULL)
        g_byte_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_IMAGE_BYTES_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_image_bytes_result_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogGetImageBytesResult *self = I_FACE_LOG_GET_IMAGE_BYTES_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_IMAGE_BYTES_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_IMAGE_BYTES_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_image_bytes_result_instance_init (IFaceLogGetImageBytesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_image_bytes_result_finalize (GObject *object)
{
  IFaceLogGetImageBytesResult *tobject = I_FACE_LOG_GET_IMAGE_BYTES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    thrift_string_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_image_bytes_result_class_init (IFaceLogGetImageBytesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_image_bytes_result_read;
  struct_class->write = i_face_log_get_image_bytes_result_write;

  gobject_class->finalize = i_face_log_get_image_bytes_result_finalize;
  gobject_class->get_property = i_face_log_get_image_bytes_result_get_property;
  gobject_class->set_property = i_face_log_get_image_bytes_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_IMAGE_BYTES_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_IMAGE_BYTES_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_image_bytes_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetImageBytesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_image_bytes_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetImageBytesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_image_bytes_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetImageBytesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetImagesAssociatedByFeatureArgsProperties
{
  PROP_I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_ARGS_0,
  PROP_I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_ARGS_FEATURE_MD5
};

/* reads a i_face_log_get_images_associated_by_feature_args object */
static gint32
i_face_log_get_images_associated_by_feature_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetImagesAssociatedByFeatureArgs * this_object = I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->featureMd5 != NULL)
          {
            g_free(this_object->featureMd5);
            this_object->featureMd5 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->featureMd5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_featureMd5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_images_associated_by_feature_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetImagesAssociatedByFeatureArgs * this_object = I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetImagesAssociatedByFeatureArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "featureMd5", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->featureMd5, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_images_associated_by_feature_args_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  IFaceLogGetImagesAssociatedByFeatureArgs *self = I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_ARGS_FEATURE_MD5:
      if (self->featureMd5 != NULL)
        g_free (self->featureMd5);
      self->featureMd5 = g_value_dup_string (value);
      self->__isset_featureMd5 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_images_associated_by_feature_args_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  IFaceLogGetImagesAssociatedByFeatureArgs *self = I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_ARGS_FEATURE_MD5:
      g_value_set_string (value, self->featureMd5);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_images_associated_by_feature_args_instance_init (IFaceLogGetImagesAssociatedByFeatureArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->featureMd5 = NULL;
  object->__isset_featureMd5 = FALSE;
}

static void 
i_face_log_get_images_associated_by_feature_args_finalize (GObject *object)
{
  IFaceLogGetImagesAssociatedByFeatureArgs *tobject = I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->featureMd5 != NULL)
  {
    g_free(tobject->featureMd5);
    tobject->featureMd5 = NULL;
  }
}

static void
i_face_log_get_images_associated_by_feature_args_class_init (IFaceLogGetImagesAssociatedByFeatureArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_images_associated_by_feature_args_read;
  struct_class->write = i_face_log_get_images_associated_by_feature_args_write;

  gobject_class->finalize = i_face_log_get_images_associated_by_feature_args_finalize;
  gobject_class->get_property = i_face_log_get_images_associated_by_feature_args_get_property;
  gobject_class->set_property = i_face_log_get_images_associated_by_feature_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_ARGS_FEATURE_MD5,
     g_param_spec_string ("featureMd5",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_get_images_associated_by_feature_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetImagesAssociatedByFeatureArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_images_associated_by_feature_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetImagesAssociatedByFeatureArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_images_associated_by_feature_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetImagesAssociatedByFeatureArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetImagesAssociatedByFeatureResultProperties
{
  PROP_I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_RESULT_0,
  PROP_I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_RESULT_EX1
};

/* reads a i_face_log_get_images_associated_by_feature_result object */
static gint32
i_face_log_get_images_associated_by_feature_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetImagesAssociatedByFeatureResult * this_object = I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem58 = NULL;
              if (_elem58 != NULL)
              {
                g_free(_elem58);
                _elem58 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem58, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem58);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_images_associated_by_feature_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetImagesAssociatedByFeatureResult * this_object = I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetImagesAssociatedByFeatureResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i59;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i59 = 0; i59 < (this_object->success ? this_object->success->len : 0); i59++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->success, i59)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_images_associated_by_feature_result_set_property (GObject *object,
                                                                 guint property_id,
                                                                 const GValue *value,
                                                                 GParamSpec *pspec)
{
  IFaceLogGetImagesAssociatedByFeatureResult *self = I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_images_associated_by_feature_result_get_property (GObject *object,
                                                                 guint property_id,
                                                                 GValue *value,
                                                                 GParamSpec *pspec)
{
  IFaceLogGetImagesAssociatedByFeatureResult *self = I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_images_associated_by_feature_result_instance_init (IFaceLogGetImagesAssociatedByFeatureResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_free);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_images_associated_by_feature_result_finalize (GObject *object)
{
  IFaceLogGetImagesAssociatedByFeatureResult *tobject = I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_images_associated_by_feature_result_class_init (IFaceLogGetImagesAssociatedByFeatureResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_images_associated_by_feature_result_read;
  struct_class->write = i_face_log_get_images_associated_by_feature_result_write;

  gobject_class->finalize = i_face_log_get_images_associated_by_feature_result_finalize;
  gobject_class->get_property = i_face_log_get_images_associated_by_feature_result_get_property;
  gobject_class->set_property = i_face_log_get_images_associated_by_feature_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_images_associated_by_feature_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetImagesAssociatedByFeatureResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_images_associated_by_feature_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetImagesAssociatedByFeatureResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_images_associated_by_feature_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetImagesAssociatedByFeatureResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetLogBeansByPersonIdArgsProperties
{
  PROP_I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_ARGS_0,
  PROP_I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_ARGS_PERSON_ID
};

/* reads a i_face_log_get_log_beans_by_person_id_args object */
static gint32
i_face_log_get_log_beans_by_person_id_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetLogBeansByPersonIdArgs * this_object = I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_ARGS(object);
  gboolean isset_personId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_log_beans_by_person_id_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetLogBeansByPersonIdArgs * this_object = I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetLogBeansByPersonIdArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_log_beans_by_person_id_args_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  IFaceLogGetLogBeansByPersonIdArgs *self = I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_ARGS_PERSON_ID:
      self->personId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_log_beans_by_person_id_args_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  IFaceLogGetLogBeansByPersonIdArgs *self = I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_ARGS_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_log_beans_by_person_id_args_instance_init (IFaceLogGetLogBeansByPersonIdArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personId = 0;
}

static void 
i_face_log_get_log_beans_by_person_id_args_finalize (GObject *object)
{
  IFaceLogGetLogBeansByPersonIdArgs *tobject = I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_get_log_beans_by_person_id_args_class_init (IFaceLogGetLogBeansByPersonIdArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_log_beans_by_person_id_args_read;
  struct_class->write = i_face_log_get_log_beans_by_person_id_args_write;

  gobject_class->finalize = i_face_log_get_log_beans_by_person_id_args_finalize;
  gobject_class->get_property = i_face_log_get_log_beans_by_person_id_args_get_property;
  gobject_class->set_property = i_face_log_get_log_beans_by_person_id_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_ARGS_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_get_log_beans_by_person_id_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetLogBeansByPersonIdArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_log_beans_by_person_id_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetLogBeansByPersonIdArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_log_beans_by_person_id_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetLogBeansByPersonIdArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetLogBeansByPersonIdResultProperties
{
  PROP_I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_RESULT_0,
  PROP_I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_RESULT_EX1
};

/* reads a i_face_log_get_log_beans_by_person_id_result object */
static gint32
i_face_log_get_log_beans_by_person_id_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetLogBeansByPersonIdResult * this_object = I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              LogBean * _elem60 = NULL;
              if ( _elem60 != NULL)
              {
                g_object_unref (_elem60);
              }
              _elem60 = g_object_new (TYPE_LOG_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem60), protocol, error)) < 0)
              {
                g_object_unref (_elem60);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem60);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_log_beans_by_person_id_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetLogBeansByPersonIdResult * this_object = I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetLogBeansByPersonIdResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i61;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i61 = 0; i61 < (this_object->success ? this_object->success->len : 0); i61++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i61))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_log_beans_by_person_id_result_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  IFaceLogGetLogBeansByPersonIdResult *self = I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_log_beans_by_person_id_result_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  IFaceLogGetLogBeansByPersonIdResult *self = I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_log_beans_by_person_id_result_instance_init (IFaceLogGetLogBeansByPersonIdResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_log_beans_by_person_id_result_finalize (GObject *object)
{
  IFaceLogGetLogBeansByPersonIdResult *tobject = I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_log_beans_by_person_id_result_class_init (IFaceLogGetLogBeansByPersonIdResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_log_beans_by_person_id_result_read;
  struct_class->write = i_face_log_get_log_beans_by_person_id_result_write;

  gobject_class->finalize = i_face_log_get_log_beans_by_person_id_result_finalize;
  gobject_class->get_property = i_face_log_get_log_beans_by_person_id_result_get_property;
  gobject_class->set_property = i_face_log_get_log_beans_by_person_id_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_log_beans_by_person_id_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetLogBeansByPersonIdResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_log_beans_by_person_id_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetLogBeansByPersonIdResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_log_beans_by_person_id_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetLogBeansByPersonIdResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPersonArgsProperties
{
  PROP_I_FACE_LOG_GET_PERSON_ARGS_0,
  PROP_I_FACE_LOG_GET_PERSON_ARGS_PERSON_ID
};

/* reads a i_face_log_get_person_args object */
static gint32
i_face_log_get_person_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPersonArgs * this_object = I_FACE_LOG_GET_PERSON_ARGS(object);
  gboolean isset_personId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_person_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPersonArgs * this_object = I_FACE_LOG_GET_PERSON_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPersonArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_person_args_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  IFaceLogGetPersonArgs *self = I_FACE_LOG_GET_PERSON_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_ARGS_PERSON_ID:
      self->personId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_person_args_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  IFaceLogGetPersonArgs *self = I_FACE_LOG_GET_PERSON_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_ARGS_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_person_args_instance_init (IFaceLogGetPersonArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personId = 0;
}

static void 
i_face_log_get_person_args_finalize (GObject *object)
{
  IFaceLogGetPersonArgs *tobject = I_FACE_LOG_GET_PERSON_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_get_person_args_class_init (IFaceLogGetPersonArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_person_args_read;
  struct_class->write = i_face_log_get_person_args_write;

  gobject_class->finalize = i_face_log_get_person_args_finalize;
  gobject_class->get_property = i_face_log_get_person_args_get_property;
  gobject_class->set_property = i_face_log_get_person_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_ARGS_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_get_person_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPersonArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_person_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPersonArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_person_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPersonArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPersonResultProperties
{
  PROP_I_FACE_LOG_GET_PERSON_RESULT_0,
  PROP_I_FACE_LOG_GET_PERSON_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_PERSON_RESULT_EX1
};

/* reads a i_face_log_get_person_result object */
static gint32
i_face_log_get_person_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPersonResult * this_object = I_FACE_LOG_GET_PERSON_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_person_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPersonResult * this_object = I_FACE_LOG_GET_PERSON_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPersonResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_person_result_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogGetPersonResult *self = I_FACE_LOG_GET_PERSON_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_PERSON_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_person_result_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogGetPersonResult *self = I_FACE_LOG_GET_PERSON_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_PERSON_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_person_result_instance_init (IFaceLogGetPersonResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_PERSON_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_person_result_finalize (GObject *object)
{
  IFaceLogGetPersonResult *tobject = I_FACE_LOG_GET_PERSON_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_person_result_class_init (IFaceLogGetPersonResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_person_result_read;
  struct_class->write = i_face_log_get_person_result_write;

  gobject_class->finalize = i_face_log_get_person_result_finalize;
  gobject_class->get_property = i_face_log_get_person_result_get_property;
  gobject_class->set_property = i_face_log_get_person_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_PERSON_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_person_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPersonResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_person_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPersonResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_person_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPersonResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPersonByPapersNumArgsProperties
{
  PROP_I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_ARGS_0,
  PROP_I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_ARGS_PAPERS_NUM
};

/* reads a i_face_log_get_person_by_papers_num_args object */
static gint32
i_face_log_get_person_by_papers_num_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPersonByPapersNumArgs * this_object = I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->papersNum != NULL)
          {
            g_free(this_object->papersNum);
            this_object->papersNum = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->papersNum, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_papersNum = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_person_by_papers_num_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPersonByPapersNumArgs * this_object = I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPersonByPapersNumArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "papersNum", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->papersNum, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_person_by_papers_num_args_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  IFaceLogGetPersonByPapersNumArgs *self = I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_ARGS_PAPERS_NUM:
      if (self->papersNum != NULL)
        g_free (self->papersNum);
      self->papersNum = g_value_dup_string (value);
      self->__isset_papersNum = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_person_by_papers_num_args_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  IFaceLogGetPersonByPapersNumArgs *self = I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_ARGS_PAPERS_NUM:
      g_value_set_string (value, self->papersNum);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_person_by_papers_num_args_instance_init (IFaceLogGetPersonByPapersNumArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->papersNum = NULL;
  object->__isset_papersNum = FALSE;
}

static void 
i_face_log_get_person_by_papers_num_args_finalize (GObject *object)
{
  IFaceLogGetPersonByPapersNumArgs *tobject = I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->papersNum != NULL)
  {
    g_free(tobject->papersNum);
    tobject->papersNum = NULL;
  }
}

static void
i_face_log_get_person_by_papers_num_args_class_init (IFaceLogGetPersonByPapersNumArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_person_by_papers_num_args_read;
  struct_class->write = i_face_log_get_person_by_papers_num_args_write;

  gobject_class->finalize = i_face_log_get_person_by_papers_num_args_finalize;
  gobject_class->get_property = i_face_log_get_person_by_papers_num_args_get_property;
  gobject_class->set_property = i_face_log_get_person_by_papers_num_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_ARGS_PAPERS_NUM,
     g_param_spec_string ("papersNum",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_get_person_by_papers_num_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPersonByPapersNumArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_person_by_papers_num_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPersonByPapersNumArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_person_by_papers_num_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPersonByPapersNumArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPersonByPapersNumResultProperties
{
  PROP_I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_RESULT_0,
  PROP_I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_RESULT_EX1
};

/* reads a i_face_log_get_person_by_papers_num_result object */
static gint32
i_face_log_get_person_by_papers_num_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPersonByPapersNumResult * this_object = I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_person_by_papers_num_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPersonByPapersNumResult * this_object = I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPersonByPapersNumResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_person_by_papers_num_result_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  IFaceLogGetPersonByPapersNumResult *self = I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_person_by_papers_num_result_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  IFaceLogGetPersonByPapersNumResult *self = I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_person_by_papers_num_result_instance_init (IFaceLogGetPersonByPapersNumResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_PERSON_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_person_by_papers_num_result_finalize (GObject *object)
{
  IFaceLogGetPersonByPapersNumResult *tobject = I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_person_by_papers_num_result_class_init (IFaceLogGetPersonByPapersNumResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_person_by_papers_num_result_read;
  struct_class->write = i_face_log_get_person_by_papers_num_result_write;

  gobject_class->finalize = i_face_log_get_person_by_papers_num_result_finalize;
  gobject_class->get_property = i_face_log_get_person_by_papers_num_result_get_property;
  gobject_class->set_property = i_face_log_get_person_by_papers_num_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_PERSON_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_person_by_papers_num_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPersonByPapersNumResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_person_by_papers_num_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPersonByPapersNumResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_person_by_papers_num_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPersonByPapersNumResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPersonGroupArgsProperties
{
  PROP_I_FACE_LOG_GET_PERSON_GROUP_ARGS_0,
  PROP_I_FACE_LOG_GET_PERSON_GROUP_ARGS_PERSON_GROUP_ID
};

/* reads a i_face_log_get_person_group_args object */
static gint32
i_face_log_get_person_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPersonGroupArgs * this_object = I_FACE_LOG_GET_PERSON_GROUP_ARGS(object);
  gboolean isset_personGroupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_person_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPersonGroupArgs * this_object = I_FACE_LOG_GET_PERSON_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPersonGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_person_group_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogGetPersonGroupArgs *self = I_FACE_LOG_GET_PERSON_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_GROUP_ARGS_PERSON_GROUP_ID:
      self->personGroupId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_person_group_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogGetPersonGroupArgs *self = I_FACE_LOG_GET_PERSON_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_GROUP_ARGS_PERSON_GROUP_ID:
      g_value_set_int (value, self->personGroupId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_person_group_args_instance_init (IFaceLogGetPersonGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personGroupId = 0;
}

static void 
i_face_log_get_person_group_args_finalize (GObject *object)
{
  IFaceLogGetPersonGroupArgs *tobject = I_FACE_LOG_GET_PERSON_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_get_person_group_args_class_init (IFaceLogGetPersonGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_person_group_args_read;
  struct_class->write = i_face_log_get_person_group_args_write;

  gobject_class->finalize = i_face_log_get_person_group_args_finalize;
  gobject_class->get_property = i_face_log_get_person_group_args_get_property;
  gobject_class->set_property = i_face_log_get_person_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_GROUP_ARGS_PERSON_GROUP_ID,
     g_param_spec_int ("personGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_get_person_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPersonGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_person_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPersonGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_person_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPersonGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPersonGroupResultProperties
{
  PROP_I_FACE_LOG_GET_PERSON_GROUP_RESULT_0,
  PROP_I_FACE_LOG_GET_PERSON_GROUP_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_PERSON_GROUP_RESULT_EX1
};

/* reads a i_face_log_get_person_group_result object */
static gint32
i_face_log_get_person_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPersonGroupResult * this_object = I_FACE_LOG_GET_PERSON_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_person_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPersonGroupResult * this_object = I_FACE_LOG_GET_PERSON_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPersonGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_person_group_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogGetPersonGroupResult *self = I_FACE_LOG_GET_PERSON_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_GROUP_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_PERSON_GROUP_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_person_group_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogGetPersonGroupResult *self = I_FACE_LOG_GET_PERSON_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_GROUP_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_PERSON_GROUP_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_person_group_result_instance_init (IFaceLogGetPersonGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_PERSON_GROUP_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_person_group_result_finalize (GObject *object)
{
  IFaceLogGetPersonGroupResult *tobject = I_FACE_LOG_GET_PERSON_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_person_group_result_class_init (IFaceLogGetPersonGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_person_group_result_read;
  struct_class->write = i_face_log_get_person_group_result_write;

  gobject_class->finalize = i_face_log_get_person_group_result_finalize;
  gobject_class->get_property = i_face_log_get_person_group_result_get_property;
  gobject_class->set_property = i_face_log_get_person_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_GROUP_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_PERSON_GROUP_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_GROUP_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_person_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPersonGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_person_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPersonGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_person_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPersonGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPersonGroupsArgsProperties
{
  PROP_I_FACE_LOG_GET_PERSON_GROUPS_ARGS_0,
  PROP_I_FACE_LOG_GET_PERSON_GROUPS_ARGS_GROUP_ID_LIST
};

/* reads a i_face_log_get_person_groups_args object */
static gint32
i_face_log_get_person_groups_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPersonGroupsArgs * this_object = I_FACE_LOG_GET_PERSON_GROUPS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem62 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem62, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->groupIdList, _elem62, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_groupIdList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_person_groups_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPersonGroupsArgs * this_object = I_FACE_LOG_GET_PERSON_GROUPS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPersonGroupsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "groupIdList", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i63;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->groupIdList ? this_object->groupIdList->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i63 = 0; i63 < (this_object->groupIdList ? this_object->groupIdList->len : 0); i63++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->groupIdList, gint32, i63)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_person_groups_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogGetPersonGroupsArgs *self = I_FACE_LOG_GET_PERSON_GROUPS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_GROUPS_ARGS_GROUP_ID_LIST:
      if (self->groupIdList != NULL)
        g_array_unref (self->groupIdList);
      self->groupIdList = g_value_dup_boxed (value);
      self->__isset_groupIdList = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_person_groups_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogGetPersonGroupsArgs *self = I_FACE_LOG_GET_PERSON_GROUPS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_GROUPS_ARGS_GROUP_ID_LIST:
      g_value_set_boxed (value, self->groupIdList);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_person_groups_args_instance_init (IFaceLogGetPersonGroupsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->groupIdList = g_array_new (0, 1, sizeof (gint32));
  object->__isset_groupIdList = FALSE;
}

static void 
i_face_log_get_person_groups_args_finalize (GObject *object)
{
  IFaceLogGetPersonGroupsArgs *tobject = I_FACE_LOG_GET_PERSON_GROUPS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->groupIdList != NULL)
  {
    g_array_unref (tobject->groupIdList);
    tobject->groupIdList = NULL;
  }
}

static void
i_face_log_get_person_groups_args_class_init (IFaceLogGetPersonGroupsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_person_groups_args_read;
  struct_class->write = i_face_log_get_person_groups_args_write;

  gobject_class->finalize = i_face_log_get_person_groups_args_finalize;
  gobject_class->get_property = i_face_log_get_person_groups_args_get_property;
  gobject_class->set_property = i_face_log_get_person_groups_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_GROUPS_ARGS_GROUP_ID_LIST,
     g_param_spec_boxed ("groupIdList",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_person_groups_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPersonGroupsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_person_groups_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPersonGroupsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_person_groups_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPersonGroupsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPersonGroupsResultProperties
{
  PROP_I_FACE_LOG_GET_PERSON_GROUPS_RESULT_0,
  PROP_I_FACE_LOG_GET_PERSON_GROUPS_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_PERSON_GROUPS_RESULT_EX1
};

/* reads a i_face_log_get_person_groups_result object */
static gint32
i_face_log_get_person_groups_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPersonGroupsResult * this_object = I_FACE_LOG_GET_PERSON_GROUPS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              PersonGroupBean * _elem64 = NULL;
              if ( _elem64 != NULL)
              {
                g_object_unref (_elem64);
              }
              _elem64 = g_object_new (TYPE_PERSON_GROUP_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem64), protocol, error)) < 0)
              {
                g_object_unref (_elem64);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem64);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_person_groups_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPersonGroupsResult * this_object = I_FACE_LOG_GET_PERSON_GROUPS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPersonGroupsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i65;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i65 = 0; i65 < (this_object->success ? this_object->success->len : 0); i65++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i65))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_person_groups_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogGetPersonGroupsResult *self = I_FACE_LOG_GET_PERSON_GROUPS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_GROUPS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_PERSON_GROUPS_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_person_groups_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogGetPersonGroupsResult *self = I_FACE_LOG_GET_PERSON_GROUPS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_GROUPS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_PERSON_GROUPS_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_person_groups_result_instance_init (IFaceLogGetPersonGroupsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_person_groups_result_finalize (GObject *object)
{
  IFaceLogGetPersonGroupsResult *tobject = I_FACE_LOG_GET_PERSON_GROUPS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_person_groups_result_class_init (IFaceLogGetPersonGroupsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_person_groups_result_read;
  struct_class->write = i_face_log_get_person_groups_result_write;

  gobject_class->finalize = i_face_log_get_person_groups_result_finalize;
  gobject_class->get_property = i_face_log_get_person_groups_result_get_property;
  gobject_class->set_property = i_face_log_get_person_groups_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_GROUPS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_GROUPS_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_person_groups_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPersonGroupsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_person_groups_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPersonGroupsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_person_groups_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPersonGroupsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPersonGroupsBelongsArgsProperties
{
  PROP_I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_ARGS_0,
  PROP_I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_ARGS_PERSON_ID
};

/* reads a i_face_log_get_person_groups_belongs_args object */
static gint32
i_face_log_get_person_groups_belongs_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPersonGroupsBelongsArgs * this_object = I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_ARGS(object);
  gboolean isset_personId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_person_groups_belongs_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPersonGroupsBelongsArgs * this_object = I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPersonGroupsBelongsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_person_groups_belongs_args_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  IFaceLogGetPersonGroupsBelongsArgs *self = I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_ARGS_PERSON_ID:
      self->personId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_person_groups_belongs_args_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  IFaceLogGetPersonGroupsBelongsArgs *self = I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_ARGS_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_person_groups_belongs_args_instance_init (IFaceLogGetPersonGroupsBelongsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personId = 0;
}

static void 
i_face_log_get_person_groups_belongs_args_finalize (GObject *object)
{
  IFaceLogGetPersonGroupsBelongsArgs *tobject = I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_get_person_groups_belongs_args_class_init (IFaceLogGetPersonGroupsBelongsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_person_groups_belongs_args_read;
  struct_class->write = i_face_log_get_person_groups_belongs_args_write;

  gobject_class->finalize = i_face_log_get_person_groups_belongs_args_finalize;
  gobject_class->get_property = i_face_log_get_person_groups_belongs_args_get_property;
  gobject_class->set_property = i_face_log_get_person_groups_belongs_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_ARGS_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_get_person_groups_belongs_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPersonGroupsBelongsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_person_groups_belongs_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPersonGroupsBelongsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_person_groups_belongs_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPersonGroupsBelongsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPersonGroupsBelongsResultProperties
{
  PROP_I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_RESULT_0,
  PROP_I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_RESULT_EX1
};

/* reads a i_face_log_get_person_groups_belongs_result object */
static gint32
i_face_log_get_person_groups_belongs_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPersonGroupsBelongsResult * this_object = I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem66 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem66, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem66, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_person_groups_belongs_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPersonGroupsBelongsResult * this_object = I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPersonGroupsBelongsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i67;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i67 = 0; i67 < (this_object->success ? this_object->success->len : 0); i67++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i67)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_person_groups_belongs_result_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  IFaceLogGetPersonGroupsBelongsResult *self = I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_person_groups_belongs_result_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  IFaceLogGetPersonGroupsBelongsResult *self = I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_person_groups_belongs_result_instance_init (IFaceLogGetPersonGroupsBelongsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_person_groups_belongs_result_finalize (GObject *object)
{
  IFaceLogGetPersonGroupsBelongsResult *tobject = I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_person_groups_belongs_result_class_init (IFaceLogGetPersonGroupsBelongsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_person_groups_belongs_result_read;
  struct_class->write = i_face_log_get_person_groups_belongs_result_write;

  gobject_class->finalize = i_face_log_get_person_groups_belongs_result_finalize;
  gobject_class->get_property = i_face_log_get_person_groups_belongs_result_get_property;
  gobject_class->set_property = i_face_log_get_person_groups_belongs_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_person_groups_belongs_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPersonGroupsBelongsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_person_groups_belongs_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPersonGroupsBelongsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_person_groups_belongs_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPersonGroupsBelongsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPersonGroupsPermittedByArgsProperties
{
  PROP_I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_ARGS_0,
  PROP_I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_ARGS_DEVICE_GROUP_ID
};

/* reads a i_face_log_get_person_groups_permitted_by_args object */
static gint32
i_face_log_get_person_groups_permitted_by_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPersonGroupsPermittedByArgs * this_object = I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_ARGS(object);
  gboolean isset_deviceGroupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_deviceGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_deviceGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_person_groups_permitted_by_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPersonGroupsPermittedByArgs * this_object = I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPersonGroupsPermittedByArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_person_groups_permitted_by_args_set_property (GObject *object,
                                                             guint property_id,
                                                             const GValue *value,
                                                             GParamSpec *pspec)
{
  IFaceLogGetPersonGroupsPermittedByArgs *self = I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_ARGS_DEVICE_GROUP_ID:
      self->deviceGroupId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_person_groups_permitted_by_args_get_property (GObject *object,
                                                             guint property_id,
                                                             GValue *value,
                                                             GParamSpec *pspec)
{
  IFaceLogGetPersonGroupsPermittedByArgs *self = I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_ARGS_DEVICE_GROUP_ID:
      g_value_set_int (value, self->deviceGroupId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_person_groups_permitted_by_args_instance_init (IFaceLogGetPersonGroupsPermittedByArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->deviceGroupId = 0;
}

static void 
i_face_log_get_person_groups_permitted_by_args_finalize (GObject *object)
{
  IFaceLogGetPersonGroupsPermittedByArgs *tobject = I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_get_person_groups_permitted_by_args_class_init (IFaceLogGetPersonGroupsPermittedByArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_person_groups_permitted_by_args_read;
  struct_class->write = i_face_log_get_person_groups_permitted_by_args_write;

  gobject_class->finalize = i_face_log_get_person_groups_permitted_by_args_finalize;
  gobject_class->get_property = i_face_log_get_person_groups_permitted_by_args_get_property;
  gobject_class->set_property = i_face_log_get_person_groups_permitted_by_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_ARGS_DEVICE_GROUP_ID,
     g_param_spec_int ("deviceGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_get_person_groups_permitted_by_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPersonGroupsPermittedByArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_person_groups_permitted_by_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPersonGroupsPermittedByArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_person_groups_permitted_by_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPersonGroupsPermittedByArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPersonGroupsPermittedByResultProperties
{
  PROP_I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_RESULT_0,
  PROP_I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_RESULT_EX1
};

/* reads a i_face_log_get_person_groups_permitted_by_result object */
static gint32
i_face_log_get_person_groups_permitted_by_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPersonGroupsPermittedByResult * this_object = I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem68 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem68, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem68, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_person_groups_permitted_by_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPersonGroupsPermittedByResult * this_object = I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPersonGroupsPermittedByResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i69;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i69 = 0; i69 < (this_object->success ? this_object->success->len : 0); i69++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i69)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_person_groups_permitted_by_result_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  IFaceLogGetPersonGroupsPermittedByResult *self = I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_person_groups_permitted_by_result_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  IFaceLogGetPersonGroupsPermittedByResult *self = I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_person_groups_permitted_by_result_instance_init (IFaceLogGetPersonGroupsPermittedByResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_person_groups_permitted_by_result_finalize (GObject *object)
{
  IFaceLogGetPersonGroupsPermittedByResult *tobject = I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_person_groups_permitted_by_result_class_init (IFaceLogGetPersonGroupsPermittedByResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_person_groups_permitted_by_result_read;
  struct_class->write = i_face_log_get_person_groups_permitted_by_result_write;

  gobject_class->finalize = i_face_log_get_person_groups_permitted_by_result_finalize;
  gobject_class->get_property = i_face_log_get_person_groups_permitted_by_result_get_property;
  gobject_class->set_property = i_face_log_get_person_groups_permitted_by_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_person_groups_permitted_by_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPersonGroupsPermittedByResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_person_groups_permitted_by_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPersonGroupsPermittedByResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_person_groups_permitted_by_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPersonGroupsPermittedByResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPersonPermitArgsProperties
{
  PROP_I_FACE_LOG_GET_PERSON_PERMIT_ARGS_0,
  PROP_I_FACE_LOG_GET_PERSON_PERMIT_ARGS_DEVICE_ID,
  PROP_I_FACE_LOG_GET_PERSON_PERMIT_ARGS_PERSON_ID
};

/* reads a i_face_log_get_person_permit_args object */
static gint32
i_face_log_get_person_permit_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPersonPermitArgs * this_object = I_FACE_LOG_GET_PERSON_PERMIT_ARGS(object);
  gboolean isset_deviceId = FALSE;
  gboolean isset_personId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceId, error)) < 0)
            return -1;
          xfer += ret;
          isset_deviceId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_deviceId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_personId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_person_permit_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPersonPermitArgs * this_object = I_FACE_LOG_GET_PERSON_PERMIT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPersonPermitArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_person_permit_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogGetPersonPermitArgs *self = I_FACE_LOG_GET_PERSON_PERMIT_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_PERMIT_ARGS_DEVICE_ID:
      self->deviceId = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_GET_PERSON_PERMIT_ARGS_PERSON_ID:
      self->personId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_person_permit_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogGetPersonPermitArgs *self = I_FACE_LOG_GET_PERSON_PERMIT_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_PERMIT_ARGS_DEVICE_ID:
      g_value_set_int (value, self->deviceId);
      break;

    case PROP_I_FACE_LOG_GET_PERSON_PERMIT_ARGS_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_person_permit_args_instance_init (IFaceLogGetPersonPermitArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->deviceId = 0;
  object->personId = 0;
}

static void 
i_face_log_get_person_permit_args_finalize (GObject *object)
{
  IFaceLogGetPersonPermitArgs *tobject = I_FACE_LOG_GET_PERSON_PERMIT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_get_person_permit_args_class_init (IFaceLogGetPersonPermitArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_person_permit_args_read;
  struct_class->write = i_face_log_get_person_permit_args_write;

  gobject_class->finalize = i_face_log_get_person_permit_args_finalize;
  gobject_class->get_property = i_face_log_get_person_permit_args_get_property;
  gobject_class->set_property = i_face_log_get_person_permit_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_PERMIT_ARGS_DEVICE_ID,
     g_param_spec_int ("deviceId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_PERMIT_ARGS_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_get_person_permit_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPersonPermitArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_person_permit_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPersonPermitArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_person_permit_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPersonPermitArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPersonPermitResultProperties
{
  PROP_I_FACE_LOG_GET_PERSON_PERMIT_RESULT_0,
  PROP_I_FACE_LOG_GET_PERSON_PERMIT_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_PERSON_PERMIT_RESULT_EX1
};

/* reads a i_face_log_get_person_permit_result object */
static gint32
i_face_log_get_person_permit_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPersonPermitResult * this_object = I_FACE_LOG_GET_PERSON_PERMIT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_person_permit_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPersonPermitResult * this_object = I_FACE_LOG_GET_PERSON_PERMIT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPersonPermitResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_person_permit_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogGetPersonPermitResult *self = I_FACE_LOG_GET_PERSON_PERMIT_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_PERMIT_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_PERSON_PERMIT_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_person_permit_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogGetPersonPermitResult *self = I_FACE_LOG_GET_PERSON_PERMIT_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_PERMIT_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_PERSON_PERMIT_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_person_permit_result_instance_init (IFaceLogGetPersonPermitResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_PERMIT_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_person_permit_result_finalize (GObject *object)
{
  IFaceLogGetPersonPermitResult *tobject = I_FACE_LOG_GET_PERSON_PERMIT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_person_permit_result_class_init (IFaceLogGetPersonPermitResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_person_permit_result_read;
  struct_class->write = i_face_log_get_person_permit_result_write;

  gobject_class->finalize = i_face_log_get_person_permit_result_finalize;
  gobject_class->get_property = i_face_log_get_person_permit_result_get_property;
  gobject_class->set_property = i_face_log_get_person_permit_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_PERMIT_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_PERMIT_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_PERMIT_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_person_permit_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPersonPermitResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_person_permit_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPersonPermitResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_person_permit_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPersonPermitResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPersonPermitsArgsProperties
{
  PROP_I_FACE_LOG_GET_PERSON_PERMITS_ARGS_0,
  PROP_I_FACE_LOG_GET_PERSON_PERMITS_ARGS_DEVICE_ID,
  PROP_I_FACE_LOG_GET_PERSON_PERMITS_ARGS_PERSON_ID_LIST
};

/* reads a i_face_log_get_person_permits_args object */
static gint32
i_face_log_get_person_permits_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPersonPermitsArgs * this_object = I_FACE_LOG_GET_PERSON_PERMITS_ARGS(object);
  gboolean isset_deviceId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceId, error)) < 0)
            return -1;
          xfer += ret;
          isset_deviceId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem70 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem70, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->personIdList, _elem70, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_personIdList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_deviceId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_person_permits_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPersonPermitsArgs * this_object = I_FACE_LOG_GET_PERSON_PERMITS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPersonPermitsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personIdList", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i71;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->personIdList ? this_object->personIdList->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i71 = 0; i71 < (this_object->personIdList ? this_object->personIdList->len : 0); i71++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->personIdList, gint32, i71)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_person_permits_args_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogGetPersonPermitsArgs *self = I_FACE_LOG_GET_PERSON_PERMITS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_PERMITS_ARGS_DEVICE_ID:
      self->deviceId = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_GET_PERSON_PERMITS_ARGS_PERSON_ID_LIST:
      if (self->personIdList != NULL)
        g_array_unref (self->personIdList);
      self->personIdList = g_value_dup_boxed (value);
      self->__isset_personIdList = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_person_permits_args_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogGetPersonPermitsArgs *self = I_FACE_LOG_GET_PERSON_PERMITS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_PERMITS_ARGS_DEVICE_ID:
      g_value_set_int (value, self->deviceId);
      break;

    case PROP_I_FACE_LOG_GET_PERSON_PERMITS_ARGS_PERSON_ID_LIST:
      g_value_set_boxed (value, self->personIdList);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_person_permits_args_instance_init (IFaceLogGetPersonPermitsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->deviceId = 0;
  object->personIdList = g_array_new (0, 1, sizeof (gint32));
  object->__isset_personIdList = FALSE;
}

static void 
i_face_log_get_person_permits_args_finalize (GObject *object)
{
  IFaceLogGetPersonPermitsArgs *tobject = I_FACE_LOG_GET_PERSON_PERMITS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->personIdList != NULL)
  {
    g_array_unref (tobject->personIdList);
    tobject->personIdList = NULL;
  }
}

static void
i_face_log_get_person_permits_args_class_init (IFaceLogGetPersonPermitsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_person_permits_args_read;
  struct_class->write = i_face_log_get_person_permits_args_write;

  gobject_class->finalize = i_face_log_get_person_permits_args_finalize;
  gobject_class->get_property = i_face_log_get_person_permits_args_get_property;
  gobject_class->set_property = i_face_log_get_person_permits_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_PERMITS_ARGS_DEVICE_ID,
     g_param_spec_int ("deviceId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_PERMITS_ARGS_PERSON_ID_LIST,
     g_param_spec_boxed ("personIdList",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_person_permits_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPersonPermitsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_person_permits_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPersonPermitsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_person_permits_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPersonPermitsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPersonPermitsResultProperties
{
  PROP_I_FACE_LOG_GET_PERSON_PERMITS_RESULT_0,
  PROP_I_FACE_LOG_GET_PERSON_PERMITS_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_PERSON_PERMITS_RESULT_EX1
};

/* reads a i_face_log_get_person_permits_result object */
static gint32
i_face_log_get_person_permits_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPersonPermitsResult * this_object = I_FACE_LOG_GET_PERSON_PERMITS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              PermitBean * _elem72 = NULL;
              if ( _elem72 != NULL)
              {
                g_object_unref (_elem72);
              }
              _elem72 = g_object_new (TYPE_PERMIT_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem72), protocol, error)) < 0)
              {
                g_object_unref (_elem72);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem72);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_person_permits_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPersonPermitsResult * this_object = I_FACE_LOG_GET_PERSON_PERMITS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPersonPermitsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i73;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i73 = 0; i73 < (this_object->success ? this_object->success->len : 0); i73++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i73))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_person_permits_result_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogGetPersonPermitsResult *self = I_FACE_LOG_GET_PERSON_PERMITS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_PERMITS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_PERSON_PERMITS_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_person_permits_result_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogGetPersonPermitsResult *self = I_FACE_LOG_GET_PERSON_PERMITS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSON_PERMITS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_PERSON_PERMITS_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_person_permits_result_instance_init (IFaceLogGetPersonPermitsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_person_permits_result_finalize (GObject *object)
{
  IFaceLogGetPersonPermitsResult *tobject = I_FACE_LOG_GET_PERSON_PERMITS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_person_permits_result_class_init (IFaceLogGetPersonPermitsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_person_permits_result_read;
  struct_class->write = i_face_log_get_person_permits_result_write;

  gobject_class->finalize = i_face_log_get_person_permits_result_finalize;
  gobject_class->get_property = i_face_log_get_person_permits_result_get_property;
  gobject_class->set_property = i_face_log_get_person_permits_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_PERMITS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSON_PERMITS_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_person_permits_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPersonPermitsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_person_permits_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPersonPermitsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_person_permits_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPersonPermitsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPersonsArgsProperties
{
  PROP_I_FACE_LOG_GET_PERSONS_ARGS_0,
  PROP_I_FACE_LOG_GET_PERSONS_ARGS_ID_LIST
};

/* reads a i_face_log_get_persons_args object */
static gint32
i_face_log_get_persons_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPersonsArgs * this_object = I_FACE_LOG_GET_PERSONS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem74 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem74, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->idList, _elem74, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_idList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_persons_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPersonsArgs * this_object = I_FACE_LOG_GET_PERSONS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPersonsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "idList", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i75;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->idList ? this_object->idList->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i75 = 0; i75 < (this_object->idList ? this_object->idList->len : 0); i75++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->idList, gint32, i75)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_persons_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  IFaceLogGetPersonsArgs *self = I_FACE_LOG_GET_PERSONS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSONS_ARGS_ID_LIST:
      if (self->idList != NULL)
        g_array_unref (self->idList);
      self->idList = g_value_dup_boxed (value);
      self->__isset_idList = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_persons_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  IFaceLogGetPersonsArgs *self = I_FACE_LOG_GET_PERSONS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSONS_ARGS_ID_LIST:
      g_value_set_boxed (value, self->idList);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_persons_args_instance_init (IFaceLogGetPersonsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->idList = g_array_new (0, 1, sizeof (gint32));
  object->__isset_idList = FALSE;
}

static void 
i_face_log_get_persons_args_finalize (GObject *object)
{
  IFaceLogGetPersonsArgs *tobject = I_FACE_LOG_GET_PERSONS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->idList != NULL)
  {
    g_array_unref (tobject->idList);
    tobject->idList = NULL;
  }
}

static void
i_face_log_get_persons_args_class_init (IFaceLogGetPersonsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_persons_args_read;
  struct_class->write = i_face_log_get_persons_args_write;

  gobject_class->finalize = i_face_log_get_persons_args_finalize;
  gobject_class->get_property = i_face_log_get_persons_args_get_property;
  gobject_class->set_property = i_face_log_get_persons_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSONS_ARGS_ID_LIST,
     g_param_spec_boxed ("idList",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_persons_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPersonsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_persons_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPersonsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_persons_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPersonsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPersonsResultProperties
{
  PROP_I_FACE_LOG_GET_PERSONS_RESULT_0,
  PROP_I_FACE_LOG_GET_PERSONS_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_PERSONS_RESULT_EX1
};

/* reads a i_face_log_get_persons_result object */
static gint32
i_face_log_get_persons_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPersonsResult * this_object = I_FACE_LOG_GET_PERSONS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              PersonBean * _elem76 = NULL;
              if ( _elem76 != NULL)
              {
                g_object_unref (_elem76);
              }
              _elem76 = g_object_new (TYPE_PERSON_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem76), protocol, error)) < 0)
              {
                g_object_unref (_elem76);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem76);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_persons_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPersonsResult * this_object = I_FACE_LOG_GET_PERSONS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPersonsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i77;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i77 = 0; i77 < (this_object->success ? this_object->success->len : 0); i77++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i77))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_persons_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogGetPersonsResult *self = I_FACE_LOG_GET_PERSONS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSONS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_PERSONS_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_persons_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogGetPersonsResult *self = I_FACE_LOG_GET_PERSONS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSONS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_PERSONS_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_persons_result_instance_init (IFaceLogGetPersonsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_persons_result_finalize (GObject *object)
{
  IFaceLogGetPersonsResult *tobject = I_FACE_LOG_GET_PERSONS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_persons_result_class_init (IFaceLogGetPersonsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_persons_result_read;
  struct_class->write = i_face_log_get_persons_result_write;

  gobject_class->finalize = i_face_log_get_persons_result_finalize;
  gobject_class->get_property = i_face_log_get_persons_result_get_property;
  gobject_class->set_property = i_face_log_get_persons_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSONS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSONS_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_persons_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPersonsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_persons_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPersonsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_persons_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPersonsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPersonsOfGroupArgsProperties
{
  PROP_I_FACE_LOG_GET_PERSONS_OF_GROUP_ARGS_0,
  PROP_I_FACE_LOG_GET_PERSONS_OF_GROUP_ARGS_PERSON_GROUP_ID
};

/* reads a i_face_log_get_persons_of_group_args object */
static gint32
i_face_log_get_persons_of_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPersonsOfGroupArgs * this_object = I_FACE_LOG_GET_PERSONS_OF_GROUP_ARGS(object);
  gboolean isset_personGroupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_persons_of_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPersonsOfGroupArgs * this_object = I_FACE_LOG_GET_PERSONS_OF_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPersonsOfGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_persons_of_group_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogGetPersonsOfGroupArgs *self = I_FACE_LOG_GET_PERSONS_OF_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSONS_OF_GROUP_ARGS_PERSON_GROUP_ID:
      self->personGroupId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_persons_of_group_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogGetPersonsOfGroupArgs *self = I_FACE_LOG_GET_PERSONS_OF_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSONS_OF_GROUP_ARGS_PERSON_GROUP_ID:
      g_value_set_int (value, self->personGroupId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_persons_of_group_args_instance_init (IFaceLogGetPersonsOfGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personGroupId = 0;
}

static void 
i_face_log_get_persons_of_group_args_finalize (GObject *object)
{
  IFaceLogGetPersonsOfGroupArgs *tobject = I_FACE_LOG_GET_PERSONS_OF_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_get_persons_of_group_args_class_init (IFaceLogGetPersonsOfGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_persons_of_group_args_read;
  struct_class->write = i_face_log_get_persons_of_group_args_write;

  gobject_class->finalize = i_face_log_get_persons_of_group_args_finalize;
  gobject_class->get_property = i_face_log_get_persons_of_group_args_get_property;
  gobject_class->set_property = i_face_log_get_persons_of_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSONS_OF_GROUP_ARGS_PERSON_GROUP_ID,
     g_param_spec_int ("personGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_get_persons_of_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPersonsOfGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_persons_of_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPersonsOfGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_persons_of_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPersonsOfGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPersonsOfGroupResultProperties
{
  PROP_I_FACE_LOG_GET_PERSONS_OF_GROUP_RESULT_0,
  PROP_I_FACE_LOG_GET_PERSONS_OF_GROUP_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_PERSONS_OF_GROUP_RESULT_EX1
};

/* reads a i_face_log_get_persons_of_group_result object */
static gint32
i_face_log_get_persons_of_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPersonsOfGroupResult * this_object = I_FACE_LOG_GET_PERSONS_OF_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem78 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem78, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem78, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_persons_of_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPersonsOfGroupResult * this_object = I_FACE_LOG_GET_PERSONS_OF_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPersonsOfGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i79;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i79 = 0; i79 < (this_object->success ? this_object->success->len : 0); i79++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i79)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_persons_of_group_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogGetPersonsOfGroupResult *self = I_FACE_LOG_GET_PERSONS_OF_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSONS_OF_GROUP_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_PERSONS_OF_GROUP_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_persons_of_group_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogGetPersonsOfGroupResult *self = I_FACE_LOG_GET_PERSONS_OF_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PERSONS_OF_GROUP_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_PERSONS_OF_GROUP_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_persons_of_group_result_instance_init (IFaceLogGetPersonsOfGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_persons_of_group_result_finalize (GObject *object)
{
  IFaceLogGetPersonsOfGroupResult *tobject = I_FACE_LOG_GET_PERSONS_OF_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_persons_of_group_result_class_init (IFaceLogGetPersonsOfGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_persons_of_group_result_read;
  struct_class->write = i_face_log_get_persons_of_group_result_write;

  gobject_class->finalize = i_face_log_get_persons_of_group_result_finalize;
  gobject_class->get_property = i_face_log_get_persons_of_group_result_get_property;
  gobject_class->set_property = i_face_log_get_persons_of_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSONS_OF_GROUP_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PERSONS_OF_GROUP_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_persons_of_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPersonsOfGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_persons_of_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPersonsOfGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_persons_of_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPersonsOfGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPropertyArgsProperties
{
  PROP_I_FACE_LOG_GET_PROPERTY_ARGS_0,
  PROP_I_FACE_LOG_GET_PROPERTY_ARGS_KEY,
  PROP_I_FACE_LOG_GET_PROPERTY_ARGS_TOKEN
};

/* reads a i_face_log_get_property_args object */
static gint32
i_face_log_get_property_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPropertyArgs * this_object = I_FACE_LOG_GET_PROPERTY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->key, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_property_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPropertyArgs * this_object = I_FACE_LOG_GET_PROPERTY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPropertyArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->key, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_property_args_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogGetPropertyArgs *self = I_FACE_LOG_GET_PROPERTY_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PROPERTY_ARGS_KEY:
      if (self->key != NULL)
        g_free (self->key);
      self->key = g_value_dup_string (value);
      self->__isset_key = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_PROPERTY_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_property_args_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogGetPropertyArgs *self = I_FACE_LOG_GET_PROPERTY_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PROPERTY_ARGS_KEY:
      g_value_set_string (value, self->key);
      break;

    case PROP_I_FACE_LOG_GET_PROPERTY_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_property_args_instance_init (IFaceLogGetPropertyArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->key = NULL;
  object->__isset_key = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_get_property_args_finalize (GObject *object)
{
  IFaceLogGetPropertyArgs *tobject = I_FACE_LOG_GET_PROPERTY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->key != NULL)
  {
    g_free(tobject->key);
    tobject->key = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_get_property_args_class_init (IFaceLogGetPropertyArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_property_args_read;
  struct_class->write = i_face_log_get_property_args_write;

  gobject_class->finalize = i_face_log_get_property_args_finalize;
  gobject_class->get_property = i_face_log_get_property_args_get_property;
  gobject_class->set_property = i_face_log_get_property_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PROPERTY_ARGS_KEY,
     g_param_spec_string ("key",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PROPERTY_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_property_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPropertyArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_property_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPropertyArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_property_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPropertyArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetPropertyResultProperties
{
  PROP_I_FACE_LOG_GET_PROPERTY_RESULT_0,
  PROP_I_FACE_LOG_GET_PROPERTY_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_PROPERTY_RESULT_EX1
};

/* reads a i_face_log_get_property_result object */
static gint32
i_face_log_get_property_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetPropertyResult * this_object = I_FACE_LOG_GET_PROPERTY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_property_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetPropertyResult * this_object = I_FACE_LOG_GET_PROPERTY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetPropertyResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_property_result_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogGetPropertyResult *self = I_FACE_LOG_GET_PROPERTY_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PROPERTY_RESULT_SUCCESS:
      if (self->success != NULL)
        g_free (self->success);
      self->success = g_value_dup_string (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_PROPERTY_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_property_result_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogGetPropertyResult *self = I_FACE_LOG_GET_PROPERTY_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_PROPERTY_RESULT_SUCCESS:
      g_value_set_string (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_PROPERTY_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_property_result_instance_init (IFaceLogGetPropertyResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_property_result_finalize (GObject *object)
{
  IFaceLogGetPropertyResult *tobject = I_FACE_LOG_GET_PROPERTY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_property_result_class_init (IFaceLogGetPropertyResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_property_result_read;
  struct_class->write = i_face_log_get_property_result_write;

  gobject_class->finalize = i_face_log_get_property_result_finalize;
  gobject_class->get_property = i_face_log_get_property_result_get_property;
  gobject_class->set_property = i_face_log_get_property_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PROPERTY_RESULT_SUCCESS,
     g_param_spec_string ("success",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_PROPERTY_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_property_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetPropertyResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_property_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetPropertyResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_property_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetPropertyResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetRedisParametersArgsProperties
{
  PROP_I_FACE_LOG_GET_REDIS_PARAMETERS_ARGS_0,
  PROP_I_FACE_LOG_GET_REDIS_PARAMETERS_ARGS_TOKEN
};

/* reads a i_face_log_get_redis_parameters_args object */
static gint32
i_face_log_get_redis_parameters_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetRedisParametersArgs * this_object = I_FACE_LOG_GET_REDIS_PARAMETERS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_redis_parameters_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetRedisParametersArgs * this_object = I_FACE_LOG_GET_REDIS_PARAMETERS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetRedisParametersArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_redis_parameters_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogGetRedisParametersArgs *self = I_FACE_LOG_GET_REDIS_PARAMETERS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_REDIS_PARAMETERS_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_redis_parameters_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogGetRedisParametersArgs *self = I_FACE_LOG_GET_REDIS_PARAMETERS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_REDIS_PARAMETERS_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_redis_parameters_args_instance_init (IFaceLogGetRedisParametersArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_get_redis_parameters_args_finalize (GObject *object)
{
  IFaceLogGetRedisParametersArgs *tobject = I_FACE_LOG_GET_REDIS_PARAMETERS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_get_redis_parameters_args_class_init (IFaceLogGetRedisParametersArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_redis_parameters_args_read;
  struct_class->write = i_face_log_get_redis_parameters_args_write;

  gobject_class->finalize = i_face_log_get_redis_parameters_args_finalize;
  gobject_class->get_property = i_face_log_get_redis_parameters_args_get_property;
  gobject_class->set_property = i_face_log_get_redis_parameters_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_REDIS_PARAMETERS_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_redis_parameters_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetRedisParametersArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_redis_parameters_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetRedisParametersArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_redis_parameters_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetRedisParametersArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetRedisParametersResultProperties
{
  PROP_I_FACE_LOG_GET_REDIS_PARAMETERS_RESULT_0,
  PROP_I_FACE_LOG_GET_REDIS_PARAMETERS_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_REDIS_PARAMETERS_RESULT_EX1
};

/* reads a i_face_log_get_redis_parameters_result object */
static gint32
i_face_log_get_redis_parameters_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetRedisParametersResult * this_object = I_FACE_LOG_GET_REDIS_PARAMETERS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              MQParam key80;
              gchar * val81 = NULL;
              gint32 ecast82;
              if ((ret = thrift_protocol_read_i32 (protocol, &ecast82, error)) < 0)
                return -1;
              xfer += ret;
              key80 = (MQParam)ecast82;
              if (val81 != NULL)
              {
                g_free(val81);
                val81 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val81, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->success && key80)
                g_hash_table_insert ((GHashTable *)this_object->success, (gpointer) key80, (gpointer) val81);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_redis_parameters_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetRedisParametersResult * this_object = I_FACE_LOG_GET_REDIS_PARAMETERS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetRedisParametersResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_MAP, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      MQParam key83;
      gchar * val84 = NULL;
      GList *key_list = NULL, *iter = NULL;
      MQParam* keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_I32, T_STRING, this_object->success ? (gint32) g_hash_table_size ((GHashTable *) this_object->success) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->success)
        g_hash_table_foreach ((GHashTable *) this_object->success, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (MQParam, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (MQParam) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key83 = keys[i];
        val84 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->success), (gpointer) key83);

        if ((ret = thrift_protocol_write_i32 (protocol, (gint32)  key83, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val84, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_redis_parameters_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogGetRedisParametersResult *self = I_FACE_LOG_GET_REDIS_PARAMETERS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_REDIS_PARAMETERS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_hash_table_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_REDIS_PARAMETERS_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_redis_parameters_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogGetRedisParametersResult *self = I_FACE_LOG_GET_REDIS_PARAMETERS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_REDIS_PARAMETERS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_REDIS_PARAMETERS_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_redis_parameters_result_instance_init (IFaceLogGetRedisParametersResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_redis_parameters_result_finalize (GObject *object)
{
  IFaceLogGetRedisParametersResult *tobject = I_FACE_LOG_GET_REDIS_PARAMETERS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_hash_table_destroy (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_redis_parameters_result_class_init (IFaceLogGetRedisParametersResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_redis_parameters_result_read;
  struct_class->write = i_face_log_get_redis_parameters_result_write;

  gobject_class->finalize = i_face_log_get_redis_parameters_result_finalize;
  gobject_class->get_property = i_face_log_get_redis_parameters_result_get_property;
  gobject_class->set_property = i_face_log_get_redis_parameters_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_REDIS_PARAMETERS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_REDIS_PARAMETERS_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_redis_parameters_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetRedisParametersResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_redis_parameters_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetRedisParametersResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_redis_parameters_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetRedisParametersResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetServiceConfigArgsProperties
{
  PROP_I_FACE_LOG_GET_SERVICE_CONFIG_ARGS_0,
  PROP_I_FACE_LOG_GET_SERVICE_CONFIG_ARGS_TOKEN
};

/* reads a i_face_log_get_service_config_args object */
static gint32
i_face_log_get_service_config_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetServiceConfigArgs * this_object = I_FACE_LOG_GET_SERVICE_CONFIG_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_service_config_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetServiceConfigArgs * this_object = I_FACE_LOG_GET_SERVICE_CONFIG_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetServiceConfigArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_service_config_args_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogGetServiceConfigArgs *self = I_FACE_LOG_GET_SERVICE_CONFIG_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_SERVICE_CONFIG_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_service_config_args_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogGetServiceConfigArgs *self = I_FACE_LOG_GET_SERVICE_CONFIG_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_SERVICE_CONFIG_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_service_config_args_instance_init (IFaceLogGetServiceConfigArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_get_service_config_args_finalize (GObject *object)
{
  IFaceLogGetServiceConfigArgs *tobject = I_FACE_LOG_GET_SERVICE_CONFIG_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_get_service_config_args_class_init (IFaceLogGetServiceConfigArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_service_config_args_read;
  struct_class->write = i_face_log_get_service_config_args_write;

  gobject_class->finalize = i_face_log_get_service_config_args_finalize;
  gobject_class->get_property = i_face_log_get_service_config_args_get_property;
  gobject_class->set_property = i_face_log_get_service_config_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_SERVICE_CONFIG_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_service_config_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetServiceConfigArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_service_config_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetServiceConfigArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_service_config_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetServiceConfigArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetServiceConfigResultProperties
{
  PROP_I_FACE_LOG_GET_SERVICE_CONFIG_RESULT_0,
  PROP_I_FACE_LOG_GET_SERVICE_CONFIG_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_SERVICE_CONFIG_RESULT_EX1
};

/* reads a i_face_log_get_service_config_result object */
static gint32
i_face_log_get_service_config_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetServiceConfigResult * this_object = I_FACE_LOG_GET_SERVICE_CONFIG_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key85 = NULL;
              gchar * val86 = NULL;
              if (key85 != NULL)
              {
                g_free(key85);
                key85 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key85, error)) < 0)
                return -1;
              xfer += ret;
              if (val86 != NULL)
              {
                g_free(val86);
                val86 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val86, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->success && key85)
                g_hash_table_insert ((GHashTable *)this_object->success, (gpointer) key85, (gpointer) val86);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_service_config_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetServiceConfigResult * this_object = I_FACE_LOG_GET_SERVICE_CONFIG_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetServiceConfigResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_MAP, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key87 = NULL;
      gchar * val88 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->success ? (gint32) g_hash_table_size ((GHashTable *) this_object->success) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->success)
        g_hash_table_foreach ((GHashTable *) this_object->success, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key87 = keys[i];
        val88 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->success), (gpointer) key87);

        if ((ret = thrift_protocol_write_string (protocol,  key87, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val88, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_service_config_result_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogGetServiceConfigResult *self = I_FACE_LOG_GET_SERVICE_CONFIG_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_SERVICE_CONFIG_RESULT_SUCCESS:
      if (self->success != NULL)
        g_hash_table_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_SERVICE_CONFIG_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_service_config_result_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogGetServiceConfigResult *self = I_FACE_LOG_GET_SERVICE_CONFIG_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_SERVICE_CONFIG_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_SERVICE_CONFIG_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_service_config_result_instance_init (IFaceLogGetServiceConfigResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_service_config_result_finalize (GObject *object)
{
  IFaceLogGetServiceConfigResult *tobject = I_FACE_LOG_GET_SERVICE_CONFIG_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_hash_table_destroy (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_service_config_result_class_init (IFaceLogGetServiceConfigResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_service_config_result_read;
  struct_class->write = i_face_log_get_service_config_result_write;

  gobject_class->finalize = i_face_log_get_service_config_result_finalize;
  gobject_class->get_property = i_face_log_get_service_config_result_get_property;
  gobject_class->set_property = i_face_log_get_service_config_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_SERVICE_CONFIG_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_SERVICE_CONFIG_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_service_config_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetServiceConfigResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_service_config_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetServiceConfigResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_service_config_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetServiceConfigResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetSubDeviceGroupArgsProperties
{
  PROP_I_FACE_LOG_GET_SUB_DEVICE_GROUP_ARGS_0,
  PROP_I_FACE_LOG_GET_SUB_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID
};

/* reads a i_face_log_get_sub_device_group_args object */
static gint32
i_face_log_get_sub_device_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetSubDeviceGroupArgs * this_object = I_FACE_LOG_GET_SUB_DEVICE_GROUP_ARGS(object);
  gboolean isset_deviceGroupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_deviceGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_deviceGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_sub_device_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetSubDeviceGroupArgs * this_object = I_FACE_LOG_GET_SUB_DEVICE_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetSubDeviceGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_sub_device_group_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogGetSubDeviceGroupArgs *self = I_FACE_LOG_GET_SUB_DEVICE_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_SUB_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID:
      self->deviceGroupId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_sub_device_group_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogGetSubDeviceGroupArgs *self = I_FACE_LOG_GET_SUB_DEVICE_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_SUB_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID:
      g_value_set_int (value, self->deviceGroupId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_sub_device_group_args_instance_init (IFaceLogGetSubDeviceGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->deviceGroupId = 0;
}

static void 
i_face_log_get_sub_device_group_args_finalize (GObject *object)
{
  IFaceLogGetSubDeviceGroupArgs *tobject = I_FACE_LOG_GET_SUB_DEVICE_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_get_sub_device_group_args_class_init (IFaceLogGetSubDeviceGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_sub_device_group_args_read;
  struct_class->write = i_face_log_get_sub_device_group_args_write;

  gobject_class->finalize = i_face_log_get_sub_device_group_args_finalize;
  gobject_class->get_property = i_face_log_get_sub_device_group_args_get_property;
  gobject_class->set_property = i_face_log_get_sub_device_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_SUB_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID,
     g_param_spec_int ("deviceGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_get_sub_device_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetSubDeviceGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_sub_device_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetSubDeviceGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_sub_device_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetSubDeviceGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetSubDeviceGroupResultProperties
{
  PROP_I_FACE_LOG_GET_SUB_DEVICE_GROUP_RESULT_0,
  PROP_I_FACE_LOG_GET_SUB_DEVICE_GROUP_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_SUB_DEVICE_GROUP_RESULT_EX1
};

/* reads a i_face_log_get_sub_device_group_result object */
static gint32
i_face_log_get_sub_device_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetSubDeviceGroupResult * this_object = I_FACE_LOG_GET_SUB_DEVICE_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem89 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem89, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem89, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_sub_device_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetSubDeviceGroupResult * this_object = I_FACE_LOG_GET_SUB_DEVICE_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetSubDeviceGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i90;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i90 = 0; i90 < (this_object->success ? this_object->success->len : 0); i90++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i90)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_sub_device_group_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogGetSubDeviceGroupResult *self = I_FACE_LOG_GET_SUB_DEVICE_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_SUB_DEVICE_GROUP_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_SUB_DEVICE_GROUP_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_sub_device_group_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogGetSubDeviceGroupResult *self = I_FACE_LOG_GET_SUB_DEVICE_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_SUB_DEVICE_GROUP_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_SUB_DEVICE_GROUP_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_sub_device_group_result_instance_init (IFaceLogGetSubDeviceGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_sub_device_group_result_finalize (GObject *object)
{
  IFaceLogGetSubDeviceGroupResult *tobject = I_FACE_LOG_GET_SUB_DEVICE_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_sub_device_group_result_class_init (IFaceLogGetSubDeviceGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_sub_device_group_result_read;
  struct_class->write = i_face_log_get_sub_device_group_result_write;

  gobject_class->finalize = i_face_log_get_sub_device_group_result_finalize;
  gobject_class->get_property = i_face_log_get_sub_device_group_result_get_property;
  gobject_class->set_property = i_face_log_get_sub_device_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_SUB_DEVICE_GROUP_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_SUB_DEVICE_GROUP_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_sub_device_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetSubDeviceGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_sub_device_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetSubDeviceGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_sub_device_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetSubDeviceGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetSubPersonGroupArgsProperties
{
  PROP_I_FACE_LOG_GET_SUB_PERSON_GROUP_ARGS_0,
  PROP_I_FACE_LOG_GET_SUB_PERSON_GROUP_ARGS_PERSON_GROUP_ID
};

/* reads a i_face_log_get_sub_person_group_args object */
static gint32
i_face_log_get_sub_person_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetSubPersonGroupArgs * this_object = I_FACE_LOG_GET_SUB_PERSON_GROUP_ARGS(object);
  gboolean isset_personGroupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_get_sub_person_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetSubPersonGroupArgs * this_object = I_FACE_LOG_GET_SUB_PERSON_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetSubPersonGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_sub_person_group_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogGetSubPersonGroupArgs *self = I_FACE_LOG_GET_SUB_PERSON_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_SUB_PERSON_GROUP_ARGS_PERSON_GROUP_ID:
      self->personGroupId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_sub_person_group_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogGetSubPersonGroupArgs *self = I_FACE_LOG_GET_SUB_PERSON_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_SUB_PERSON_GROUP_ARGS_PERSON_GROUP_ID:
      g_value_set_int (value, self->personGroupId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_sub_person_group_args_instance_init (IFaceLogGetSubPersonGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personGroupId = 0;
}

static void 
i_face_log_get_sub_person_group_args_finalize (GObject *object)
{
  IFaceLogGetSubPersonGroupArgs *tobject = I_FACE_LOG_GET_SUB_PERSON_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_get_sub_person_group_args_class_init (IFaceLogGetSubPersonGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_sub_person_group_args_read;
  struct_class->write = i_face_log_get_sub_person_group_args_write;

  gobject_class->finalize = i_face_log_get_sub_person_group_args_finalize;
  gobject_class->get_property = i_face_log_get_sub_person_group_args_get_property;
  gobject_class->set_property = i_face_log_get_sub_person_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_SUB_PERSON_GROUP_ARGS_PERSON_GROUP_ID,
     g_param_spec_int ("personGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_get_sub_person_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetSubPersonGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_sub_person_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetSubPersonGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_sub_person_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetSubPersonGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogGetSubPersonGroupResultProperties
{
  PROP_I_FACE_LOG_GET_SUB_PERSON_GROUP_RESULT_0,
  PROP_I_FACE_LOG_GET_SUB_PERSON_GROUP_RESULT_SUCCESS,
  PROP_I_FACE_LOG_GET_SUB_PERSON_GROUP_RESULT_EX1
};

/* reads a i_face_log_get_sub_person_group_result object */
static gint32
i_face_log_get_sub_person_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogGetSubPersonGroupResult * this_object = I_FACE_LOG_GET_SUB_PERSON_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem91 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem91, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem91, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_get_sub_person_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogGetSubPersonGroupResult * this_object = I_FACE_LOG_GET_SUB_PERSON_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogGetSubPersonGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i92;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i92 = 0; i92 < (this_object->success ? this_object->success->len : 0); i92++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i92)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_get_sub_person_group_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogGetSubPersonGroupResult *self = I_FACE_LOG_GET_SUB_PERSON_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_SUB_PERSON_GROUP_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_GET_SUB_PERSON_GROUP_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_get_sub_person_group_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogGetSubPersonGroupResult *self = I_FACE_LOG_GET_SUB_PERSON_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_GET_SUB_PERSON_GROUP_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_GET_SUB_PERSON_GROUP_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_get_sub_person_group_result_instance_init (IFaceLogGetSubPersonGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_get_sub_person_group_result_finalize (GObject *object)
{
  IFaceLogGetSubPersonGroupResult *tobject = I_FACE_LOG_GET_SUB_PERSON_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_get_sub_person_group_result_class_init (IFaceLogGetSubPersonGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_get_sub_person_group_result_read;
  struct_class->write = i_face_log_get_sub_person_group_result_write;

  gobject_class->finalize = i_face_log_get_sub_person_group_result_finalize;
  gobject_class->get_property = i_face_log_get_sub_person_group_result_get_property;
  gobject_class->set_property = i_face_log_get_sub_person_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_SUB_PERSON_GROUP_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_GET_SUB_PERSON_GROUP_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_get_sub_person_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogGetSubPersonGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_get_sub_person_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogGetSubPersonGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_get_sub_person_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogGetSubPersonGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogIsDisableArgsProperties
{
  PROP_I_FACE_LOG_IS_DISABLE_ARGS_0,
  PROP_I_FACE_LOG_IS_DISABLE_ARGS_PERSON_ID
};

/* reads a i_face_log_is_disable_args object */
static gint32
i_face_log_is_disable_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogIsDisableArgs * this_object = I_FACE_LOG_IS_DISABLE_ARGS(object);
  gboolean isset_personId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_is_disable_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogIsDisableArgs * this_object = I_FACE_LOG_IS_DISABLE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogIsDisableArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_is_disable_args_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  IFaceLogIsDisableArgs *self = I_FACE_LOG_IS_DISABLE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_DISABLE_ARGS_PERSON_ID:
      self->personId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_is_disable_args_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  IFaceLogIsDisableArgs *self = I_FACE_LOG_IS_DISABLE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_DISABLE_ARGS_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_is_disable_args_instance_init (IFaceLogIsDisableArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personId = 0;
}

static void 
i_face_log_is_disable_args_finalize (GObject *object)
{
  IFaceLogIsDisableArgs *tobject = I_FACE_LOG_IS_DISABLE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_is_disable_args_class_init (IFaceLogIsDisableArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_is_disable_args_read;
  struct_class->write = i_face_log_is_disable_args_write;

  gobject_class->finalize = i_face_log_is_disable_args_finalize;
  gobject_class->get_property = i_face_log_is_disable_args_get_property;
  gobject_class->set_property = i_face_log_is_disable_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_DISABLE_ARGS_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_is_disable_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogIsDisableArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_is_disable_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogIsDisableArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_is_disable_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogIsDisableArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogIsDisableResultProperties
{
  PROP_I_FACE_LOG_IS_DISABLE_RESULT_0,
  PROP_I_FACE_LOG_IS_DISABLE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_IS_DISABLE_RESULT_EX1
};

/* reads a i_face_log_is_disable_result object */
static gint32
i_face_log_is_disable_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogIsDisableResult * this_object = I_FACE_LOG_IS_DISABLE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_is_disable_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogIsDisableResult * this_object = I_FACE_LOG_IS_DISABLE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogIsDisableResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_is_disable_result_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogIsDisableResult *self = I_FACE_LOG_IS_DISABLE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_DISABLE_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_IS_DISABLE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_is_disable_result_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogIsDisableResult *self = I_FACE_LOG_IS_DISABLE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_DISABLE_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_I_FACE_LOG_IS_DISABLE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_is_disable_result_instance_init (IFaceLogIsDisableResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_is_disable_result_finalize (GObject *object)
{
  IFaceLogIsDisableResult *tobject = I_FACE_LOG_IS_DISABLE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_is_disable_result_class_init (IFaceLogIsDisableResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_is_disable_result_read;
  struct_class->write = i_face_log_is_disable_result_write;

  gobject_class->finalize = i_face_log_is_disable_result_finalize;
  gobject_class->get_property = i_face_log_is_disable_result_get_property;
  gobject_class->set_property = i_face_log_is_disable_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_DISABLE_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_DISABLE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_is_disable_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogIsDisableResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_is_disable_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogIsDisableResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_is_disable_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogIsDisableResultType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a i_face_log_is_local_args object */
static gint32
i_face_log_is_local_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogIsLocalArgs * this_object = I_FACE_LOG_IS_LOCAL_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_is_local_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogIsLocalArgs * this_object = I_FACE_LOG_IS_LOCAL_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogIsLocalArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
i_face_log_is_local_args_instance_init (IFaceLogIsLocalArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
i_face_log_is_local_args_finalize (GObject *object)
{
  IFaceLogIsLocalArgs *tobject = I_FACE_LOG_IS_LOCAL_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_is_local_args_class_init (IFaceLogIsLocalArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_is_local_args_read;
  struct_class->write = i_face_log_is_local_args_write;

  gobject_class->finalize = i_face_log_is_local_args_finalize;
}

GType
i_face_log_is_local_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogIsLocalArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_is_local_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogIsLocalArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_is_local_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogIsLocalArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogIsLocalResultProperties
{
  PROP_I_FACE_LOG_IS_LOCAL_RESULT_0,
  PROP_I_FACE_LOG_IS_LOCAL_RESULT_SUCCESS,
  PROP_I_FACE_LOG_IS_LOCAL_RESULT_EX1
};

/* reads a i_face_log_is_local_result object */
static gint32
i_face_log_is_local_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogIsLocalResult * this_object = I_FACE_LOG_IS_LOCAL_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_is_local_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogIsLocalResult * this_object = I_FACE_LOG_IS_LOCAL_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogIsLocalResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_is_local_result_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  IFaceLogIsLocalResult *self = I_FACE_LOG_IS_LOCAL_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_LOCAL_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_IS_LOCAL_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_is_local_result_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  IFaceLogIsLocalResult *self = I_FACE_LOG_IS_LOCAL_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_LOCAL_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_I_FACE_LOG_IS_LOCAL_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_is_local_result_instance_init (IFaceLogIsLocalResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_is_local_result_finalize (GObject *object)
{
  IFaceLogIsLocalResult *tobject = I_FACE_LOG_IS_LOCAL_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_is_local_result_class_init (IFaceLogIsLocalResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_is_local_result_read;
  struct_class->write = i_face_log_is_local_result_write;

  gobject_class->finalize = i_face_log_is_local_result_finalize;
  gobject_class->get_property = i_face_log_is_local_result_get_property;
  gobject_class->set_property = i_face_log_is_local_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_LOCAL_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_LOCAL_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_is_local_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogIsLocalResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_is_local_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogIsLocalResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_is_local_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogIsLocalResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogIsValidAckChannelArgsProperties
{
  PROP_I_FACE_LOG_IS_VALID_ACK_CHANNEL_ARGS_0,
  PROP_I_FACE_LOG_IS_VALID_ACK_CHANNEL_ARGS_ACK_CHANNEL
};

/* reads a i_face_log_is_valid_ack_channel_args object */
static gint32
i_face_log_is_valid_ack_channel_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogIsValidAckChannelArgs * this_object = I_FACE_LOG_IS_VALID_ACK_CHANNEL_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->ackChannel != NULL)
          {
            g_free(this_object->ackChannel);
            this_object->ackChannel = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->ackChannel, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ackChannel = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_is_valid_ack_channel_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogIsValidAckChannelArgs * this_object = I_FACE_LOG_IS_VALID_ACK_CHANNEL_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogIsValidAckChannelArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ackChannel", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->ackChannel, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_is_valid_ack_channel_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogIsValidAckChannelArgs *self = I_FACE_LOG_IS_VALID_ACK_CHANNEL_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_ACK_CHANNEL_ARGS_ACK_CHANNEL:
      if (self->ackChannel != NULL)
        g_free (self->ackChannel);
      self->ackChannel = g_value_dup_string (value);
      self->__isset_ackChannel = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_is_valid_ack_channel_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogIsValidAckChannelArgs *self = I_FACE_LOG_IS_VALID_ACK_CHANNEL_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_ACK_CHANNEL_ARGS_ACK_CHANNEL:
      g_value_set_string (value, self->ackChannel);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_is_valid_ack_channel_args_instance_init (IFaceLogIsValidAckChannelArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ackChannel = NULL;
  object->__isset_ackChannel = FALSE;
}

static void 
i_face_log_is_valid_ack_channel_args_finalize (GObject *object)
{
  IFaceLogIsValidAckChannelArgs *tobject = I_FACE_LOG_IS_VALID_ACK_CHANNEL_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ackChannel != NULL)
  {
    g_free(tobject->ackChannel);
    tobject->ackChannel = NULL;
  }
}

static void
i_face_log_is_valid_ack_channel_args_class_init (IFaceLogIsValidAckChannelArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_is_valid_ack_channel_args_read;
  struct_class->write = i_face_log_is_valid_ack_channel_args_write;

  gobject_class->finalize = i_face_log_is_valid_ack_channel_args_finalize;
  gobject_class->get_property = i_face_log_is_valid_ack_channel_args_get_property;
  gobject_class->set_property = i_face_log_is_valid_ack_channel_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_ACK_CHANNEL_ARGS_ACK_CHANNEL,
     g_param_spec_string ("ackChannel",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_is_valid_ack_channel_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogIsValidAckChannelArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_is_valid_ack_channel_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogIsValidAckChannelArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_is_valid_ack_channel_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogIsValidAckChannelArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogIsValidAckChannelResultProperties
{
  PROP_I_FACE_LOG_IS_VALID_ACK_CHANNEL_RESULT_0,
  PROP_I_FACE_LOG_IS_VALID_ACK_CHANNEL_RESULT_SUCCESS,
  PROP_I_FACE_LOG_IS_VALID_ACK_CHANNEL_RESULT_EX1
};

/* reads a i_face_log_is_valid_ack_channel_result object */
static gint32
i_face_log_is_valid_ack_channel_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogIsValidAckChannelResult * this_object = I_FACE_LOG_IS_VALID_ACK_CHANNEL_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_is_valid_ack_channel_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogIsValidAckChannelResult * this_object = I_FACE_LOG_IS_VALID_ACK_CHANNEL_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogIsValidAckChannelResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_is_valid_ack_channel_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogIsValidAckChannelResult *self = I_FACE_LOG_IS_VALID_ACK_CHANNEL_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_ACK_CHANNEL_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_IS_VALID_ACK_CHANNEL_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_is_valid_ack_channel_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogIsValidAckChannelResult *self = I_FACE_LOG_IS_VALID_ACK_CHANNEL_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_ACK_CHANNEL_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_I_FACE_LOG_IS_VALID_ACK_CHANNEL_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_is_valid_ack_channel_result_instance_init (IFaceLogIsValidAckChannelResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_is_valid_ack_channel_result_finalize (GObject *object)
{
  IFaceLogIsValidAckChannelResult *tobject = I_FACE_LOG_IS_VALID_ACK_CHANNEL_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_is_valid_ack_channel_result_class_init (IFaceLogIsValidAckChannelResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_is_valid_ack_channel_result_read;
  struct_class->write = i_face_log_is_valid_ack_channel_result_write;

  gobject_class->finalize = i_face_log_is_valid_ack_channel_result_finalize;
  gobject_class->get_property = i_face_log_is_valid_ack_channel_result_get_property;
  gobject_class->set_property = i_face_log_is_valid_ack_channel_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_ACK_CHANNEL_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_ACK_CHANNEL_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_is_valid_ack_channel_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogIsValidAckChannelResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_is_valid_ack_channel_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogIsValidAckChannelResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_is_valid_ack_channel_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogIsValidAckChannelResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogIsValidCmdSnArgsProperties
{
  PROP_I_FACE_LOG_IS_VALID_CMD_SN_ARGS_0,
  PROP_I_FACE_LOG_IS_VALID_CMD_SN_ARGS_CMD_SN
};

/* reads a i_face_log_is_valid_cmd_sn_args object */
static gint32
i_face_log_is_valid_cmd_sn_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogIsValidCmdSnArgs * this_object = I_FACE_LOG_IS_VALID_CMD_SN_ARGS(object);
  gboolean isset_cmdSn = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->cmdSn, error)) < 0)
            return -1;
          xfer += ret;
          isset_cmdSn = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_cmdSn)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_is_valid_cmd_sn_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogIsValidCmdSnArgs * this_object = I_FACE_LOG_IS_VALID_CMD_SN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogIsValidCmdSnArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cmdSn", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->cmdSn, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_is_valid_cmd_sn_args_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogIsValidCmdSnArgs *self = I_FACE_LOG_IS_VALID_CMD_SN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_CMD_SN_ARGS_CMD_SN:
      self->cmdSn = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_is_valid_cmd_sn_args_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogIsValidCmdSnArgs *self = I_FACE_LOG_IS_VALID_CMD_SN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_CMD_SN_ARGS_CMD_SN:
      g_value_set_int (value, self->cmdSn);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_is_valid_cmd_sn_args_instance_init (IFaceLogIsValidCmdSnArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->cmdSn = 0;
}

static void 
i_face_log_is_valid_cmd_sn_args_finalize (GObject *object)
{
  IFaceLogIsValidCmdSnArgs *tobject = I_FACE_LOG_IS_VALID_CMD_SN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_is_valid_cmd_sn_args_class_init (IFaceLogIsValidCmdSnArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_is_valid_cmd_sn_args_read;
  struct_class->write = i_face_log_is_valid_cmd_sn_args_write;

  gobject_class->finalize = i_face_log_is_valid_cmd_sn_args_finalize;
  gobject_class->get_property = i_face_log_is_valid_cmd_sn_args_get_property;
  gobject_class->set_property = i_face_log_is_valid_cmd_sn_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_CMD_SN_ARGS_CMD_SN,
     g_param_spec_int ("cmdSn",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_is_valid_cmd_sn_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogIsValidCmdSnArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_is_valid_cmd_sn_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogIsValidCmdSnArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_is_valid_cmd_sn_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogIsValidCmdSnArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogIsValidCmdSnResultProperties
{
  PROP_I_FACE_LOG_IS_VALID_CMD_SN_RESULT_0,
  PROP_I_FACE_LOG_IS_VALID_CMD_SN_RESULT_SUCCESS,
  PROP_I_FACE_LOG_IS_VALID_CMD_SN_RESULT_EX1
};

/* reads a i_face_log_is_valid_cmd_sn_result object */
static gint32
i_face_log_is_valid_cmd_sn_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogIsValidCmdSnResult * this_object = I_FACE_LOG_IS_VALID_CMD_SN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_is_valid_cmd_sn_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogIsValidCmdSnResult * this_object = I_FACE_LOG_IS_VALID_CMD_SN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogIsValidCmdSnResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_is_valid_cmd_sn_result_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogIsValidCmdSnResult *self = I_FACE_LOG_IS_VALID_CMD_SN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_CMD_SN_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_IS_VALID_CMD_SN_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_is_valid_cmd_sn_result_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogIsValidCmdSnResult *self = I_FACE_LOG_IS_VALID_CMD_SN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_CMD_SN_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_I_FACE_LOG_IS_VALID_CMD_SN_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_is_valid_cmd_sn_result_instance_init (IFaceLogIsValidCmdSnResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_is_valid_cmd_sn_result_finalize (GObject *object)
{
  IFaceLogIsValidCmdSnResult *tobject = I_FACE_LOG_IS_VALID_CMD_SN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_is_valid_cmd_sn_result_class_init (IFaceLogIsValidCmdSnResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_is_valid_cmd_sn_result_read;
  struct_class->write = i_face_log_is_valid_cmd_sn_result_write;

  gobject_class->finalize = i_face_log_is_valid_cmd_sn_result_finalize;
  gobject_class->get_property = i_face_log_is_valid_cmd_sn_result_get_property;
  gobject_class->set_property = i_face_log_is_valid_cmd_sn_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_CMD_SN_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_CMD_SN_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_is_valid_cmd_sn_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogIsValidCmdSnResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_is_valid_cmd_sn_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogIsValidCmdSnResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_is_valid_cmd_sn_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogIsValidCmdSnResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogIsValidDeviceTokenArgsProperties
{
  PROP_I_FACE_LOG_IS_VALID_DEVICE_TOKEN_ARGS_0,
  PROP_I_FACE_LOG_IS_VALID_DEVICE_TOKEN_ARGS_TOKEN
};

/* reads a i_face_log_is_valid_device_token_args object */
static gint32
i_face_log_is_valid_device_token_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogIsValidDeviceTokenArgs * this_object = I_FACE_LOG_IS_VALID_DEVICE_TOKEN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_is_valid_device_token_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogIsValidDeviceTokenArgs * this_object = I_FACE_LOG_IS_VALID_DEVICE_TOKEN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogIsValidDeviceTokenArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_is_valid_device_token_args_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogIsValidDeviceTokenArgs *self = I_FACE_LOG_IS_VALID_DEVICE_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_DEVICE_TOKEN_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_is_valid_device_token_args_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogIsValidDeviceTokenArgs *self = I_FACE_LOG_IS_VALID_DEVICE_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_DEVICE_TOKEN_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_is_valid_device_token_args_instance_init (IFaceLogIsValidDeviceTokenArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_is_valid_device_token_args_finalize (GObject *object)
{
  IFaceLogIsValidDeviceTokenArgs *tobject = I_FACE_LOG_IS_VALID_DEVICE_TOKEN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_is_valid_device_token_args_class_init (IFaceLogIsValidDeviceTokenArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_is_valid_device_token_args_read;
  struct_class->write = i_face_log_is_valid_device_token_args_write;

  gobject_class->finalize = i_face_log_is_valid_device_token_args_finalize;
  gobject_class->get_property = i_face_log_is_valid_device_token_args_get_property;
  gobject_class->set_property = i_face_log_is_valid_device_token_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_DEVICE_TOKEN_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_is_valid_device_token_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogIsValidDeviceTokenArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_is_valid_device_token_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogIsValidDeviceTokenArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_is_valid_device_token_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogIsValidDeviceTokenArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogIsValidDeviceTokenResultProperties
{
  PROP_I_FACE_LOG_IS_VALID_DEVICE_TOKEN_RESULT_0,
  PROP_I_FACE_LOG_IS_VALID_DEVICE_TOKEN_RESULT_SUCCESS,
  PROP_I_FACE_LOG_IS_VALID_DEVICE_TOKEN_RESULT_EX1
};

/* reads a i_face_log_is_valid_device_token_result object */
static gint32
i_face_log_is_valid_device_token_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogIsValidDeviceTokenResult * this_object = I_FACE_LOG_IS_VALID_DEVICE_TOKEN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_is_valid_device_token_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogIsValidDeviceTokenResult * this_object = I_FACE_LOG_IS_VALID_DEVICE_TOKEN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogIsValidDeviceTokenResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_is_valid_device_token_result_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  IFaceLogIsValidDeviceTokenResult *self = I_FACE_LOG_IS_VALID_DEVICE_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_DEVICE_TOKEN_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_IS_VALID_DEVICE_TOKEN_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_is_valid_device_token_result_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  IFaceLogIsValidDeviceTokenResult *self = I_FACE_LOG_IS_VALID_DEVICE_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_DEVICE_TOKEN_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_I_FACE_LOG_IS_VALID_DEVICE_TOKEN_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_is_valid_device_token_result_instance_init (IFaceLogIsValidDeviceTokenResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_is_valid_device_token_result_finalize (GObject *object)
{
  IFaceLogIsValidDeviceTokenResult *tobject = I_FACE_LOG_IS_VALID_DEVICE_TOKEN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_is_valid_device_token_result_class_init (IFaceLogIsValidDeviceTokenResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_is_valid_device_token_result_read;
  struct_class->write = i_face_log_is_valid_device_token_result_write;

  gobject_class->finalize = i_face_log_is_valid_device_token_result_finalize;
  gobject_class->get_property = i_face_log_is_valid_device_token_result_get_property;
  gobject_class->set_property = i_face_log_is_valid_device_token_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_DEVICE_TOKEN_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_DEVICE_TOKEN_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_is_valid_device_token_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogIsValidDeviceTokenResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_is_valid_device_token_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogIsValidDeviceTokenResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_is_valid_device_token_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogIsValidDeviceTokenResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogIsValidPasswordArgsProperties
{
  PROP_I_FACE_LOG_IS_VALID_PASSWORD_ARGS_0,
  PROP_I_FACE_LOG_IS_VALID_PASSWORD_ARGS_USER_ID,
  PROP_I_FACE_LOG_IS_VALID_PASSWORD_ARGS_PASSWORD,
  PROP_I_FACE_LOG_IS_VALID_PASSWORD_ARGS_IS_MD5
};

/* reads a i_face_log_is_valid_password_args object */
static gint32
i_face_log_is_valid_password_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogIsValidPasswordArgs * this_object = I_FACE_LOG_IS_VALID_PASSWORD_ARGS(object);
  gboolean isset_isMd5 = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->userId != NULL)
          {
            g_free(this_object->userId);
            this_object->userId = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->userId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_userId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->password != NULL)
          {
            g_free(this_object->password);
            this_object->password = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->password, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_password = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->isMd5, error)) < 0)
            return -1;
          xfer += ret;
          isset_isMd5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_isMd5)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_is_valid_password_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogIsValidPasswordArgs * this_object = I_FACE_LOG_IS_VALID_PASSWORD_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogIsValidPasswordArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "userId", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->userId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "password", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->password, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "isMd5", T_BOOL, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->isMd5, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_is_valid_password_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogIsValidPasswordArgs *self = I_FACE_LOG_IS_VALID_PASSWORD_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_PASSWORD_ARGS_USER_ID:
      if (self->userId != NULL)
        g_free (self->userId);
      self->userId = g_value_dup_string (value);
      self->__isset_userId = TRUE;
      break;

    case PROP_I_FACE_LOG_IS_VALID_PASSWORD_ARGS_PASSWORD:
      if (self->password != NULL)
        g_free (self->password);
      self->password = g_value_dup_string (value);
      self->__isset_password = TRUE;
      break;

    case PROP_I_FACE_LOG_IS_VALID_PASSWORD_ARGS_IS_MD5:
      self->isMd5 = g_value_get_boolean (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_is_valid_password_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogIsValidPasswordArgs *self = I_FACE_LOG_IS_VALID_PASSWORD_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_PASSWORD_ARGS_USER_ID:
      g_value_set_string (value, self->userId);
      break;

    case PROP_I_FACE_LOG_IS_VALID_PASSWORD_ARGS_PASSWORD:
      g_value_set_string (value, self->password);
      break;

    case PROP_I_FACE_LOG_IS_VALID_PASSWORD_ARGS_IS_MD5:
      g_value_set_boolean (value, self->isMd5);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_is_valid_password_args_instance_init (IFaceLogIsValidPasswordArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->userId = NULL;
  object->__isset_userId = FALSE;
  object->password = NULL;
  object->__isset_password = FALSE;
  object->isMd5 = 0;
}

static void 
i_face_log_is_valid_password_args_finalize (GObject *object)
{
  IFaceLogIsValidPasswordArgs *tobject = I_FACE_LOG_IS_VALID_PASSWORD_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->userId != NULL)
  {
    g_free(tobject->userId);
    tobject->userId = NULL;
  }
  if (tobject->password != NULL)
  {
    g_free(tobject->password);
    tobject->password = NULL;
  }
}

static void
i_face_log_is_valid_password_args_class_init (IFaceLogIsValidPasswordArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_is_valid_password_args_read;
  struct_class->write = i_face_log_is_valid_password_args_write;

  gobject_class->finalize = i_face_log_is_valid_password_args_finalize;
  gobject_class->get_property = i_face_log_is_valid_password_args_get_property;
  gobject_class->set_property = i_face_log_is_valid_password_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_PASSWORD_ARGS_USER_ID,
     g_param_spec_string ("userId",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_PASSWORD_ARGS_PASSWORD,
     g_param_spec_string ("password",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_PASSWORD_ARGS_IS_MD5,
     g_param_spec_boolean ("isMd5",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));
}

GType
i_face_log_is_valid_password_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogIsValidPasswordArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_is_valid_password_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogIsValidPasswordArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_is_valid_password_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogIsValidPasswordArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogIsValidPasswordResultProperties
{
  PROP_I_FACE_LOG_IS_VALID_PASSWORD_RESULT_0,
  PROP_I_FACE_LOG_IS_VALID_PASSWORD_RESULT_SUCCESS,
  PROP_I_FACE_LOG_IS_VALID_PASSWORD_RESULT_EX1
};

/* reads a i_face_log_is_valid_password_result object */
static gint32
i_face_log_is_valid_password_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogIsValidPasswordResult * this_object = I_FACE_LOG_IS_VALID_PASSWORD_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_is_valid_password_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogIsValidPasswordResult * this_object = I_FACE_LOG_IS_VALID_PASSWORD_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogIsValidPasswordResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_is_valid_password_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogIsValidPasswordResult *self = I_FACE_LOG_IS_VALID_PASSWORD_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_PASSWORD_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_IS_VALID_PASSWORD_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_is_valid_password_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogIsValidPasswordResult *self = I_FACE_LOG_IS_VALID_PASSWORD_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_PASSWORD_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_I_FACE_LOG_IS_VALID_PASSWORD_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_is_valid_password_result_instance_init (IFaceLogIsValidPasswordResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_is_valid_password_result_finalize (GObject *object)
{
  IFaceLogIsValidPasswordResult *tobject = I_FACE_LOG_IS_VALID_PASSWORD_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_is_valid_password_result_class_init (IFaceLogIsValidPasswordResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_is_valid_password_result_read;
  struct_class->write = i_face_log_is_valid_password_result_write;

  gobject_class->finalize = i_face_log_is_valid_password_result_finalize;
  gobject_class->get_property = i_face_log_is_valid_password_result_get_property;
  gobject_class->set_property = i_face_log_is_valid_password_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_PASSWORD_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_PASSWORD_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_is_valid_password_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogIsValidPasswordResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_is_valid_password_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogIsValidPasswordResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_is_valid_password_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogIsValidPasswordResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogIsValidPersonTokenArgsProperties
{
  PROP_I_FACE_LOG_IS_VALID_PERSON_TOKEN_ARGS_0,
  PROP_I_FACE_LOG_IS_VALID_PERSON_TOKEN_ARGS_TOKEN
};

/* reads a i_face_log_is_valid_person_token_args object */
static gint32
i_face_log_is_valid_person_token_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogIsValidPersonTokenArgs * this_object = I_FACE_LOG_IS_VALID_PERSON_TOKEN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_is_valid_person_token_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogIsValidPersonTokenArgs * this_object = I_FACE_LOG_IS_VALID_PERSON_TOKEN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogIsValidPersonTokenArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_is_valid_person_token_args_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogIsValidPersonTokenArgs *self = I_FACE_LOG_IS_VALID_PERSON_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_PERSON_TOKEN_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_is_valid_person_token_args_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogIsValidPersonTokenArgs *self = I_FACE_LOG_IS_VALID_PERSON_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_PERSON_TOKEN_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_is_valid_person_token_args_instance_init (IFaceLogIsValidPersonTokenArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_is_valid_person_token_args_finalize (GObject *object)
{
  IFaceLogIsValidPersonTokenArgs *tobject = I_FACE_LOG_IS_VALID_PERSON_TOKEN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_is_valid_person_token_args_class_init (IFaceLogIsValidPersonTokenArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_is_valid_person_token_args_read;
  struct_class->write = i_face_log_is_valid_person_token_args_write;

  gobject_class->finalize = i_face_log_is_valid_person_token_args_finalize;
  gobject_class->get_property = i_face_log_is_valid_person_token_args_get_property;
  gobject_class->set_property = i_face_log_is_valid_person_token_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_PERSON_TOKEN_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_is_valid_person_token_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogIsValidPersonTokenArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_is_valid_person_token_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogIsValidPersonTokenArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_is_valid_person_token_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogIsValidPersonTokenArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogIsValidPersonTokenResultProperties
{
  PROP_I_FACE_LOG_IS_VALID_PERSON_TOKEN_RESULT_0,
  PROP_I_FACE_LOG_IS_VALID_PERSON_TOKEN_RESULT_SUCCESS,
  PROP_I_FACE_LOG_IS_VALID_PERSON_TOKEN_RESULT_EX1
};

/* reads a i_face_log_is_valid_person_token_result object */
static gint32
i_face_log_is_valid_person_token_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogIsValidPersonTokenResult * this_object = I_FACE_LOG_IS_VALID_PERSON_TOKEN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_is_valid_person_token_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogIsValidPersonTokenResult * this_object = I_FACE_LOG_IS_VALID_PERSON_TOKEN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogIsValidPersonTokenResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_is_valid_person_token_result_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  IFaceLogIsValidPersonTokenResult *self = I_FACE_LOG_IS_VALID_PERSON_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_PERSON_TOKEN_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_IS_VALID_PERSON_TOKEN_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_is_valid_person_token_result_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  IFaceLogIsValidPersonTokenResult *self = I_FACE_LOG_IS_VALID_PERSON_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_PERSON_TOKEN_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_I_FACE_LOG_IS_VALID_PERSON_TOKEN_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_is_valid_person_token_result_instance_init (IFaceLogIsValidPersonTokenResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_is_valid_person_token_result_finalize (GObject *object)
{
  IFaceLogIsValidPersonTokenResult *tobject = I_FACE_LOG_IS_VALID_PERSON_TOKEN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_is_valid_person_token_result_class_init (IFaceLogIsValidPersonTokenResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_is_valid_person_token_result_read;
  struct_class->write = i_face_log_is_valid_person_token_result_write;

  gobject_class->finalize = i_face_log_is_valid_person_token_result_finalize;
  gobject_class->get_property = i_face_log_is_valid_person_token_result_get_property;
  gobject_class->set_property = i_face_log_is_valid_person_token_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_PERSON_TOKEN_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_PERSON_TOKEN_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_is_valid_person_token_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogIsValidPersonTokenResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_is_valid_person_token_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogIsValidPersonTokenResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_is_valid_person_token_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogIsValidPersonTokenResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogIsValidRootTokenArgsProperties
{
  PROP_I_FACE_LOG_IS_VALID_ROOT_TOKEN_ARGS_0,
  PROP_I_FACE_LOG_IS_VALID_ROOT_TOKEN_ARGS_TOKEN
};

/* reads a i_face_log_is_valid_root_token_args object */
static gint32
i_face_log_is_valid_root_token_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogIsValidRootTokenArgs * this_object = I_FACE_LOG_IS_VALID_ROOT_TOKEN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_is_valid_root_token_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogIsValidRootTokenArgs * this_object = I_FACE_LOG_IS_VALID_ROOT_TOKEN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogIsValidRootTokenArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_is_valid_root_token_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogIsValidRootTokenArgs *self = I_FACE_LOG_IS_VALID_ROOT_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_ROOT_TOKEN_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_is_valid_root_token_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogIsValidRootTokenArgs *self = I_FACE_LOG_IS_VALID_ROOT_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_ROOT_TOKEN_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_is_valid_root_token_args_instance_init (IFaceLogIsValidRootTokenArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_is_valid_root_token_args_finalize (GObject *object)
{
  IFaceLogIsValidRootTokenArgs *tobject = I_FACE_LOG_IS_VALID_ROOT_TOKEN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_is_valid_root_token_args_class_init (IFaceLogIsValidRootTokenArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_is_valid_root_token_args_read;
  struct_class->write = i_face_log_is_valid_root_token_args_write;

  gobject_class->finalize = i_face_log_is_valid_root_token_args_finalize;
  gobject_class->get_property = i_face_log_is_valid_root_token_args_get_property;
  gobject_class->set_property = i_face_log_is_valid_root_token_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_ROOT_TOKEN_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_is_valid_root_token_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogIsValidRootTokenArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_is_valid_root_token_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogIsValidRootTokenArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_is_valid_root_token_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogIsValidRootTokenArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogIsValidRootTokenResultProperties
{
  PROP_I_FACE_LOG_IS_VALID_ROOT_TOKEN_RESULT_0,
  PROP_I_FACE_LOG_IS_VALID_ROOT_TOKEN_RESULT_SUCCESS,
  PROP_I_FACE_LOG_IS_VALID_ROOT_TOKEN_RESULT_EX1
};

/* reads a i_face_log_is_valid_root_token_result object */
static gint32
i_face_log_is_valid_root_token_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogIsValidRootTokenResult * this_object = I_FACE_LOG_IS_VALID_ROOT_TOKEN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_is_valid_root_token_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogIsValidRootTokenResult * this_object = I_FACE_LOG_IS_VALID_ROOT_TOKEN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogIsValidRootTokenResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_is_valid_root_token_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogIsValidRootTokenResult *self = I_FACE_LOG_IS_VALID_ROOT_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_ROOT_TOKEN_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_IS_VALID_ROOT_TOKEN_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_is_valid_root_token_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogIsValidRootTokenResult *self = I_FACE_LOG_IS_VALID_ROOT_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_ROOT_TOKEN_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_I_FACE_LOG_IS_VALID_ROOT_TOKEN_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_is_valid_root_token_result_instance_init (IFaceLogIsValidRootTokenResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_is_valid_root_token_result_finalize (GObject *object)
{
  IFaceLogIsValidRootTokenResult *tobject = I_FACE_LOG_IS_VALID_ROOT_TOKEN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_is_valid_root_token_result_class_init (IFaceLogIsValidRootTokenResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_is_valid_root_token_result_read;
  struct_class->write = i_face_log_is_valid_root_token_result_write;

  gobject_class->finalize = i_face_log_is_valid_root_token_result_finalize;
  gobject_class->get_property = i_face_log_is_valid_root_token_result_get_property;
  gobject_class->set_property = i_face_log_is_valid_root_token_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_ROOT_TOKEN_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_ROOT_TOKEN_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_is_valid_root_token_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogIsValidRootTokenResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_is_valid_root_token_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogIsValidRootTokenResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_is_valid_root_token_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogIsValidRootTokenResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogIsValidTokenArgsProperties
{
  PROP_I_FACE_LOG_IS_VALID_TOKEN_ARGS_0,
  PROP_I_FACE_LOG_IS_VALID_TOKEN_ARGS_TOKEN
};

/* reads a i_face_log_is_valid_token_args object */
static gint32
i_face_log_is_valid_token_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogIsValidTokenArgs * this_object = I_FACE_LOG_IS_VALID_TOKEN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_is_valid_token_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogIsValidTokenArgs * this_object = I_FACE_LOG_IS_VALID_TOKEN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogIsValidTokenArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_is_valid_token_args_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogIsValidTokenArgs *self = I_FACE_LOG_IS_VALID_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_TOKEN_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_is_valid_token_args_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogIsValidTokenArgs *self = I_FACE_LOG_IS_VALID_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_TOKEN_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_is_valid_token_args_instance_init (IFaceLogIsValidTokenArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_is_valid_token_args_finalize (GObject *object)
{
  IFaceLogIsValidTokenArgs *tobject = I_FACE_LOG_IS_VALID_TOKEN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_is_valid_token_args_class_init (IFaceLogIsValidTokenArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_is_valid_token_args_read;
  struct_class->write = i_face_log_is_valid_token_args_write;

  gobject_class->finalize = i_face_log_is_valid_token_args_finalize;
  gobject_class->get_property = i_face_log_is_valid_token_args_get_property;
  gobject_class->set_property = i_face_log_is_valid_token_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_TOKEN_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_is_valid_token_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogIsValidTokenArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_is_valid_token_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogIsValidTokenArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_is_valid_token_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogIsValidTokenArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogIsValidTokenResultProperties
{
  PROP_I_FACE_LOG_IS_VALID_TOKEN_RESULT_0,
  PROP_I_FACE_LOG_IS_VALID_TOKEN_RESULT_SUCCESS,
  PROP_I_FACE_LOG_IS_VALID_TOKEN_RESULT_EX1
};

/* reads a i_face_log_is_valid_token_result object */
static gint32
i_face_log_is_valid_token_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogIsValidTokenResult * this_object = I_FACE_LOG_IS_VALID_TOKEN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_is_valid_token_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogIsValidTokenResult * this_object = I_FACE_LOG_IS_VALID_TOKEN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogIsValidTokenResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_is_valid_token_result_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogIsValidTokenResult *self = I_FACE_LOG_IS_VALID_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_TOKEN_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_IS_VALID_TOKEN_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_is_valid_token_result_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogIsValidTokenResult *self = I_FACE_LOG_IS_VALID_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_TOKEN_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_I_FACE_LOG_IS_VALID_TOKEN_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_is_valid_token_result_instance_init (IFaceLogIsValidTokenResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_is_valid_token_result_finalize (GObject *object)
{
  IFaceLogIsValidTokenResult *tobject = I_FACE_LOG_IS_VALID_TOKEN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_is_valid_token_result_class_init (IFaceLogIsValidTokenResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_is_valid_token_result_read;
  struct_class->write = i_face_log_is_valid_token_result_write;

  gobject_class->finalize = i_face_log_is_valid_token_result_finalize;
  gobject_class->get_property = i_face_log_is_valid_token_result_get_property;
  gobject_class->set_property = i_face_log_is_valid_token_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_TOKEN_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_TOKEN_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_is_valid_token_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogIsValidTokenResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_is_valid_token_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogIsValidTokenResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_is_valid_token_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogIsValidTokenResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogIsValidUserTokenArgsProperties
{
  PROP_I_FACE_LOG_IS_VALID_USER_TOKEN_ARGS_0,
  PROP_I_FACE_LOG_IS_VALID_USER_TOKEN_ARGS_TOKEN
};

/* reads a i_face_log_is_valid_user_token_args object */
static gint32
i_face_log_is_valid_user_token_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogIsValidUserTokenArgs * this_object = I_FACE_LOG_IS_VALID_USER_TOKEN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_is_valid_user_token_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogIsValidUserTokenArgs * this_object = I_FACE_LOG_IS_VALID_USER_TOKEN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogIsValidUserTokenArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_is_valid_user_token_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogIsValidUserTokenArgs *self = I_FACE_LOG_IS_VALID_USER_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_USER_TOKEN_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_is_valid_user_token_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogIsValidUserTokenArgs *self = I_FACE_LOG_IS_VALID_USER_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_USER_TOKEN_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_is_valid_user_token_args_instance_init (IFaceLogIsValidUserTokenArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_is_valid_user_token_args_finalize (GObject *object)
{
  IFaceLogIsValidUserTokenArgs *tobject = I_FACE_LOG_IS_VALID_USER_TOKEN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_is_valid_user_token_args_class_init (IFaceLogIsValidUserTokenArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_is_valid_user_token_args_read;
  struct_class->write = i_face_log_is_valid_user_token_args_write;

  gobject_class->finalize = i_face_log_is_valid_user_token_args_finalize;
  gobject_class->get_property = i_face_log_is_valid_user_token_args_get_property;
  gobject_class->set_property = i_face_log_is_valid_user_token_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_USER_TOKEN_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_is_valid_user_token_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogIsValidUserTokenArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_is_valid_user_token_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogIsValidUserTokenArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_is_valid_user_token_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogIsValidUserTokenArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogIsValidUserTokenResultProperties
{
  PROP_I_FACE_LOG_IS_VALID_USER_TOKEN_RESULT_0,
  PROP_I_FACE_LOG_IS_VALID_USER_TOKEN_RESULT_SUCCESS,
  PROP_I_FACE_LOG_IS_VALID_USER_TOKEN_RESULT_EX1
};

/* reads a i_face_log_is_valid_user_token_result object */
static gint32
i_face_log_is_valid_user_token_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogIsValidUserTokenResult * this_object = I_FACE_LOG_IS_VALID_USER_TOKEN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_is_valid_user_token_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogIsValidUserTokenResult * this_object = I_FACE_LOG_IS_VALID_USER_TOKEN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogIsValidUserTokenResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_is_valid_user_token_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogIsValidUserTokenResult *self = I_FACE_LOG_IS_VALID_USER_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_USER_TOKEN_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_IS_VALID_USER_TOKEN_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_is_valid_user_token_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogIsValidUserTokenResult *self = I_FACE_LOG_IS_VALID_USER_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_IS_VALID_USER_TOKEN_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_I_FACE_LOG_IS_VALID_USER_TOKEN_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_is_valid_user_token_result_instance_init (IFaceLogIsValidUserTokenResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_is_valid_user_token_result_finalize (GObject *object)
{
  IFaceLogIsValidUserTokenResult *tobject = I_FACE_LOG_IS_VALID_USER_TOKEN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_is_valid_user_token_result_class_init (IFaceLogIsValidUserTokenResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_is_valid_user_token_result_read;
  struct_class->write = i_face_log_is_valid_user_token_result_write;

  gobject_class->finalize = i_face_log_is_valid_user_token_result_finalize;
  gobject_class->get_property = i_face_log_is_valid_user_token_result_get_property;
  gobject_class->set_property = i_face_log_is_valid_user_token_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_USER_TOKEN_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_IS_VALID_USER_TOKEN_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_is_valid_user_token_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogIsValidUserTokenResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_is_valid_user_token_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogIsValidUserTokenResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_is_valid_user_token_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogIsValidUserTokenResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogListOfParentForDeviceGroupArgsProperties
{
  PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_ARGS_0,
  PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID
};

/* reads a i_face_log_list_of_parent_for_device_group_args object */
static gint32
i_face_log_list_of_parent_for_device_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogListOfParentForDeviceGroupArgs * this_object = I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_ARGS(object);
  gboolean isset_deviceGroupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_deviceGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_deviceGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_list_of_parent_for_device_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogListOfParentForDeviceGroupArgs * this_object = I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogListOfParentForDeviceGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_list_of_parent_for_device_group_args_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  IFaceLogListOfParentForDeviceGroupArgs *self = I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID:
      self->deviceGroupId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_list_of_parent_for_device_group_args_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  IFaceLogListOfParentForDeviceGroupArgs *self = I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID:
      g_value_set_int (value, self->deviceGroupId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_list_of_parent_for_device_group_args_instance_init (IFaceLogListOfParentForDeviceGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->deviceGroupId = 0;
}

static void 
i_face_log_list_of_parent_for_device_group_args_finalize (GObject *object)
{
  IFaceLogListOfParentForDeviceGroupArgs *tobject = I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_list_of_parent_for_device_group_args_class_init (IFaceLogListOfParentForDeviceGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_list_of_parent_for_device_group_args_read;
  struct_class->write = i_face_log_list_of_parent_for_device_group_args_write;

  gobject_class->finalize = i_face_log_list_of_parent_for_device_group_args_finalize;
  gobject_class->get_property = i_face_log_list_of_parent_for_device_group_args_get_property;
  gobject_class->set_property = i_face_log_list_of_parent_for_device_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_ARGS_DEVICE_GROUP_ID,
     g_param_spec_int ("deviceGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_list_of_parent_for_device_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogListOfParentForDeviceGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_list_of_parent_for_device_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogListOfParentForDeviceGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_list_of_parent_for_device_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogListOfParentForDeviceGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogListOfParentForDeviceGroupResultProperties
{
  PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_RESULT_0,
  PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_RESULT_EX1
};

/* reads a i_face_log_list_of_parent_for_device_group_result object */
static gint32
i_face_log_list_of_parent_for_device_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogListOfParentForDeviceGroupResult * this_object = I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem93 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem93, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem93, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_list_of_parent_for_device_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogListOfParentForDeviceGroupResult * this_object = I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogListOfParentForDeviceGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i94;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i94 = 0; i94 < (this_object->success ? this_object->success->len : 0); i94++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i94)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_list_of_parent_for_device_group_result_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  IFaceLogListOfParentForDeviceGroupResult *self = I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_list_of_parent_for_device_group_result_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  IFaceLogListOfParentForDeviceGroupResult *self = I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_list_of_parent_for_device_group_result_instance_init (IFaceLogListOfParentForDeviceGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_list_of_parent_for_device_group_result_finalize (GObject *object)
{
  IFaceLogListOfParentForDeviceGroupResult *tobject = I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_list_of_parent_for_device_group_result_class_init (IFaceLogListOfParentForDeviceGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_list_of_parent_for_device_group_result_read;
  struct_class->write = i_face_log_list_of_parent_for_device_group_result_write;

  gobject_class->finalize = i_face_log_list_of_parent_for_device_group_result_finalize;
  gobject_class->get_property = i_face_log_list_of_parent_for_device_group_result_get_property;
  gobject_class->set_property = i_face_log_list_of_parent_for_device_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_list_of_parent_for_device_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogListOfParentForDeviceGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_list_of_parent_for_device_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogListOfParentForDeviceGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_list_of_parent_for_device_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogListOfParentForDeviceGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogListOfParentForPersonGroupArgsProperties
{
  PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_ARGS_0,
  PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_ARGS_PERSON_GROUP_ID
};

/* reads a i_face_log_list_of_parent_for_person_group_args object */
static gint32
i_face_log_list_of_parent_for_person_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogListOfParentForPersonGroupArgs * this_object = I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_ARGS(object);
  gboolean isset_personGroupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_list_of_parent_for_person_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogListOfParentForPersonGroupArgs * this_object = I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogListOfParentForPersonGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_list_of_parent_for_person_group_args_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  IFaceLogListOfParentForPersonGroupArgs *self = I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_ARGS_PERSON_GROUP_ID:
      self->personGroupId = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_list_of_parent_for_person_group_args_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  IFaceLogListOfParentForPersonGroupArgs *self = I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_ARGS_PERSON_GROUP_ID:
      g_value_set_int (value, self->personGroupId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_list_of_parent_for_person_group_args_instance_init (IFaceLogListOfParentForPersonGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personGroupId = 0;
}

static void 
i_face_log_list_of_parent_for_person_group_args_finalize (GObject *object)
{
  IFaceLogListOfParentForPersonGroupArgs *tobject = I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_list_of_parent_for_person_group_args_class_init (IFaceLogListOfParentForPersonGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_list_of_parent_for_person_group_args_read;
  struct_class->write = i_face_log_list_of_parent_for_person_group_args_write;

  gobject_class->finalize = i_face_log_list_of_parent_for_person_group_args_finalize;
  gobject_class->get_property = i_face_log_list_of_parent_for_person_group_args_get_property;
  gobject_class->set_property = i_face_log_list_of_parent_for_person_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_ARGS_PERSON_GROUP_ID,
     g_param_spec_int ("personGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_list_of_parent_for_person_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogListOfParentForPersonGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_list_of_parent_for_person_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogListOfParentForPersonGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_list_of_parent_for_person_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogListOfParentForPersonGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogListOfParentForPersonGroupResultProperties
{
  PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_RESULT_0,
  PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_RESULT_EX1
};

/* reads a i_face_log_list_of_parent_for_person_group_result object */
static gint32
i_face_log_list_of_parent_for_person_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogListOfParentForPersonGroupResult * this_object = I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem95 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem95, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem95, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_list_of_parent_for_person_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogListOfParentForPersonGroupResult * this_object = I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogListOfParentForPersonGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i96;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i96 = 0; i96 < (this_object->success ? this_object->success->len : 0); i96++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i96)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_list_of_parent_for_person_group_result_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  IFaceLogListOfParentForPersonGroupResult *self = I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_list_of_parent_for_person_group_result_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  IFaceLogListOfParentForPersonGroupResult *self = I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_list_of_parent_for_person_group_result_instance_init (IFaceLogListOfParentForPersonGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_list_of_parent_for_person_group_result_finalize (GObject *object)
{
  IFaceLogListOfParentForPersonGroupResult *tobject = I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_list_of_parent_for_person_group_result_class_init (IFaceLogListOfParentForPersonGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_list_of_parent_for_person_group_result_read;
  struct_class->write = i_face_log_list_of_parent_for_person_group_result_write;

  gobject_class->finalize = i_face_log_list_of_parent_for_person_group_result_finalize;
  gobject_class->get_property = i_face_log_list_of_parent_for_person_group_result_get_property;
  gobject_class->set_property = i_face_log_list_of_parent_for_person_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_list_of_parent_for_person_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogListOfParentForPersonGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_list_of_parent_for_person_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogListOfParentForPersonGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_list_of_parent_for_person_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogListOfParentForPersonGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a i_face_log_load_all_person_args object */
static gint32
i_face_log_load_all_person_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadAllPersonArgs * this_object = I_FACE_LOG_LOAD_ALL_PERSON_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_all_person_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadAllPersonArgs * this_object = I_FACE_LOG_LOAD_ALL_PERSON_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadAllPersonArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
i_face_log_load_all_person_args_instance_init (IFaceLogLoadAllPersonArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
i_face_log_load_all_person_args_finalize (GObject *object)
{
  IFaceLogLoadAllPersonArgs *tobject = I_FACE_LOG_LOAD_ALL_PERSON_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_load_all_person_args_class_init (IFaceLogLoadAllPersonArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_all_person_args_read;
  struct_class->write = i_face_log_load_all_person_args_write;

  gobject_class->finalize = i_face_log_load_all_person_args_finalize;
}

GType
i_face_log_load_all_person_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadAllPersonArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_all_person_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadAllPersonArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_all_person_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadAllPersonArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadAllPersonResultProperties
{
  PROP_I_FACE_LOG_LOAD_ALL_PERSON_RESULT_0,
  PROP_I_FACE_LOG_LOAD_ALL_PERSON_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LOAD_ALL_PERSON_RESULT_EX1
};

/* reads a i_face_log_load_all_person_result object */
static gint32
i_face_log_load_all_person_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadAllPersonResult * this_object = I_FACE_LOG_LOAD_ALL_PERSON_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem97 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem97, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem97, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_all_person_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadAllPersonResult * this_object = I_FACE_LOG_LOAD_ALL_PERSON_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadAllPersonResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i98;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i98 = 0; i98 < (this_object->success ? this_object->success->len : 0); i98++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i98)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_all_person_result_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogLoadAllPersonResult *self = I_FACE_LOG_LOAD_ALL_PERSON_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_ALL_PERSON_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_ALL_PERSON_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_all_person_result_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogLoadAllPersonResult *self = I_FACE_LOG_LOAD_ALL_PERSON_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_ALL_PERSON_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LOAD_ALL_PERSON_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_all_person_result_instance_init (IFaceLogLoadAllPersonResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_load_all_person_result_finalize (GObject *object)
{
  IFaceLogLoadAllPersonResult *tobject = I_FACE_LOG_LOAD_ALL_PERSON_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_load_all_person_result_class_init (IFaceLogLoadAllPersonResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_all_person_result_read;
  struct_class->write = i_face_log_load_all_person_result_write;

  gobject_class->finalize = i_face_log_load_all_person_result_finalize;
  gobject_class->get_property = i_face_log_load_all_person_result_get_property;
  gobject_class->set_property = i_face_log_load_all_person_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_ALL_PERSON_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_ALL_PERSON_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_all_person_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadAllPersonResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_all_person_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadAllPersonResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_all_person_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadAllPersonResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadDeviceByWhereArgsProperties
{
  PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_ARGS_0,
  PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_ARGS_WHERE,
  PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_ARGS_START_ROW,
  PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_ARGS_NUM_ROWS
};

/* reads a i_face_log_load_device_by_where_args object */
static gint32
i_face_log_load_device_by_where_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadDeviceByWhereArgs * this_object = I_FACE_LOG_LOAD_DEVICE_BY_WHERE_ARGS(object);
  gboolean isset_startRow = FALSE;
  gboolean isset_numRows = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->where != NULL)
          {
            g_free(this_object->where);
            this_object->where = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->where, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_where = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->startRow, error)) < 0)
            return -1;
          xfer += ret;
          isset_startRow = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->numRows, error)) < 0)
            return -1;
          xfer += ret;
          isset_numRows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_startRow)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_numRows)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_load_device_by_where_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadDeviceByWhereArgs * this_object = I_FACE_LOG_LOAD_DEVICE_BY_WHERE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadDeviceByWhereArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->where, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->startRow, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "numRows", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->numRows, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_device_by_where_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogLoadDeviceByWhereArgs *self = I_FACE_LOG_LOAD_DEVICE_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_ARGS_WHERE:
      if (self->where != NULL)
        g_free (self->where);
      self->where = g_value_dup_string (value);
      self->__isset_where = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_ARGS_START_ROW:
      self->startRow = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_ARGS_NUM_ROWS:
      self->numRows = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_device_by_where_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogLoadDeviceByWhereArgs *self = I_FACE_LOG_LOAD_DEVICE_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_ARGS_WHERE:
      g_value_set_string (value, self->where);
      break;

    case PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_ARGS_START_ROW:
      g_value_set_int (value, self->startRow);
      break;

    case PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_ARGS_NUM_ROWS:
      g_value_set_int (value, self->numRows);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_device_by_where_args_instance_init (IFaceLogLoadDeviceByWhereArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->where = NULL;
  object->__isset_where = FALSE;
  object->startRow = 0;
  object->numRows = 0;
}

static void 
i_face_log_load_device_by_where_args_finalize (GObject *object)
{
  IFaceLogLoadDeviceByWhereArgs *tobject = I_FACE_LOG_LOAD_DEVICE_BY_WHERE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->where != NULL)
  {
    g_free(tobject->where);
    tobject->where = NULL;
  }
}

static void
i_face_log_load_device_by_where_args_class_init (IFaceLogLoadDeviceByWhereArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_device_by_where_args_read;
  struct_class->write = i_face_log_load_device_by_where_args_write;

  gobject_class->finalize = i_face_log_load_device_by_where_args_finalize;
  gobject_class->get_property = i_face_log_load_device_by_where_args_get_property;
  gobject_class->set_property = i_face_log_load_device_by_where_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_ARGS_WHERE,
     g_param_spec_string ("where",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_ARGS_START_ROW,
     g_param_spec_int ("startRow",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_ARGS_NUM_ROWS,
     g_param_spec_int ("numRows",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_load_device_by_where_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadDeviceByWhereArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_device_by_where_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadDeviceByWhereArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_device_by_where_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadDeviceByWhereArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadDeviceByWhereResultProperties
{
  PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_RESULT_0,
  PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_RESULT_EX1
};

/* reads a i_face_log_load_device_by_where_result object */
static gint32
i_face_log_load_device_by_where_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadDeviceByWhereResult * this_object = I_FACE_LOG_LOAD_DEVICE_BY_WHERE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              DeviceBean * _elem99 = NULL;
              if ( _elem99 != NULL)
              {
                g_object_unref (_elem99);
              }
              _elem99 = g_object_new (TYPE_DEVICE_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem99), protocol, error)) < 0)
              {
                g_object_unref (_elem99);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem99);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_device_by_where_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadDeviceByWhereResult * this_object = I_FACE_LOG_LOAD_DEVICE_BY_WHERE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadDeviceByWhereResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i100;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i100 = 0; i100 < (this_object->success ? this_object->success->len : 0); i100++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i100))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_device_by_where_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogLoadDeviceByWhereResult *self = I_FACE_LOG_LOAD_DEVICE_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_device_by_where_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogLoadDeviceByWhereResult *self = I_FACE_LOG_LOAD_DEVICE_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_device_by_where_result_instance_init (IFaceLogLoadDeviceByWhereResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_load_device_by_where_result_finalize (GObject *object)
{
  IFaceLogLoadDeviceByWhereResult *tobject = I_FACE_LOG_LOAD_DEVICE_BY_WHERE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_load_device_by_where_result_class_init (IFaceLogLoadDeviceByWhereResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_device_by_where_result_read;
  struct_class->write = i_face_log_load_device_by_where_result_write;

  gobject_class->finalize = i_face_log_load_device_by_where_result_finalize;
  gobject_class->get_property = i_face_log_load_device_by_where_result_get_property;
  gobject_class->set_property = i_face_log_load_device_by_where_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_device_by_where_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadDeviceByWhereResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_device_by_where_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadDeviceByWhereResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_device_by_where_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadDeviceByWhereResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadDeviceGroupByWhereArgsProperties
{
  PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_ARGS_0,
  PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_ARGS_WHERE,
  PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_ARGS_START_ROW,
  PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_ARGS_NUM_ROWS
};

/* reads a i_face_log_load_device_group_by_where_args object */
static gint32
i_face_log_load_device_group_by_where_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadDeviceGroupByWhereArgs * this_object = I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_ARGS(object);
  gboolean isset_startRow = FALSE;
  gboolean isset_numRows = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->where != NULL)
          {
            g_free(this_object->where);
            this_object->where = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->where, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_where = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->startRow, error)) < 0)
            return -1;
          xfer += ret;
          isset_startRow = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->numRows, error)) < 0)
            return -1;
          xfer += ret;
          isset_numRows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_startRow)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_numRows)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_load_device_group_by_where_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadDeviceGroupByWhereArgs * this_object = I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadDeviceGroupByWhereArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->where, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->startRow, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "numRows", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->numRows, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_device_group_by_where_args_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  IFaceLogLoadDeviceGroupByWhereArgs *self = I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_ARGS_WHERE:
      if (self->where != NULL)
        g_free (self->where);
      self->where = g_value_dup_string (value);
      self->__isset_where = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_ARGS_START_ROW:
      self->startRow = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_ARGS_NUM_ROWS:
      self->numRows = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_device_group_by_where_args_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  IFaceLogLoadDeviceGroupByWhereArgs *self = I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_ARGS_WHERE:
      g_value_set_string (value, self->where);
      break;

    case PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_ARGS_START_ROW:
      g_value_set_int (value, self->startRow);
      break;

    case PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_ARGS_NUM_ROWS:
      g_value_set_int (value, self->numRows);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_device_group_by_where_args_instance_init (IFaceLogLoadDeviceGroupByWhereArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->where = NULL;
  object->__isset_where = FALSE;
  object->startRow = 0;
  object->numRows = 0;
}

static void 
i_face_log_load_device_group_by_where_args_finalize (GObject *object)
{
  IFaceLogLoadDeviceGroupByWhereArgs *tobject = I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->where != NULL)
  {
    g_free(tobject->where);
    tobject->where = NULL;
  }
}

static void
i_face_log_load_device_group_by_where_args_class_init (IFaceLogLoadDeviceGroupByWhereArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_device_group_by_where_args_read;
  struct_class->write = i_face_log_load_device_group_by_where_args_write;

  gobject_class->finalize = i_face_log_load_device_group_by_where_args_finalize;
  gobject_class->get_property = i_face_log_load_device_group_by_where_args_get_property;
  gobject_class->set_property = i_face_log_load_device_group_by_where_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_ARGS_WHERE,
     g_param_spec_string ("where",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_ARGS_START_ROW,
     g_param_spec_int ("startRow",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_ARGS_NUM_ROWS,
     g_param_spec_int ("numRows",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_load_device_group_by_where_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadDeviceGroupByWhereArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_device_group_by_where_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadDeviceGroupByWhereArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_device_group_by_where_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadDeviceGroupByWhereArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadDeviceGroupByWhereResultProperties
{
  PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_RESULT_0,
  PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_RESULT_EX1
};

/* reads a i_face_log_load_device_group_by_where_result object */
static gint32
i_face_log_load_device_group_by_where_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadDeviceGroupByWhereResult * this_object = I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem101 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem101, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem101, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_device_group_by_where_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadDeviceGroupByWhereResult * this_object = I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadDeviceGroupByWhereResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i102;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i102 = 0; i102 < (this_object->success ? this_object->success->len : 0); i102++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i102)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_device_group_by_where_result_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  IFaceLogLoadDeviceGroupByWhereResult *self = I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_device_group_by_where_result_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  IFaceLogLoadDeviceGroupByWhereResult *self = I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_device_group_by_where_result_instance_init (IFaceLogLoadDeviceGroupByWhereResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_load_device_group_by_where_result_finalize (GObject *object)
{
  IFaceLogLoadDeviceGroupByWhereResult *tobject = I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_load_device_group_by_where_result_class_init (IFaceLogLoadDeviceGroupByWhereResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_device_group_by_where_result_read;
  struct_class->write = i_face_log_load_device_group_by_where_result_write;

  gobject_class->finalize = i_face_log_load_device_group_by_where_result_finalize;
  gobject_class->get_property = i_face_log_load_device_group_by_where_result_get_property;
  gobject_class->set_property = i_face_log_load_device_group_by_where_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_device_group_by_where_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadDeviceGroupByWhereResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_device_group_by_where_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadDeviceGroupByWhereResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_device_group_by_where_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadDeviceGroupByWhereResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadDeviceGroupIdByWhereArgsProperties
{
  PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_ARGS_0,
  PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_ARGS_WHERE
};

/* reads a i_face_log_load_device_group_id_by_where_args object */
static gint32
i_face_log_load_device_group_id_by_where_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadDeviceGroupIdByWhereArgs * this_object = I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->where != NULL)
          {
            g_free(this_object->where);
            this_object->where = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->where, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_where = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_device_group_id_by_where_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadDeviceGroupIdByWhereArgs * this_object = I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadDeviceGroupIdByWhereArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->where, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_device_group_id_by_where_args_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogLoadDeviceGroupIdByWhereArgs *self = I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_ARGS_WHERE:
      if (self->where != NULL)
        g_free (self->where);
      self->where = g_value_dup_string (value);
      self->__isset_where = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_device_group_id_by_where_args_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogLoadDeviceGroupIdByWhereArgs *self = I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_ARGS_WHERE:
      g_value_set_string (value, self->where);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_device_group_id_by_where_args_instance_init (IFaceLogLoadDeviceGroupIdByWhereArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->where = NULL;
  object->__isset_where = FALSE;
}

static void 
i_face_log_load_device_group_id_by_where_args_finalize (GObject *object)
{
  IFaceLogLoadDeviceGroupIdByWhereArgs *tobject = I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->where != NULL)
  {
    g_free(tobject->where);
    tobject->where = NULL;
  }
}

static void
i_face_log_load_device_group_id_by_where_args_class_init (IFaceLogLoadDeviceGroupIdByWhereArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_device_group_id_by_where_args_read;
  struct_class->write = i_face_log_load_device_group_id_by_where_args_write;

  gobject_class->finalize = i_face_log_load_device_group_id_by_where_args_finalize;
  gobject_class->get_property = i_face_log_load_device_group_id_by_where_args_get_property;
  gobject_class->set_property = i_face_log_load_device_group_id_by_where_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_ARGS_WHERE,
     g_param_spec_string ("where",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_load_device_group_id_by_where_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadDeviceGroupIdByWhereArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_device_group_id_by_where_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadDeviceGroupIdByWhereArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_device_group_id_by_where_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadDeviceGroupIdByWhereArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadDeviceGroupIdByWhereResultProperties
{
  PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_RESULT_0,
  PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_RESULT_EX1
};

/* reads a i_face_log_load_device_group_id_by_where_result object */
static gint32
i_face_log_load_device_group_id_by_where_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadDeviceGroupIdByWhereResult * this_object = I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem103 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem103, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem103, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_device_group_id_by_where_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadDeviceGroupIdByWhereResult * this_object = I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadDeviceGroupIdByWhereResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i104;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i104 = 0; i104 < (this_object->success ? this_object->success->len : 0); i104++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i104)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_device_group_id_by_where_result_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  IFaceLogLoadDeviceGroupIdByWhereResult *self = I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_device_group_id_by_where_result_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  IFaceLogLoadDeviceGroupIdByWhereResult *self = I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_device_group_id_by_where_result_instance_init (IFaceLogLoadDeviceGroupIdByWhereResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_load_device_group_id_by_where_result_finalize (GObject *object)
{
  IFaceLogLoadDeviceGroupIdByWhereResult *tobject = I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_load_device_group_id_by_where_result_class_init (IFaceLogLoadDeviceGroupIdByWhereResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_device_group_id_by_where_result_read;
  struct_class->write = i_face_log_load_device_group_id_by_where_result_write;

  gobject_class->finalize = i_face_log_load_device_group_id_by_where_result_finalize;
  gobject_class->get_property = i_face_log_load_device_group_id_by_where_result_get_property;
  gobject_class->set_property = i_face_log_load_device_group_id_by_where_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_device_group_id_by_where_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadDeviceGroupIdByWhereResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_device_group_id_by_where_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadDeviceGroupIdByWhereResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_device_group_id_by_where_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadDeviceGroupIdByWhereResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadDeviceIdByWhereArgsProperties
{
  PROP_I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_ARGS_0,
  PROP_I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_ARGS_WHERE
};

/* reads a i_face_log_load_device_id_by_where_args object */
static gint32
i_face_log_load_device_id_by_where_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadDeviceIdByWhereArgs * this_object = I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->where != NULL)
          {
            g_free(this_object->where);
            this_object->where = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->where, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_where = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_device_id_by_where_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadDeviceIdByWhereArgs * this_object = I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadDeviceIdByWhereArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->where, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_device_id_by_where_args_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  IFaceLogLoadDeviceIdByWhereArgs *self = I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_ARGS_WHERE:
      if (self->where != NULL)
        g_free (self->where);
      self->where = g_value_dup_string (value);
      self->__isset_where = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_device_id_by_where_args_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  IFaceLogLoadDeviceIdByWhereArgs *self = I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_ARGS_WHERE:
      g_value_set_string (value, self->where);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_device_id_by_where_args_instance_init (IFaceLogLoadDeviceIdByWhereArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->where = NULL;
  object->__isset_where = FALSE;
}

static void 
i_face_log_load_device_id_by_where_args_finalize (GObject *object)
{
  IFaceLogLoadDeviceIdByWhereArgs *tobject = I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->where != NULL)
  {
    g_free(tobject->where);
    tobject->where = NULL;
  }
}

static void
i_face_log_load_device_id_by_where_args_class_init (IFaceLogLoadDeviceIdByWhereArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_device_id_by_where_args_read;
  struct_class->write = i_face_log_load_device_id_by_where_args_write;

  gobject_class->finalize = i_face_log_load_device_id_by_where_args_finalize;
  gobject_class->get_property = i_face_log_load_device_id_by_where_args_get_property;
  gobject_class->set_property = i_face_log_load_device_id_by_where_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_ARGS_WHERE,
     g_param_spec_string ("where",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_load_device_id_by_where_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadDeviceIdByWhereArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_device_id_by_where_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadDeviceIdByWhereArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_device_id_by_where_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadDeviceIdByWhereArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadDeviceIdByWhereResultProperties
{
  PROP_I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_RESULT_0,
  PROP_I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_RESULT_EX1
};

/* reads a i_face_log_load_device_id_by_where_result object */
static gint32
i_face_log_load_device_id_by_where_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadDeviceIdByWhereResult * this_object = I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem105 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem105, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem105, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_device_id_by_where_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadDeviceIdByWhereResult * this_object = I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadDeviceIdByWhereResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i106;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i106 = 0; i106 < (this_object->success ? this_object->success->len : 0); i106++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i106)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_device_id_by_where_result_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  IFaceLogLoadDeviceIdByWhereResult *self = I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_device_id_by_where_result_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  IFaceLogLoadDeviceIdByWhereResult *self = I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_device_id_by_where_result_instance_init (IFaceLogLoadDeviceIdByWhereResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_load_device_id_by_where_result_finalize (GObject *object)
{
  IFaceLogLoadDeviceIdByWhereResult *tobject = I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_load_device_id_by_where_result_class_init (IFaceLogLoadDeviceIdByWhereResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_device_id_by_where_result_read;
  struct_class->write = i_face_log_load_device_id_by_where_result_write;

  gobject_class->finalize = i_face_log_load_device_id_by_where_result_finalize;
  gobject_class->get_property = i_face_log_load_device_id_by_where_result_get_property;
  gobject_class->set_property = i_face_log_load_device_id_by_where_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_device_id_by_where_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadDeviceIdByWhereResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_device_id_by_where_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadDeviceIdByWhereResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_device_id_by_where_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadDeviceIdByWhereResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadFeatureMd5ByUpdateArgsProperties
{
  PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_ARGS_0,
  PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_ARGS_TIMESTAMP
};

/* reads a i_face_log_load_feature_md5_by_update_args object */
static gint32
i_face_log_load_feature_md5_by_update_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadFeatureMd5ByUpdateArgs * this_object = I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_ARGS(object);
  gboolean isset_timestamp = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_timestamp)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_load_feature_md5_by_update_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadFeatureMd5ByUpdateArgs * this_object = I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadFeatureMd5ByUpdateArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_feature_md5_by_update_args_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  IFaceLogLoadFeatureMd5ByUpdateArgs *self = I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_ARGS_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_feature_md5_by_update_args_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  IFaceLogLoadFeatureMd5ByUpdateArgs *self = I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_ARGS_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_feature_md5_by_update_args_instance_init (IFaceLogLoadFeatureMd5ByUpdateArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->timestamp = 0;
}

static void 
i_face_log_load_feature_md5_by_update_args_finalize (GObject *object)
{
  IFaceLogLoadFeatureMd5ByUpdateArgs *tobject = I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_load_feature_md5_by_update_args_class_init (IFaceLogLoadFeatureMd5ByUpdateArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_feature_md5_by_update_args_read;
  struct_class->write = i_face_log_load_feature_md5_by_update_args_write;

  gobject_class->finalize = i_face_log_load_feature_md5_by_update_args_finalize;
  gobject_class->get_property = i_face_log_load_feature_md5_by_update_args_get_property;
  gobject_class->set_property = i_face_log_load_feature_md5_by_update_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_ARGS_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_feature_md5_by_update_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadFeatureMd5ByUpdateArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_feature_md5_by_update_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadFeatureMd5ByUpdateArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_feature_md5_by_update_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadFeatureMd5ByUpdateArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadFeatureMd5ByUpdateResultProperties
{
  PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_RESULT_0,
  PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_RESULT_EX1
};

/* reads a i_face_log_load_feature_md5_by_update_result object */
static gint32
i_face_log_load_feature_md5_by_update_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadFeatureMd5ByUpdateResult * this_object = I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem107 = NULL;
              if (_elem107 != NULL)
              {
                g_free(_elem107);
                _elem107 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem107, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem107);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_feature_md5_by_update_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadFeatureMd5ByUpdateResult * this_object = I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadFeatureMd5ByUpdateResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i108;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i108 = 0; i108 < (this_object->success ? this_object->success->len : 0); i108++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->success, i108)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_feature_md5_by_update_result_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  IFaceLogLoadFeatureMd5ByUpdateResult *self = I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_feature_md5_by_update_result_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  IFaceLogLoadFeatureMd5ByUpdateResult *self = I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_feature_md5_by_update_result_instance_init (IFaceLogLoadFeatureMd5ByUpdateResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_free);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_load_feature_md5_by_update_result_finalize (GObject *object)
{
  IFaceLogLoadFeatureMd5ByUpdateResult *tobject = I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_load_feature_md5_by_update_result_class_init (IFaceLogLoadFeatureMd5ByUpdateResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_feature_md5_by_update_result_read;
  struct_class->write = i_face_log_load_feature_md5_by_update_result_write;

  gobject_class->finalize = i_face_log_load_feature_md5_by_update_result_finalize;
  gobject_class->get_property = i_face_log_load_feature_md5_by_update_result_get_property;
  gobject_class->set_property = i_face_log_load_feature_md5_by_update_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_feature_md5_by_update_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadFeatureMd5ByUpdateResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_feature_md5_by_update_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadFeatureMd5ByUpdateResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_feature_md5_by_update_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadFeatureMd5ByUpdateResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadFeatureMd5ByUpdateTimeStrArgsProperties
{
  PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_ARGS_0,
  PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_ARGS_TIMESTAMP
};

/* reads a i_face_log_load_feature_md5_by_update_time_str_args object */
static gint32
i_face_log_load_feature_md5_by_update_time_str_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadFeatureMd5ByUpdateTimeStrArgs * this_object = I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->timestamp != NULL)
          {
            g_free(this_object->timestamp);
            this_object->timestamp = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_feature_md5_by_update_time_str_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadFeatureMd5ByUpdateTimeStrArgs * this_object = I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadFeatureMd5ByUpdateTimeStrArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_feature_md5_by_update_time_str_args_set_property (GObject *object,
                                                                  guint property_id,
                                                                  const GValue *value,
                                                                  GParamSpec *pspec)
{
  IFaceLogLoadFeatureMd5ByUpdateTimeStrArgs *self = I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_ARGS_TIMESTAMP:
      if (self->timestamp != NULL)
        g_free (self->timestamp);
      self->timestamp = g_value_dup_string (value);
      self->__isset_timestamp = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_feature_md5_by_update_time_str_args_get_property (GObject *object,
                                                                  guint property_id,
                                                                  GValue *value,
                                                                  GParamSpec *pspec)
{
  IFaceLogLoadFeatureMd5ByUpdateTimeStrArgs *self = I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_ARGS_TIMESTAMP:
      g_value_set_string (value, self->timestamp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_feature_md5_by_update_time_str_args_instance_init (IFaceLogLoadFeatureMd5ByUpdateTimeStrArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->timestamp = NULL;
  object->__isset_timestamp = FALSE;
}

static void 
i_face_log_load_feature_md5_by_update_time_str_args_finalize (GObject *object)
{
  IFaceLogLoadFeatureMd5ByUpdateTimeStrArgs *tobject = I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->timestamp != NULL)
  {
    g_free(tobject->timestamp);
    tobject->timestamp = NULL;
  }
}

static void
i_face_log_load_feature_md5_by_update_time_str_args_class_init (IFaceLogLoadFeatureMd5ByUpdateTimeStrArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_feature_md5_by_update_time_str_args_read;
  struct_class->write = i_face_log_load_feature_md5_by_update_time_str_args_write;

  gobject_class->finalize = i_face_log_load_feature_md5_by_update_time_str_args_finalize;
  gobject_class->get_property = i_face_log_load_feature_md5_by_update_time_str_args_get_property;
  gobject_class->set_property = i_face_log_load_feature_md5_by_update_time_str_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_ARGS_TIMESTAMP,
     g_param_spec_string ("timestamp",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_load_feature_md5_by_update_time_str_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadFeatureMd5ByUpdateTimeStrArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_feature_md5_by_update_time_str_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadFeatureMd5ByUpdateTimeStrArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_feature_md5_by_update_time_str_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadFeatureMd5ByUpdateTimeStrArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadFeatureMd5ByUpdateTimeStrResultProperties
{
  PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_RESULT_0,
  PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_RESULT_EX1
};

/* reads a i_face_log_load_feature_md5_by_update_time_str_result object */
static gint32
i_face_log_load_feature_md5_by_update_time_str_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadFeatureMd5ByUpdateTimeStrResult * this_object = I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem109 = NULL;
              if (_elem109 != NULL)
              {
                g_free(_elem109);
                _elem109 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem109, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem109);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_feature_md5_by_update_time_str_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadFeatureMd5ByUpdateTimeStrResult * this_object = I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadFeatureMd5ByUpdateTimeStrResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i110;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i110 = 0; i110 < (this_object->success ? this_object->success->len : 0); i110++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->success, i110)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_feature_md5_by_update_time_str_result_set_property (GObject *object,
                                                                    guint property_id,
                                                                    const GValue *value,
                                                                    GParamSpec *pspec)
{
  IFaceLogLoadFeatureMd5ByUpdateTimeStrResult *self = I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_feature_md5_by_update_time_str_result_get_property (GObject *object,
                                                                    guint property_id,
                                                                    GValue *value,
                                                                    GParamSpec *pspec)
{
  IFaceLogLoadFeatureMd5ByUpdateTimeStrResult *self = I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_feature_md5_by_update_time_str_result_instance_init (IFaceLogLoadFeatureMd5ByUpdateTimeStrResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_free);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_load_feature_md5_by_update_time_str_result_finalize (GObject *object)
{
  IFaceLogLoadFeatureMd5ByUpdateTimeStrResult *tobject = I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_load_feature_md5_by_update_time_str_result_class_init (IFaceLogLoadFeatureMd5ByUpdateTimeStrResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_feature_md5_by_update_time_str_result_read;
  struct_class->write = i_face_log_load_feature_md5_by_update_time_str_result_write;

  gobject_class->finalize = i_face_log_load_feature_md5_by_update_time_str_result_finalize;
  gobject_class->get_property = i_face_log_load_feature_md5_by_update_time_str_result_get_property;
  gobject_class->set_property = i_face_log_load_feature_md5_by_update_time_str_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_feature_md5_by_update_time_str_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadFeatureMd5ByUpdateTimeStrResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_feature_md5_by_update_time_str_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadFeatureMd5ByUpdateTimeStrResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_feature_md5_by_update_time_str_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadFeatureMd5ByUpdateTimeStrResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadLogByWhereArgsProperties
{
  PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_ARGS_0,
  PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_ARGS_WHERE,
  PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_ARGS_START_ROW,
  PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_ARGS_NUM_ROWS
};

/* reads a i_face_log_load_log_by_where_args object */
static gint32
i_face_log_load_log_by_where_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadLogByWhereArgs * this_object = I_FACE_LOG_LOAD_LOG_BY_WHERE_ARGS(object);
  gboolean isset_startRow = FALSE;
  gboolean isset_numRows = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->where != NULL)
          {
            g_free(this_object->where);
            this_object->where = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->where, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_where = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->startRow, error)) < 0)
            return -1;
          xfer += ret;
          isset_startRow = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->numRows, error)) < 0)
            return -1;
          xfer += ret;
          isset_numRows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_startRow)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_numRows)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_load_log_by_where_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadLogByWhereArgs * this_object = I_FACE_LOG_LOAD_LOG_BY_WHERE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadLogByWhereArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->where, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->startRow, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "numRows", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->numRows, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_log_by_where_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogLoadLogByWhereArgs *self = I_FACE_LOG_LOAD_LOG_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_ARGS_WHERE:
      if (self->where != NULL)
        g_free (self->where);
      self->where = g_value_dup_string (value);
      self->__isset_where = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_ARGS_START_ROW:
      self->startRow = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_ARGS_NUM_ROWS:
      self->numRows = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_log_by_where_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogLoadLogByWhereArgs *self = I_FACE_LOG_LOAD_LOG_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_ARGS_WHERE:
      g_value_set_string (value, self->where);
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_ARGS_START_ROW:
      g_value_set_int (value, self->startRow);
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_ARGS_NUM_ROWS:
      g_value_set_int (value, self->numRows);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_log_by_where_args_instance_init (IFaceLogLoadLogByWhereArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->where = NULL;
  object->__isset_where = FALSE;
  object->startRow = 0;
  object->numRows = 0;
}

static void 
i_face_log_load_log_by_where_args_finalize (GObject *object)
{
  IFaceLogLoadLogByWhereArgs *tobject = I_FACE_LOG_LOAD_LOG_BY_WHERE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->where != NULL)
  {
    g_free(tobject->where);
    tobject->where = NULL;
  }
}

static void
i_face_log_load_log_by_where_args_class_init (IFaceLogLoadLogByWhereArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_log_by_where_args_read;
  struct_class->write = i_face_log_load_log_by_where_args_write;

  gobject_class->finalize = i_face_log_load_log_by_where_args_finalize;
  gobject_class->get_property = i_face_log_load_log_by_where_args_get_property;
  gobject_class->set_property = i_face_log_load_log_by_where_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_ARGS_WHERE,
     g_param_spec_string ("where",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_ARGS_START_ROW,
     g_param_spec_int ("startRow",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_ARGS_NUM_ROWS,
     g_param_spec_int ("numRows",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_load_log_by_where_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadLogByWhereArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_log_by_where_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadLogByWhereArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_log_by_where_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadLogByWhereArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadLogByWhereResultProperties
{
  PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_RESULT_0,
  PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_RESULT_EX1
};

/* reads a i_face_log_load_log_by_where_result object */
static gint32
i_face_log_load_log_by_where_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadLogByWhereResult * this_object = I_FACE_LOG_LOAD_LOG_BY_WHERE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              LogBean * _elem111 = NULL;
              if ( _elem111 != NULL)
              {
                g_object_unref (_elem111);
              }
              _elem111 = g_object_new (TYPE_LOG_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem111), protocol, error)) < 0)
              {
                g_object_unref (_elem111);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem111);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_log_by_where_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadLogByWhereResult * this_object = I_FACE_LOG_LOAD_LOG_BY_WHERE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadLogByWhereResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i112;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i112 = 0; i112 < (this_object->success ? this_object->success->len : 0); i112++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i112))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_log_by_where_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogLoadLogByWhereResult *self = I_FACE_LOG_LOAD_LOG_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_log_by_where_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogLoadLogByWhereResult *self = I_FACE_LOG_LOAD_LOG_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_log_by_where_result_instance_init (IFaceLogLoadLogByWhereResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_load_log_by_where_result_finalize (GObject *object)
{
  IFaceLogLoadLogByWhereResult *tobject = I_FACE_LOG_LOAD_LOG_BY_WHERE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_load_log_by_where_result_class_init (IFaceLogLoadLogByWhereResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_log_by_where_result_read;
  struct_class->write = i_face_log_load_log_by_where_result_write;

  gobject_class->finalize = i_face_log_load_log_by_where_result_finalize;
  gobject_class->get_property = i_face_log_load_log_by_where_result_get_property;
  gobject_class->set_property = i_face_log_load_log_by_where_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_LOG_BY_WHERE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_log_by_where_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadLogByWhereResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_log_by_where_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadLogByWhereResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_log_by_where_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadLogByWhereResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadLogLightByVerifyTimeArgsProperties
{
  PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_ARGS_0,
  PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_ARGS_TIMESTAMP,
  PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_ARGS_START_ROW,
  PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_ARGS_NUM_ROWS
};

/* reads a i_face_log_load_log_light_by_verify_time_args object */
static gint32
i_face_log_load_log_light_by_verify_time_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadLogLightByVerifyTimeArgs * this_object = I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_ARGS(object);
  gboolean isset_timestamp = FALSE;
  gboolean isset_startRow = FALSE;
  gboolean isset_numRows = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->startRow, error)) < 0)
            return -1;
          xfer += ret;
          isset_startRow = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->numRows, error)) < 0)
            return -1;
          xfer += ret;
          isset_numRows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_timestamp)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_startRow)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_numRows)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_load_log_light_by_verify_time_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadLogLightByVerifyTimeArgs * this_object = I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadLogLightByVerifyTimeArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->startRow, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "numRows", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->numRows, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_log_light_by_verify_time_args_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogLoadLogLightByVerifyTimeArgs *self = I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_ARGS_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_ARGS_START_ROW:
      self->startRow = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_ARGS_NUM_ROWS:
      self->numRows = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_log_light_by_verify_time_args_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogLoadLogLightByVerifyTimeArgs *self = I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_ARGS_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_ARGS_START_ROW:
      g_value_set_int (value, self->startRow);
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_ARGS_NUM_ROWS:
      g_value_set_int (value, self->numRows);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_log_light_by_verify_time_args_instance_init (IFaceLogLoadLogLightByVerifyTimeArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->timestamp = 0;
  object->startRow = 0;
  object->numRows = 0;
}

static void 
i_face_log_load_log_light_by_verify_time_args_finalize (GObject *object)
{
  IFaceLogLoadLogLightByVerifyTimeArgs *tobject = I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_load_log_light_by_verify_time_args_class_init (IFaceLogLoadLogLightByVerifyTimeArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_log_light_by_verify_time_args_read;
  struct_class->write = i_face_log_load_log_light_by_verify_time_args_write;

  gobject_class->finalize = i_face_log_load_log_light_by_verify_time_args_finalize;
  gobject_class->get_property = i_face_log_load_log_light_by_verify_time_args_get_property;
  gobject_class->set_property = i_face_log_load_log_light_by_verify_time_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_ARGS_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_ARGS_START_ROW,
     g_param_spec_int ("startRow",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_ARGS_NUM_ROWS,
     g_param_spec_int ("numRows",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_load_log_light_by_verify_time_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadLogLightByVerifyTimeArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_log_light_by_verify_time_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadLogLightByVerifyTimeArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_log_light_by_verify_time_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadLogLightByVerifyTimeArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadLogLightByVerifyTimeResultProperties
{
  PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_RESULT_0,
  PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_RESULT_EX1
};

/* reads a i_face_log_load_log_light_by_verify_time_result object */
static gint32
i_face_log_load_log_light_by_verify_time_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadLogLightByVerifyTimeResult * this_object = I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              LogLightBean * _elem113 = NULL;
              if ( _elem113 != NULL)
              {
                g_object_unref (_elem113);
              }
              _elem113 = g_object_new (TYPE_LOG_LIGHT_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem113), protocol, error)) < 0)
              {
                g_object_unref (_elem113);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem113);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_log_light_by_verify_time_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadLogLightByVerifyTimeResult * this_object = I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadLogLightByVerifyTimeResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i114;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i114 = 0; i114 < (this_object->success ? this_object->success->len : 0); i114++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i114))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_log_light_by_verify_time_result_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  IFaceLogLoadLogLightByVerifyTimeResult *self = I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_log_light_by_verify_time_result_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  IFaceLogLoadLogLightByVerifyTimeResult *self = I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_log_light_by_verify_time_result_instance_init (IFaceLogLoadLogLightByVerifyTimeResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_load_log_light_by_verify_time_result_finalize (GObject *object)
{
  IFaceLogLoadLogLightByVerifyTimeResult *tobject = I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_load_log_light_by_verify_time_result_class_init (IFaceLogLoadLogLightByVerifyTimeResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_log_light_by_verify_time_result_read;
  struct_class->write = i_face_log_load_log_light_by_verify_time_result_write;

  gobject_class->finalize = i_face_log_load_log_light_by_verify_time_result_finalize;
  gobject_class->get_property = i_face_log_load_log_light_by_verify_time_result_get_property;
  gobject_class->set_property = i_face_log_load_log_light_by_verify_time_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_log_light_by_verify_time_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadLogLightByVerifyTimeResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_log_light_by_verify_time_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadLogLightByVerifyTimeResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_log_light_by_verify_time_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadLogLightByVerifyTimeResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadLogLightByVerifyTimeTimestrArgsProperties
{
  PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS_0,
  PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS_TIMESTAMP,
  PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS_START_ROW,
  PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS_NUM_ROWS
};

/* reads a i_face_log_load_log_light_by_verify_time_timestr_args object */
static gint32
i_face_log_load_log_light_by_verify_time_timestr_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadLogLightByVerifyTimeTimestrArgs * this_object = I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS(object);
  gboolean isset_startRow = FALSE;
  gboolean isset_numRows = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->timestamp != NULL)
          {
            g_free(this_object->timestamp);
            this_object->timestamp = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->startRow, error)) < 0)
            return -1;
          xfer += ret;
          isset_startRow = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->numRows, error)) < 0)
            return -1;
          xfer += ret;
          isset_numRows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_startRow)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_numRows)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_load_log_light_by_verify_time_timestr_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadLogLightByVerifyTimeTimestrArgs * this_object = I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadLogLightByVerifyTimeTimestrArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->startRow, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "numRows", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->numRows, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_log_light_by_verify_time_timestr_args_set_property (GObject *object,
                                                                    guint property_id,
                                                                    const GValue *value,
                                                                    GParamSpec *pspec)
{
  IFaceLogLoadLogLightByVerifyTimeTimestrArgs *self = I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS_TIMESTAMP:
      if (self->timestamp != NULL)
        g_free (self->timestamp);
      self->timestamp = g_value_dup_string (value);
      self->__isset_timestamp = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS_START_ROW:
      self->startRow = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS_NUM_ROWS:
      self->numRows = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_log_light_by_verify_time_timestr_args_get_property (GObject *object,
                                                                    guint property_id,
                                                                    GValue *value,
                                                                    GParamSpec *pspec)
{
  IFaceLogLoadLogLightByVerifyTimeTimestrArgs *self = I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS_TIMESTAMP:
      g_value_set_string (value, self->timestamp);
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS_START_ROW:
      g_value_set_int (value, self->startRow);
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS_NUM_ROWS:
      g_value_set_int (value, self->numRows);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_log_light_by_verify_time_timestr_args_instance_init (IFaceLogLoadLogLightByVerifyTimeTimestrArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->timestamp = NULL;
  object->__isset_timestamp = FALSE;
  object->startRow = 0;
  object->numRows = 0;
}

static void 
i_face_log_load_log_light_by_verify_time_timestr_args_finalize (GObject *object)
{
  IFaceLogLoadLogLightByVerifyTimeTimestrArgs *tobject = I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->timestamp != NULL)
  {
    g_free(tobject->timestamp);
    tobject->timestamp = NULL;
  }
}

static void
i_face_log_load_log_light_by_verify_time_timestr_args_class_init (IFaceLogLoadLogLightByVerifyTimeTimestrArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_log_light_by_verify_time_timestr_args_read;
  struct_class->write = i_face_log_load_log_light_by_verify_time_timestr_args_write;

  gobject_class->finalize = i_face_log_load_log_light_by_verify_time_timestr_args_finalize;
  gobject_class->get_property = i_face_log_load_log_light_by_verify_time_timestr_args_get_property;
  gobject_class->set_property = i_face_log_load_log_light_by_verify_time_timestr_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS_TIMESTAMP,
     g_param_spec_string ("timestamp",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS_START_ROW,
     g_param_spec_int ("startRow",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS_NUM_ROWS,
     g_param_spec_int ("numRows",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_load_log_light_by_verify_time_timestr_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadLogLightByVerifyTimeTimestrArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_log_light_by_verify_time_timestr_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadLogLightByVerifyTimeTimestrArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_log_light_by_verify_time_timestr_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadLogLightByVerifyTimeTimestrArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadLogLightByVerifyTimeTimestrResultProperties
{
  PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT_0,
  PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT_EX1
};

/* reads a i_face_log_load_log_light_by_verify_time_timestr_result object */
static gint32
i_face_log_load_log_light_by_verify_time_timestr_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadLogLightByVerifyTimeTimestrResult * this_object = I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              LogLightBean * _elem115 = NULL;
              if ( _elem115 != NULL)
              {
                g_object_unref (_elem115);
              }
              _elem115 = g_object_new (TYPE_LOG_LIGHT_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem115), protocol, error)) < 0)
              {
                g_object_unref (_elem115);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem115);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_log_light_by_verify_time_timestr_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadLogLightByVerifyTimeTimestrResult * this_object = I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadLogLightByVerifyTimeTimestrResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i116;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i116 = 0; i116 < (this_object->success ? this_object->success->len : 0); i116++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i116))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_log_light_by_verify_time_timestr_result_set_property (GObject *object,
                                                                      guint property_id,
                                                                      const GValue *value,
                                                                      GParamSpec *pspec)
{
  IFaceLogLoadLogLightByVerifyTimeTimestrResult *self = I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_log_light_by_verify_time_timestr_result_get_property (GObject *object,
                                                                      guint property_id,
                                                                      GValue *value,
                                                                      GParamSpec *pspec)
{
  IFaceLogLoadLogLightByVerifyTimeTimestrResult *self = I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_log_light_by_verify_time_timestr_result_instance_init (IFaceLogLoadLogLightByVerifyTimeTimestrResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_load_log_light_by_verify_time_timestr_result_finalize (GObject *object)
{
  IFaceLogLoadLogLightByVerifyTimeTimestrResult *tobject = I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_load_log_light_by_verify_time_timestr_result_class_init (IFaceLogLoadLogLightByVerifyTimeTimestrResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_log_light_by_verify_time_timestr_result_read;
  struct_class->write = i_face_log_load_log_light_by_verify_time_timestr_result_write;

  gobject_class->finalize = i_face_log_load_log_light_by_verify_time_timestr_result_finalize;
  gobject_class->get_property = i_face_log_load_log_light_by_verify_time_timestr_result_get_property;
  gobject_class->set_property = i_face_log_load_log_light_by_verify_time_timestr_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_log_light_by_verify_time_timestr_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadLogLightByVerifyTimeTimestrResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_log_light_by_verify_time_timestr_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadLogLightByVerifyTimeTimestrResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_log_light_by_verify_time_timestr_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadLogLightByVerifyTimeTimestrResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadLogLightByWhereArgsProperties
{
  PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_ARGS_0,
  PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_ARGS_WHERE,
  PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_ARGS_START_ROW,
  PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_ARGS_NUM_ROWS
};

/* reads a i_face_log_load_log_light_by_where_args object */
static gint32
i_face_log_load_log_light_by_where_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadLogLightByWhereArgs * this_object = I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_ARGS(object);
  gboolean isset_startRow = FALSE;
  gboolean isset_numRows = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->where != NULL)
          {
            g_free(this_object->where);
            this_object->where = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->where, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_where = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->startRow, error)) < 0)
            return -1;
          xfer += ret;
          isset_startRow = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->numRows, error)) < 0)
            return -1;
          xfer += ret;
          isset_numRows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_startRow)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_numRows)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_load_log_light_by_where_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadLogLightByWhereArgs * this_object = I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadLogLightByWhereArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->where, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->startRow, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "numRows", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->numRows, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_log_light_by_where_args_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  IFaceLogLoadLogLightByWhereArgs *self = I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_ARGS_WHERE:
      if (self->where != NULL)
        g_free (self->where);
      self->where = g_value_dup_string (value);
      self->__isset_where = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_ARGS_START_ROW:
      self->startRow = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_ARGS_NUM_ROWS:
      self->numRows = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_log_light_by_where_args_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  IFaceLogLoadLogLightByWhereArgs *self = I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_ARGS_WHERE:
      g_value_set_string (value, self->where);
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_ARGS_START_ROW:
      g_value_set_int (value, self->startRow);
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_ARGS_NUM_ROWS:
      g_value_set_int (value, self->numRows);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_log_light_by_where_args_instance_init (IFaceLogLoadLogLightByWhereArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->where = NULL;
  object->__isset_where = FALSE;
  object->startRow = 0;
  object->numRows = 0;
}

static void 
i_face_log_load_log_light_by_where_args_finalize (GObject *object)
{
  IFaceLogLoadLogLightByWhereArgs *tobject = I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->where != NULL)
  {
    g_free(tobject->where);
    tobject->where = NULL;
  }
}

static void
i_face_log_load_log_light_by_where_args_class_init (IFaceLogLoadLogLightByWhereArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_log_light_by_where_args_read;
  struct_class->write = i_face_log_load_log_light_by_where_args_write;

  gobject_class->finalize = i_face_log_load_log_light_by_where_args_finalize;
  gobject_class->get_property = i_face_log_load_log_light_by_where_args_get_property;
  gobject_class->set_property = i_face_log_load_log_light_by_where_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_ARGS_WHERE,
     g_param_spec_string ("where",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_ARGS_START_ROW,
     g_param_spec_int ("startRow",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_ARGS_NUM_ROWS,
     g_param_spec_int ("numRows",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_load_log_light_by_where_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadLogLightByWhereArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_log_light_by_where_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadLogLightByWhereArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_log_light_by_where_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadLogLightByWhereArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadLogLightByWhereResultProperties
{
  PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_RESULT_0,
  PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_RESULT_EX1
};

/* reads a i_face_log_load_log_light_by_where_result object */
static gint32
i_face_log_load_log_light_by_where_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadLogLightByWhereResult * this_object = I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              LogLightBean * _elem117 = NULL;
              if ( _elem117 != NULL)
              {
                g_object_unref (_elem117);
              }
              _elem117 = g_object_new (TYPE_LOG_LIGHT_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem117), protocol, error)) < 0)
              {
                g_object_unref (_elem117);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem117);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_log_light_by_where_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadLogLightByWhereResult * this_object = I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadLogLightByWhereResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i118;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i118 = 0; i118 < (this_object->success ? this_object->success->len : 0); i118++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i118))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_log_light_by_where_result_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  IFaceLogLoadLogLightByWhereResult *self = I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_log_light_by_where_result_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  IFaceLogLoadLogLightByWhereResult *self = I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_log_light_by_where_result_instance_init (IFaceLogLoadLogLightByWhereResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_load_log_light_by_where_result_finalize (GObject *object)
{
  IFaceLogLoadLogLightByWhereResult *tobject = I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_load_log_light_by_where_result_class_init (IFaceLogLoadLogLightByWhereResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_log_light_by_where_result_read;
  struct_class->write = i_face_log_load_log_light_by_where_result_write;

  gobject_class->finalize = i_face_log_load_log_light_by_where_result_finalize;
  gobject_class->get_property = i_face_log_load_log_light_by_where_result_get_property;
  gobject_class->set_property = i_face_log_load_log_light_by_where_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_log_light_by_where_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadLogLightByWhereResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_log_light_by_where_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadLogLightByWhereResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_log_light_by_where_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadLogLightByWhereResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadPermitByUpdateArgsProperties
{
  PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_ARGS_0,
  PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_ARGS_TIMESTAMP
};

/* reads a i_face_log_load_permit_by_update_args object */
static gint32
i_face_log_load_permit_by_update_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadPermitByUpdateArgs * this_object = I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_ARGS(object);
  gboolean isset_timestamp = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_timestamp)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_load_permit_by_update_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadPermitByUpdateArgs * this_object = I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadPermitByUpdateArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_permit_by_update_args_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogLoadPermitByUpdateArgs *self = I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_ARGS_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_permit_by_update_args_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogLoadPermitByUpdateArgs *self = I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_ARGS_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_permit_by_update_args_instance_init (IFaceLogLoadPermitByUpdateArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->timestamp = 0;
}

static void 
i_face_log_load_permit_by_update_args_finalize (GObject *object)
{
  IFaceLogLoadPermitByUpdateArgs *tobject = I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_load_permit_by_update_args_class_init (IFaceLogLoadPermitByUpdateArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_permit_by_update_args_read;
  struct_class->write = i_face_log_load_permit_by_update_args_write;

  gobject_class->finalize = i_face_log_load_permit_by_update_args_finalize;
  gobject_class->get_property = i_face_log_load_permit_by_update_args_get_property;
  gobject_class->set_property = i_face_log_load_permit_by_update_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_ARGS_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_permit_by_update_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadPermitByUpdateArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_permit_by_update_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadPermitByUpdateArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_permit_by_update_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadPermitByUpdateArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadPermitByUpdateResultProperties
{
  PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_RESULT_0,
  PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_RESULT_EX1
};

/* reads a i_face_log_load_permit_by_update_result object */
static gint32
i_face_log_load_permit_by_update_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadPermitByUpdateResult * this_object = I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              PermitBean * _elem119 = NULL;
              if ( _elem119 != NULL)
              {
                g_object_unref (_elem119);
              }
              _elem119 = g_object_new (TYPE_PERMIT_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem119), protocol, error)) < 0)
              {
                g_object_unref (_elem119);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem119);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_permit_by_update_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadPermitByUpdateResult * this_object = I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadPermitByUpdateResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i120;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i120 = 0; i120 < (this_object->success ? this_object->success->len : 0); i120++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i120))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_permit_by_update_result_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  IFaceLogLoadPermitByUpdateResult *self = I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_permit_by_update_result_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  IFaceLogLoadPermitByUpdateResult *self = I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_permit_by_update_result_instance_init (IFaceLogLoadPermitByUpdateResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_load_permit_by_update_result_finalize (GObject *object)
{
  IFaceLogLoadPermitByUpdateResult *tobject = I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_load_permit_by_update_result_class_init (IFaceLogLoadPermitByUpdateResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_permit_by_update_result_read;
  struct_class->write = i_face_log_load_permit_by_update_result_write;

  gobject_class->finalize = i_face_log_load_permit_by_update_result_finalize;
  gobject_class->get_property = i_face_log_load_permit_by_update_result_get_property;
  gobject_class->set_property = i_face_log_load_permit_by_update_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_permit_by_update_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadPermitByUpdateResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_permit_by_update_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadPermitByUpdateResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_permit_by_update_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadPermitByUpdateResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadPermitByUpdateTimestrArgsProperties
{
  PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_ARGS_0,
  PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_ARGS_TIMESTAMP
};

/* reads a i_face_log_load_permit_by_update_timestr_args object */
static gint32
i_face_log_load_permit_by_update_timestr_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadPermitByUpdateTimestrArgs * this_object = I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->timestamp != NULL)
          {
            g_free(this_object->timestamp);
            this_object->timestamp = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_permit_by_update_timestr_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadPermitByUpdateTimestrArgs * this_object = I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadPermitByUpdateTimestrArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_permit_by_update_timestr_args_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogLoadPermitByUpdateTimestrArgs *self = I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_ARGS_TIMESTAMP:
      if (self->timestamp != NULL)
        g_free (self->timestamp);
      self->timestamp = g_value_dup_string (value);
      self->__isset_timestamp = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_permit_by_update_timestr_args_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogLoadPermitByUpdateTimestrArgs *self = I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_ARGS_TIMESTAMP:
      g_value_set_string (value, self->timestamp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_permit_by_update_timestr_args_instance_init (IFaceLogLoadPermitByUpdateTimestrArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->timestamp = NULL;
  object->__isset_timestamp = FALSE;
}

static void 
i_face_log_load_permit_by_update_timestr_args_finalize (GObject *object)
{
  IFaceLogLoadPermitByUpdateTimestrArgs *tobject = I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->timestamp != NULL)
  {
    g_free(tobject->timestamp);
    tobject->timestamp = NULL;
  }
}

static void
i_face_log_load_permit_by_update_timestr_args_class_init (IFaceLogLoadPermitByUpdateTimestrArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_permit_by_update_timestr_args_read;
  struct_class->write = i_face_log_load_permit_by_update_timestr_args_write;

  gobject_class->finalize = i_face_log_load_permit_by_update_timestr_args_finalize;
  gobject_class->get_property = i_face_log_load_permit_by_update_timestr_args_get_property;
  gobject_class->set_property = i_face_log_load_permit_by_update_timestr_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_ARGS_TIMESTAMP,
     g_param_spec_string ("timestamp",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_load_permit_by_update_timestr_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadPermitByUpdateTimestrArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_permit_by_update_timestr_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadPermitByUpdateTimestrArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_permit_by_update_timestr_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadPermitByUpdateTimestrArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadPermitByUpdateTimestrResultProperties
{
  PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_RESULT_0,
  PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_RESULT_EX1
};

/* reads a i_face_log_load_permit_by_update_timestr_result object */
static gint32
i_face_log_load_permit_by_update_timestr_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadPermitByUpdateTimestrResult * this_object = I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              PermitBean * _elem121 = NULL;
              if ( _elem121 != NULL)
              {
                g_object_unref (_elem121);
              }
              _elem121 = g_object_new (TYPE_PERMIT_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem121), protocol, error)) < 0)
              {
                g_object_unref (_elem121);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem121);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_permit_by_update_timestr_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadPermitByUpdateTimestrResult * this_object = I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadPermitByUpdateTimestrResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i122;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i122 = 0; i122 < (this_object->success ? this_object->success->len : 0); i122++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i122))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_permit_by_update_timestr_result_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  IFaceLogLoadPermitByUpdateTimestrResult *self = I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_permit_by_update_timestr_result_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  IFaceLogLoadPermitByUpdateTimestrResult *self = I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_permit_by_update_timestr_result_instance_init (IFaceLogLoadPermitByUpdateTimestrResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_load_permit_by_update_timestr_result_finalize (GObject *object)
{
  IFaceLogLoadPermitByUpdateTimestrResult *tobject = I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_load_permit_by_update_timestr_result_class_init (IFaceLogLoadPermitByUpdateTimestrResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_permit_by_update_timestr_result_read;
  struct_class->write = i_face_log_load_permit_by_update_timestr_result_write;

  gobject_class->finalize = i_face_log_load_permit_by_update_timestr_result_finalize;
  gobject_class->get_property = i_face_log_load_permit_by_update_timestr_result_get_property;
  gobject_class->set_property = i_face_log_load_permit_by_update_timestr_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_permit_by_update_timestr_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadPermitByUpdateTimestrResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_permit_by_update_timestr_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadPermitByUpdateTimestrResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_permit_by_update_timestr_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadPermitByUpdateTimestrResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadPersonByWhereArgsProperties
{
  PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_ARGS_0,
  PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_ARGS_WHERE,
  PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_ARGS_START_ROW,
  PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_ARGS_NUM_ROWS
};

/* reads a i_face_log_load_person_by_where_args object */
static gint32
i_face_log_load_person_by_where_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadPersonByWhereArgs * this_object = I_FACE_LOG_LOAD_PERSON_BY_WHERE_ARGS(object);
  gboolean isset_startRow = FALSE;
  gboolean isset_numRows = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->where != NULL)
          {
            g_free(this_object->where);
            this_object->where = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->where, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_where = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->startRow, error)) < 0)
            return -1;
          xfer += ret;
          isset_startRow = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->numRows, error)) < 0)
            return -1;
          xfer += ret;
          isset_numRows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_startRow)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_numRows)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_load_person_by_where_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadPersonByWhereArgs * this_object = I_FACE_LOG_LOAD_PERSON_BY_WHERE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadPersonByWhereArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->where, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->startRow, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "numRows", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->numRows, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_person_by_where_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogLoadPersonByWhereArgs *self = I_FACE_LOG_LOAD_PERSON_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_ARGS_WHERE:
      if (self->where != NULL)
        g_free (self->where);
      self->where = g_value_dup_string (value);
      self->__isset_where = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_ARGS_START_ROW:
      self->startRow = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_ARGS_NUM_ROWS:
      self->numRows = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_person_by_where_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogLoadPersonByWhereArgs *self = I_FACE_LOG_LOAD_PERSON_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_ARGS_WHERE:
      g_value_set_string (value, self->where);
      break;

    case PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_ARGS_START_ROW:
      g_value_set_int (value, self->startRow);
      break;

    case PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_ARGS_NUM_ROWS:
      g_value_set_int (value, self->numRows);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_person_by_where_args_instance_init (IFaceLogLoadPersonByWhereArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->where = NULL;
  object->__isset_where = FALSE;
  object->startRow = 0;
  object->numRows = 0;
}

static void 
i_face_log_load_person_by_where_args_finalize (GObject *object)
{
  IFaceLogLoadPersonByWhereArgs *tobject = I_FACE_LOG_LOAD_PERSON_BY_WHERE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->where != NULL)
  {
    g_free(tobject->where);
    tobject->where = NULL;
  }
}

static void
i_face_log_load_person_by_where_args_class_init (IFaceLogLoadPersonByWhereArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_person_by_where_args_read;
  struct_class->write = i_face_log_load_person_by_where_args_write;

  gobject_class->finalize = i_face_log_load_person_by_where_args_finalize;
  gobject_class->get_property = i_face_log_load_person_by_where_args_get_property;
  gobject_class->set_property = i_face_log_load_person_by_where_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_ARGS_WHERE,
     g_param_spec_string ("where",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_ARGS_START_ROW,
     g_param_spec_int ("startRow",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_ARGS_NUM_ROWS,
     g_param_spec_int ("numRows",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_load_person_by_where_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadPersonByWhereArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_person_by_where_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadPersonByWhereArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_person_by_where_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadPersonByWhereArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadPersonByWhereResultProperties
{
  PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_RESULT_0,
  PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_RESULT_EX1
};

/* reads a i_face_log_load_person_by_where_result object */
static gint32
i_face_log_load_person_by_where_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadPersonByWhereResult * this_object = I_FACE_LOG_LOAD_PERSON_BY_WHERE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              PersonBean * _elem123 = NULL;
              if ( _elem123 != NULL)
              {
                g_object_unref (_elem123);
              }
              _elem123 = g_object_new (TYPE_PERSON_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem123), protocol, error)) < 0)
              {
                g_object_unref (_elem123);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem123);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_person_by_where_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadPersonByWhereResult * this_object = I_FACE_LOG_LOAD_PERSON_BY_WHERE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadPersonByWhereResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i124;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i124 = 0; i124 < (this_object->success ? this_object->success->len : 0); i124++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i124))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_person_by_where_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogLoadPersonByWhereResult *self = I_FACE_LOG_LOAD_PERSON_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_person_by_where_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogLoadPersonByWhereResult *self = I_FACE_LOG_LOAD_PERSON_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_person_by_where_result_instance_init (IFaceLogLoadPersonByWhereResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_load_person_by_where_result_finalize (GObject *object)
{
  IFaceLogLoadPersonByWhereResult *tobject = I_FACE_LOG_LOAD_PERSON_BY_WHERE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_load_person_by_where_result_class_init (IFaceLogLoadPersonByWhereResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_person_by_where_result_read;
  struct_class->write = i_face_log_load_person_by_where_result_write;

  gobject_class->finalize = i_face_log_load_person_by_where_result_finalize;
  gobject_class->get_property = i_face_log_load_person_by_where_result_get_property;
  gobject_class->set_property = i_face_log_load_person_by_where_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_BY_WHERE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_person_by_where_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadPersonByWhereResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_person_by_where_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadPersonByWhereResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_person_by_where_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadPersonByWhereResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadPersonGroupByWhereArgsProperties
{
  PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_ARGS_0,
  PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_ARGS_WHERE,
  PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_ARGS_START_ROW,
  PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_ARGS_NUM_ROWS
};

/* reads a i_face_log_load_person_group_by_where_args object */
static gint32
i_face_log_load_person_group_by_where_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadPersonGroupByWhereArgs * this_object = I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_ARGS(object);
  gboolean isset_startRow = FALSE;
  gboolean isset_numRows = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->where != NULL)
          {
            g_free(this_object->where);
            this_object->where = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->where, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_where = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->startRow, error)) < 0)
            return -1;
          xfer += ret;
          isset_startRow = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->numRows, error)) < 0)
            return -1;
          xfer += ret;
          isset_numRows = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_startRow)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_numRows)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_load_person_group_by_where_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadPersonGroupByWhereArgs * this_object = I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadPersonGroupByWhereArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->where, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->startRow, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "numRows", T_I32, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->numRows, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_person_group_by_where_args_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  IFaceLogLoadPersonGroupByWhereArgs *self = I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_ARGS_WHERE:
      if (self->where != NULL)
        g_free (self->where);
      self->where = g_value_dup_string (value);
      self->__isset_where = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_ARGS_START_ROW:
      self->startRow = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_ARGS_NUM_ROWS:
      self->numRows = g_value_get_int (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_person_group_by_where_args_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  IFaceLogLoadPersonGroupByWhereArgs *self = I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_ARGS_WHERE:
      g_value_set_string (value, self->where);
      break;

    case PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_ARGS_START_ROW:
      g_value_set_int (value, self->startRow);
      break;

    case PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_ARGS_NUM_ROWS:
      g_value_set_int (value, self->numRows);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_person_group_by_where_args_instance_init (IFaceLogLoadPersonGroupByWhereArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->where = NULL;
  object->__isset_where = FALSE;
  object->startRow = 0;
  object->numRows = 0;
}

static void 
i_face_log_load_person_group_by_where_args_finalize (GObject *object)
{
  IFaceLogLoadPersonGroupByWhereArgs *tobject = I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->where != NULL)
  {
    g_free(tobject->where);
    tobject->where = NULL;
  }
}

static void
i_face_log_load_person_group_by_where_args_class_init (IFaceLogLoadPersonGroupByWhereArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_person_group_by_where_args_read;
  struct_class->write = i_face_log_load_person_group_by_where_args_write;

  gobject_class->finalize = i_face_log_load_person_group_by_where_args_finalize;
  gobject_class->get_property = i_face_log_load_person_group_by_where_args_get_property;
  gobject_class->set_property = i_face_log_load_person_group_by_where_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_ARGS_WHERE,
     g_param_spec_string ("where",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_ARGS_START_ROW,
     g_param_spec_int ("startRow",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_ARGS_NUM_ROWS,
     g_param_spec_int ("numRows",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_load_person_group_by_where_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadPersonGroupByWhereArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_person_group_by_where_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadPersonGroupByWhereArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_person_group_by_where_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadPersonGroupByWhereArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadPersonGroupByWhereResultProperties
{
  PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_RESULT_0,
  PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_RESULT_EX1
};

/* reads a i_face_log_load_person_group_by_where_result object */
static gint32
i_face_log_load_person_group_by_where_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadPersonGroupByWhereResult * this_object = I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem125 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem125, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem125, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_person_group_by_where_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadPersonGroupByWhereResult * this_object = I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadPersonGroupByWhereResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i126;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i126 = 0; i126 < (this_object->success ? this_object->success->len : 0); i126++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i126)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_person_group_by_where_result_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  IFaceLogLoadPersonGroupByWhereResult *self = I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_person_group_by_where_result_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  IFaceLogLoadPersonGroupByWhereResult *self = I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_person_group_by_where_result_instance_init (IFaceLogLoadPersonGroupByWhereResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_load_person_group_by_where_result_finalize (GObject *object)
{
  IFaceLogLoadPersonGroupByWhereResult *tobject = I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_load_person_group_by_where_result_class_init (IFaceLogLoadPersonGroupByWhereResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_person_group_by_where_result_read;
  struct_class->write = i_face_log_load_person_group_by_where_result_write;

  gobject_class->finalize = i_face_log_load_person_group_by_where_result_finalize;
  gobject_class->get_property = i_face_log_load_person_group_by_where_result_get_property;
  gobject_class->set_property = i_face_log_load_person_group_by_where_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_person_group_by_where_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadPersonGroupByWhereResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_person_group_by_where_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadPersonGroupByWhereResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_person_group_by_where_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadPersonGroupByWhereResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadPersonGroupIdByWhereArgsProperties
{
  PROP_I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_ARGS_0,
  PROP_I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_ARGS_WHERE
};

/* reads a i_face_log_load_person_group_id_by_where_args object */
static gint32
i_face_log_load_person_group_id_by_where_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadPersonGroupIdByWhereArgs * this_object = I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->where != NULL)
          {
            g_free(this_object->where);
            this_object->where = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->where, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_where = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_person_group_id_by_where_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadPersonGroupIdByWhereArgs * this_object = I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadPersonGroupIdByWhereArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->where, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_person_group_id_by_where_args_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogLoadPersonGroupIdByWhereArgs *self = I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_ARGS_WHERE:
      if (self->where != NULL)
        g_free (self->where);
      self->where = g_value_dup_string (value);
      self->__isset_where = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_person_group_id_by_where_args_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogLoadPersonGroupIdByWhereArgs *self = I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_ARGS_WHERE:
      g_value_set_string (value, self->where);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_person_group_id_by_where_args_instance_init (IFaceLogLoadPersonGroupIdByWhereArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->where = NULL;
  object->__isset_where = FALSE;
}

static void 
i_face_log_load_person_group_id_by_where_args_finalize (GObject *object)
{
  IFaceLogLoadPersonGroupIdByWhereArgs *tobject = I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->where != NULL)
  {
    g_free(tobject->where);
    tobject->where = NULL;
  }
}

static void
i_face_log_load_person_group_id_by_where_args_class_init (IFaceLogLoadPersonGroupIdByWhereArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_person_group_id_by_where_args_read;
  struct_class->write = i_face_log_load_person_group_id_by_where_args_write;

  gobject_class->finalize = i_face_log_load_person_group_id_by_where_args_finalize;
  gobject_class->get_property = i_face_log_load_person_group_id_by_where_args_get_property;
  gobject_class->set_property = i_face_log_load_person_group_id_by_where_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_ARGS_WHERE,
     g_param_spec_string ("where",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_load_person_group_id_by_where_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadPersonGroupIdByWhereArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_person_group_id_by_where_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadPersonGroupIdByWhereArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_person_group_id_by_where_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadPersonGroupIdByWhereArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadPersonGroupIdByWhereResultProperties
{
  PROP_I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_RESULT_0,
  PROP_I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_RESULT_EX1
};

/* reads a i_face_log_load_person_group_id_by_where_result object */
static gint32
i_face_log_load_person_group_id_by_where_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadPersonGroupIdByWhereResult * this_object = I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem127 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem127, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem127, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_person_group_id_by_where_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadPersonGroupIdByWhereResult * this_object = I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadPersonGroupIdByWhereResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i128;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i128 = 0; i128 < (this_object->success ? this_object->success->len : 0); i128++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i128)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_person_group_id_by_where_result_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  IFaceLogLoadPersonGroupIdByWhereResult *self = I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_person_group_id_by_where_result_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  IFaceLogLoadPersonGroupIdByWhereResult *self = I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_person_group_id_by_where_result_instance_init (IFaceLogLoadPersonGroupIdByWhereResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_load_person_group_id_by_where_result_finalize (GObject *object)
{
  IFaceLogLoadPersonGroupIdByWhereResult *tobject = I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_load_person_group_id_by_where_result_class_init (IFaceLogLoadPersonGroupIdByWhereResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_person_group_id_by_where_result_read;
  struct_class->write = i_face_log_load_person_group_id_by_where_result_write;

  gobject_class->finalize = i_face_log_load_person_group_id_by_where_result_finalize;
  gobject_class->get_property = i_face_log_load_person_group_id_by_where_result_get_property;
  gobject_class->set_property = i_face_log_load_person_group_id_by_where_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_person_group_id_by_where_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadPersonGroupIdByWhereResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_person_group_id_by_where_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadPersonGroupIdByWhereResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_person_group_id_by_where_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadPersonGroupIdByWhereResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadPersonIdByUpdateTimeArgsProperties
{
  PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_ARGS_0,
  PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_ARGS_TIMESTAMP
};

/* reads a i_face_log_load_person_id_by_update_time_args object */
static gint32
i_face_log_load_person_id_by_update_time_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadPersonIdByUpdateTimeArgs * this_object = I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_ARGS(object);
  gboolean isset_timestamp = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_timestamp)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_load_person_id_by_update_time_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadPersonIdByUpdateTimeArgs * this_object = I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadPersonIdByUpdateTimeArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_person_id_by_update_time_args_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogLoadPersonIdByUpdateTimeArgs *self = I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_ARGS_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_person_id_by_update_time_args_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogLoadPersonIdByUpdateTimeArgs *self = I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_ARGS_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_person_id_by_update_time_args_instance_init (IFaceLogLoadPersonIdByUpdateTimeArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->timestamp = 0;
}

static void 
i_face_log_load_person_id_by_update_time_args_finalize (GObject *object)
{
  IFaceLogLoadPersonIdByUpdateTimeArgs *tobject = I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_load_person_id_by_update_time_args_class_init (IFaceLogLoadPersonIdByUpdateTimeArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_person_id_by_update_time_args_read;
  struct_class->write = i_face_log_load_person_id_by_update_time_args_write;

  gobject_class->finalize = i_face_log_load_person_id_by_update_time_args_finalize;
  gobject_class->get_property = i_face_log_load_person_id_by_update_time_args_get_property;
  gobject_class->set_property = i_face_log_load_person_id_by_update_time_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_ARGS_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_person_id_by_update_time_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadPersonIdByUpdateTimeArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_person_id_by_update_time_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadPersonIdByUpdateTimeArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_person_id_by_update_time_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadPersonIdByUpdateTimeArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadPersonIdByUpdateTimeResultProperties
{
  PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_RESULT_0,
  PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_RESULT_EX1
};

/* reads a i_face_log_load_person_id_by_update_time_result object */
static gint32
i_face_log_load_person_id_by_update_time_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadPersonIdByUpdateTimeResult * this_object = I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem129 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem129, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem129, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_person_id_by_update_time_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadPersonIdByUpdateTimeResult * this_object = I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadPersonIdByUpdateTimeResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i130;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i130 = 0; i130 < (this_object->success ? this_object->success->len : 0); i130++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i130)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_person_id_by_update_time_result_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  IFaceLogLoadPersonIdByUpdateTimeResult *self = I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_person_id_by_update_time_result_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  IFaceLogLoadPersonIdByUpdateTimeResult *self = I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_person_id_by_update_time_result_instance_init (IFaceLogLoadPersonIdByUpdateTimeResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_load_person_id_by_update_time_result_finalize (GObject *object)
{
  IFaceLogLoadPersonIdByUpdateTimeResult *tobject = I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_load_person_id_by_update_time_result_class_init (IFaceLogLoadPersonIdByUpdateTimeResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_person_id_by_update_time_result_read;
  struct_class->write = i_face_log_load_person_id_by_update_time_result_write;

  gobject_class->finalize = i_face_log_load_person_id_by_update_time_result_finalize;
  gobject_class->get_property = i_face_log_load_person_id_by_update_time_result_get_property;
  gobject_class->set_property = i_face_log_load_person_id_by_update_time_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_person_id_by_update_time_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadPersonIdByUpdateTimeResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_person_id_by_update_time_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadPersonIdByUpdateTimeResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_person_id_by_update_time_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadPersonIdByUpdateTimeResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadPersonIdByUpdateTimeTimeStrArgsProperties
{
  PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_ARGS_0,
  PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_ARGS_TIMESTAMP
};

/* reads a i_face_log_load_person_id_by_update_time_time_str_args object */
static gint32
i_face_log_load_person_id_by_update_time_time_str_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadPersonIdByUpdateTimeTimeStrArgs * this_object = I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->timestamp != NULL)
          {
            g_free(this_object->timestamp);
            this_object->timestamp = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_person_id_by_update_time_time_str_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadPersonIdByUpdateTimeTimeStrArgs * this_object = I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadPersonIdByUpdateTimeTimeStrArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_person_id_by_update_time_time_str_args_set_property (GObject *object,
                                                                     guint property_id,
                                                                     const GValue *value,
                                                                     GParamSpec *pspec)
{
  IFaceLogLoadPersonIdByUpdateTimeTimeStrArgs *self = I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_ARGS_TIMESTAMP:
      if (self->timestamp != NULL)
        g_free (self->timestamp);
      self->timestamp = g_value_dup_string (value);
      self->__isset_timestamp = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_person_id_by_update_time_time_str_args_get_property (GObject *object,
                                                                     guint property_id,
                                                                     GValue *value,
                                                                     GParamSpec *pspec)
{
  IFaceLogLoadPersonIdByUpdateTimeTimeStrArgs *self = I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_ARGS_TIMESTAMP:
      g_value_set_string (value, self->timestamp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_person_id_by_update_time_time_str_args_instance_init (IFaceLogLoadPersonIdByUpdateTimeTimeStrArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->timestamp = NULL;
  object->__isset_timestamp = FALSE;
}

static void 
i_face_log_load_person_id_by_update_time_time_str_args_finalize (GObject *object)
{
  IFaceLogLoadPersonIdByUpdateTimeTimeStrArgs *tobject = I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->timestamp != NULL)
  {
    g_free(tobject->timestamp);
    tobject->timestamp = NULL;
  }
}

static void
i_face_log_load_person_id_by_update_time_time_str_args_class_init (IFaceLogLoadPersonIdByUpdateTimeTimeStrArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_person_id_by_update_time_time_str_args_read;
  struct_class->write = i_face_log_load_person_id_by_update_time_time_str_args_write;

  gobject_class->finalize = i_face_log_load_person_id_by_update_time_time_str_args_finalize;
  gobject_class->get_property = i_face_log_load_person_id_by_update_time_time_str_args_get_property;
  gobject_class->set_property = i_face_log_load_person_id_by_update_time_time_str_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_ARGS_TIMESTAMP,
     g_param_spec_string ("timestamp",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_load_person_id_by_update_time_time_str_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadPersonIdByUpdateTimeTimeStrArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_person_id_by_update_time_time_str_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadPersonIdByUpdateTimeTimeStrArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_person_id_by_update_time_time_str_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadPersonIdByUpdateTimeTimeStrArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadPersonIdByUpdateTimeTimeStrResultProperties
{
  PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_RESULT_0,
  PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_RESULT_EX1
};

/* reads a i_face_log_load_person_id_by_update_time_time_str_result object */
static gint32
i_face_log_load_person_id_by_update_time_time_str_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadPersonIdByUpdateTimeTimeStrResult * this_object = I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem131 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem131, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem131, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_person_id_by_update_time_time_str_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadPersonIdByUpdateTimeTimeStrResult * this_object = I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadPersonIdByUpdateTimeTimeStrResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i132;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i132 = 0; i132 < (this_object->success ? this_object->success->len : 0); i132++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i132)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_person_id_by_update_time_time_str_result_set_property (GObject *object,
                                                                       guint property_id,
                                                                       const GValue *value,
                                                                       GParamSpec *pspec)
{
  IFaceLogLoadPersonIdByUpdateTimeTimeStrResult *self = I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_person_id_by_update_time_time_str_result_get_property (GObject *object,
                                                                       guint property_id,
                                                                       GValue *value,
                                                                       GParamSpec *pspec)
{
  IFaceLogLoadPersonIdByUpdateTimeTimeStrResult *self = I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_person_id_by_update_time_time_str_result_instance_init (IFaceLogLoadPersonIdByUpdateTimeTimeStrResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_load_person_id_by_update_time_time_str_result_finalize (GObject *object)
{
  IFaceLogLoadPersonIdByUpdateTimeTimeStrResult *tobject = I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_load_person_id_by_update_time_time_str_result_class_init (IFaceLogLoadPersonIdByUpdateTimeTimeStrResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_person_id_by_update_time_time_str_result_read;
  struct_class->write = i_face_log_load_person_id_by_update_time_time_str_result_write;

  gobject_class->finalize = i_face_log_load_person_id_by_update_time_time_str_result_finalize;
  gobject_class->get_property = i_face_log_load_person_id_by_update_time_time_str_result_get_property;
  gobject_class->set_property = i_face_log_load_person_id_by_update_time_time_str_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_person_id_by_update_time_time_str_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadPersonIdByUpdateTimeTimeStrResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_person_id_by_update_time_time_str_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadPersonIdByUpdateTimeTimeStrResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_person_id_by_update_time_time_str_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadPersonIdByUpdateTimeTimeStrResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadPersonIdByWhereArgsProperties
{
  PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_ARGS_0,
  PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_ARGS_WHERE
};

/* reads a i_face_log_load_person_id_by_where_args object */
static gint32
i_face_log_load_person_id_by_where_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadPersonIdByWhereArgs * this_object = I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->where != NULL)
          {
            g_free(this_object->where);
            this_object->where = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->where, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_where = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_person_id_by_where_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadPersonIdByWhereArgs * this_object = I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadPersonIdByWhereArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->where, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_person_id_by_where_args_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  IFaceLogLoadPersonIdByWhereArgs *self = I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_ARGS_WHERE:
      if (self->where != NULL)
        g_free (self->where);
      self->where = g_value_dup_string (value);
      self->__isset_where = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_person_id_by_where_args_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  IFaceLogLoadPersonIdByWhereArgs *self = I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_ARGS_WHERE:
      g_value_set_string (value, self->where);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_person_id_by_where_args_instance_init (IFaceLogLoadPersonIdByWhereArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->where = NULL;
  object->__isset_where = FALSE;
}

static void 
i_face_log_load_person_id_by_where_args_finalize (GObject *object)
{
  IFaceLogLoadPersonIdByWhereArgs *tobject = I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->where != NULL)
  {
    g_free(tobject->where);
    tobject->where = NULL;
  }
}

static void
i_face_log_load_person_id_by_where_args_class_init (IFaceLogLoadPersonIdByWhereArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_person_id_by_where_args_read;
  struct_class->write = i_face_log_load_person_id_by_where_args_write;

  gobject_class->finalize = i_face_log_load_person_id_by_where_args_finalize;
  gobject_class->get_property = i_face_log_load_person_id_by_where_args_get_property;
  gobject_class->set_property = i_face_log_load_person_id_by_where_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_ARGS_WHERE,
     g_param_spec_string ("where",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_load_person_id_by_where_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadPersonIdByWhereArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_person_id_by_where_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadPersonIdByWhereArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_person_id_by_where_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadPersonIdByWhereArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadPersonIdByWhereResultProperties
{
  PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_RESULT_0,
  PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_RESULT_EX1
};

/* reads a i_face_log_load_person_id_by_where_result object */
static gint32
i_face_log_load_person_id_by_where_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadPersonIdByWhereResult * this_object = I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem133 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem133, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem133, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_person_id_by_where_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadPersonIdByWhereResult * this_object = I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadPersonIdByWhereResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i134;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i134 = 0; i134 < (this_object->success ? this_object->success->len : 0); i134++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i134)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_person_id_by_where_result_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  IFaceLogLoadPersonIdByWhereResult *self = I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_person_id_by_where_result_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  IFaceLogLoadPersonIdByWhereResult *self = I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_person_id_by_where_result_instance_init (IFaceLogLoadPersonIdByWhereResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_load_person_id_by_where_result_finalize (GObject *object)
{
  IFaceLogLoadPersonIdByWhereResult *tobject = I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_load_person_id_by_where_result_class_init (IFaceLogLoadPersonIdByWhereResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_person_id_by_where_result_read;
  struct_class->write = i_face_log_load_person_id_by_where_result_write;

  gobject_class->finalize = i_face_log_load_person_id_by_where_result_finalize;
  gobject_class->get_property = i_face_log_load_person_id_by_where_result_get_property;
  gobject_class->set_property = i_face_log_load_person_id_by_where_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_person_id_by_where_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadPersonIdByWhereResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_person_id_by_where_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadPersonIdByWhereResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_person_id_by_where_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadPersonIdByWhereResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadUpdatedPersonsArgsProperties
{
  PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_ARGS_0,
  PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_ARGS_TIMESTAMP
};

/* reads a i_face_log_load_updated_persons_args object */
static gint32
i_face_log_load_updated_persons_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadUpdatedPersonsArgs * this_object = I_FACE_LOG_LOAD_UPDATED_PERSONS_ARGS(object);
  gboolean isset_timestamp = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_timestamp)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_load_updated_persons_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadUpdatedPersonsArgs * this_object = I_FACE_LOG_LOAD_UPDATED_PERSONS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadUpdatedPersonsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_updated_persons_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogLoadUpdatedPersonsArgs *self = I_FACE_LOG_LOAD_UPDATED_PERSONS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_ARGS_TIMESTAMP:
      self->timestamp = g_value_get_int64 (value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_updated_persons_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogLoadUpdatedPersonsArgs *self = I_FACE_LOG_LOAD_UPDATED_PERSONS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_ARGS_TIMESTAMP:
      g_value_set_int64 (value, self->timestamp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_updated_persons_args_instance_init (IFaceLogLoadUpdatedPersonsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->timestamp = 0;
}

static void 
i_face_log_load_updated_persons_args_finalize (GObject *object)
{
  IFaceLogLoadUpdatedPersonsArgs *tobject = I_FACE_LOG_LOAD_UPDATED_PERSONS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_load_updated_persons_args_class_init (IFaceLogLoadUpdatedPersonsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_updated_persons_args_read;
  struct_class->write = i_face_log_load_updated_persons_args_write;

  gobject_class->finalize = i_face_log_load_updated_persons_args_finalize;
  gobject_class->get_property = i_face_log_load_updated_persons_args_get_property;
  gobject_class->set_property = i_face_log_load_updated_persons_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_ARGS_TIMESTAMP,
     g_param_spec_int64 ("timestamp",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_updated_persons_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadUpdatedPersonsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_updated_persons_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadUpdatedPersonsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_updated_persons_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadUpdatedPersonsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadUpdatedPersonsResultProperties
{
  PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_RESULT_0,
  PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_RESULT_EX1
};

/* reads a i_face_log_load_updated_persons_result object */
static gint32
i_face_log_load_updated_persons_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadUpdatedPersonsResult * this_object = I_FACE_LOG_LOAD_UPDATED_PERSONS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem135 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem135, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem135, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_updated_persons_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadUpdatedPersonsResult * this_object = I_FACE_LOG_LOAD_UPDATED_PERSONS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadUpdatedPersonsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i136;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i136 = 0; i136 < (this_object->success ? this_object->success->len : 0); i136++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i136)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_updated_persons_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogLoadUpdatedPersonsResult *self = I_FACE_LOG_LOAD_UPDATED_PERSONS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_updated_persons_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogLoadUpdatedPersonsResult *self = I_FACE_LOG_LOAD_UPDATED_PERSONS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_updated_persons_result_instance_init (IFaceLogLoadUpdatedPersonsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_load_updated_persons_result_finalize (GObject *object)
{
  IFaceLogLoadUpdatedPersonsResult *tobject = I_FACE_LOG_LOAD_UPDATED_PERSONS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_load_updated_persons_result_class_init (IFaceLogLoadUpdatedPersonsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_updated_persons_result_read;
  struct_class->write = i_face_log_load_updated_persons_result_write;

  gobject_class->finalize = i_face_log_load_updated_persons_result_finalize;
  gobject_class->get_property = i_face_log_load_updated_persons_result_get_property;
  gobject_class->set_property = i_face_log_load_updated_persons_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_updated_persons_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadUpdatedPersonsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_updated_persons_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadUpdatedPersonsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_updated_persons_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadUpdatedPersonsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadUpdatedPersonsTimestrArgsProperties
{
  PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_ARGS_0,
  PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_ARGS_TIMESTAMP
};

/* reads a i_face_log_load_updated_persons_timestr_args object */
static gint32
i_face_log_load_updated_persons_timestr_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadUpdatedPersonsTimestrArgs * this_object = I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->timestamp != NULL)
          {
            g_free(this_object->timestamp);
            this_object->timestamp = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->timestamp, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_timestamp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_updated_persons_timestr_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadUpdatedPersonsTimestrArgs * this_object = I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadUpdatedPersonsTimestrArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->timestamp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_updated_persons_timestr_args_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  IFaceLogLoadUpdatedPersonsTimestrArgs *self = I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_ARGS_TIMESTAMP:
      if (self->timestamp != NULL)
        g_free (self->timestamp);
      self->timestamp = g_value_dup_string (value);
      self->__isset_timestamp = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_updated_persons_timestr_args_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  IFaceLogLoadUpdatedPersonsTimestrArgs *self = I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_ARGS_TIMESTAMP:
      g_value_set_string (value, self->timestamp);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_updated_persons_timestr_args_instance_init (IFaceLogLoadUpdatedPersonsTimestrArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->timestamp = NULL;
  object->__isset_timestamp = FALSE;
}

static void 
i_face_log_load_updated_persons_timestr_args_finalize (GObject *object)
{
  IFaceLogLoadUpdatedPersonsTimestrArgs *tobject = I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->timestamp != NULL)
  {
    g_free(tobject->timestamp);
    tobject->timestamp = NULL;
  }
}

static void
i_face_log_load_updated_persons_timestr_args_class_init (IFaceLogLoadUpdatedPersonsTimestrArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_updated_persons_timestr_args_read;
  struct_class->write = i_face_log_load_updated_persons_timestr_args_write;

  gobject_class->finalize = i_face_log_load_updated_persons_timestr_args_finalize;
  gobject_class->get_property = i_face_log_load_updated_persons_timestr_args_get_property;
  gobject_class->set_property = i_face_log_load_updated_persons_timestr_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_ARGS_TIMESTAMP,
     g_param_spec_string ("timestamp",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
i_face_log_load_updated_persons_timestr_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadUpdatedPersonsTimestrArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_updated_persons_timestr_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadUpdatedPersonsTimestrArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_updated_persons_timestr_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadUpdatedPersonsTimestrArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogLoadUpdatedPersonsTimestrResultProperties
{
  PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_RESULT_0,
  PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_RESULT_SUCCESS,
  PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_RESULT_EX1
};

/* reads a i_face_log_load_updated_persons_timestr_result object */
static gint32
i_face_log_load_updated_persons_timestr_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogLoadUpdatedPersonsTimestrResult * this_object = I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem137 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem137, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->success, _elem137, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_load_updated_persons_timestr_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogLoadUpdatedPersonsTimestrResult * this_object = I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogLoadUpdatedPersonsTimestrResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i138;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i138 = 0; i138 < (this_object->success ? this_object->success->len : 0); i138++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->success, gint32, i138)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_load_updated_persons_timestr_result_set_property (GObject *object,
                                                             guint property_id,
                                                             const GValue *value,
                                                             GParamSpec *pspec)
{
  IFaceLogLoadUpdatedPersonsTimestrResult *self = I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_RESULT_SUCCESS:
      if (self->success != NULL)
        g_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_load_updated_persons_timestr_result_get_property (GObject *object,
                                                             guint property_id,
                                                             GValue *value,
                                                             GParamSpec *pspec)
{
  IFaceLogLoadUpdatedPersonsTimestrResult *self = I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_load_updated_persons_timestr_result_instance_init (IFaceLogLoadUpdatedPersonsTimestrResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_array_new (0, 1, sizeof (gint32));
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_load_updated_persons_timestr_result_finalize (GObject *object)
{
  IFaceLogLoadUpdatedPersonsTimestrResult *tobject = I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_load_updated_persons_timestr_result_class_init (IFaceLogLoadUpdatedPersonsTimestrResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_load_updated_persons_timestr_result_read;
  struct_class->write = i_face_log_load_updated_persons_timestr_result_write;

  gobject_class->finalize = i_face_log_load_updated_persons_timestr_result_finalize;
  gobject_class->get_property = i_face_log_load_updated_persons_timestr_result_get_property;
  gobject_class->set_property = i_face_log_load_updated_persons_timestr_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_load_updated_persons_timestr_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogLoadUpdatedPersonsTimestrResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_load_updated_persons_timestr_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogLoadUpdatedPersonsTimestrResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_load_updated_persons_timestr_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogLoadUpdatedPersonsTimestrResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogOfflineArgsProperties
{
  PROP_I_FACE_LOG_OFFLINE_ARGS_0,
  PROP_I_FACE_LOG_OFFLINE_ARGS_TOKEN
};

/* reads a i_face_log_offline_args object */
static gint32
i_face_log_offline_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogOfflineArgs * this_object = I_FACE_LOG_OFFLINE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_offline_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogOfflineArgs * this_object = I_FACE_LOG_OFFLINE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogOfflineArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_offline_args_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  IFaceLogOfflineArgs *self = I_FACE_LOG_OFFLINE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_OFFLINE_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_offline_args_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  IFaceLogOfflineArgs *self = I_FACE_LOG_OFFLINE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_OFFLINE_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_offline_args_instance_init (IFaceLogOfflineArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_offline_args_finalize (GObject *object)
{
  IFaceLogOfflineArgs *tobject = I_FACE_LOG_OFFLINE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_offline_args_class_init (IFaceLogOfflineArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_offline_args_read;
  struct_class->write = i_face_log_offline_args_write;

  gobject_class->finalize = i_face_log_offline_args_finalize;
  gobject_class->get_property = i_face_log_offline_args_get_property;
  gobject_class->set_property = i_face_log_offline_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_OFFLINE_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_offline_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogOfflineArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_offline_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogOfflineArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_offline_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogOfflineArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogOfflineResultProperties
{
  PROP_I_FACE_LOG_OFFLINE_RESULT_0,
  PROP_I_FACE_LOG_OFFLINE_RESULT_EX1,
  PROP_I_FACE_LOG_OFFLINE_RESULT_EX2
};

/* reads a i_face_log_offline_result object */
static gint32
i_face_log_offline_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogOfflineResult * this_object = I_FACE_LOG_OFFLINE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_SECURITY_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex2 != NULL)
          {
            g_object_unref (this_object->ex2);
          }
          this_object->ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex2);
            this_object->ex2 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_offline_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogOfflineResult * this_object = I_FACE_LOG_OFFLINE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogOfflineResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex2", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_offline_result_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  IFaceLogOfflineResult *self = I_FACE_LOG_OFFLINE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_OFFLINE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    case PROP_I_FACE_LOG_OFFLINE_RESULT_EX2:
      if (self->ex2 != NULL)
        g_object_unref (self->ex2);
      self->ex2 = g_value_dup_object (value);
      self->__isset_ex2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_offline_result_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  IFaceLogOfflineResult *self = I_FACE_LOG_OFFLINE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_OFFLINE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    case PROP_I_FACE_LOG_OFFLINE_RESULT_EX2:
      g_value_set_object (value, self->ex2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_offline_result_instance_init (IFaceLogOfflineResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
  object->ex2 = NULL;
  object->__isset_ex2 = FALSE;
}

static void 
i_face_log_offline_result_finalize (GObject *object)
{
  IFaceLogOfflineResult *tobject = I_FACE_LOG_OFFLINE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
  if (tobject->ex2 != NULL)
  {
    g_object_unref(tobject->ex2);
    tobject->ex2 = NULL;
  }
}

static void
i_face_log_offline_result_class_init (IFaceLogOfflineResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_offline_result_read;
  struct_class->write = i_face_log_offline_result_write;

  gobject_class->finalize = i_face_log_offline_result_finalize;
  gobject_class->get_property = i_face_log_offline_result_get_property;
  gobject_class->set_property = i_face_log_offline_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_OFFLINE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_SECURITY_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_OFFLINE_RESULT_EX2,
     g_param_spec_object ("ex2",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_offline_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogOfflineResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_offline_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogOfflineResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_offline_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogOfflineResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogOnlineArgsProperties
{
  PROP_I_FACE_LOG_ONLINE_ARGS_0,
  PROP_I_FACE_LOG_ONLINE_ARGS_DEVICE
};

/* reads a i_face_log_online_args object */
static gint32
i_face_log_online_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogOnlineArgs * this_object = I_FACE_LOG_ONLINE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->device), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_device = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_online_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogOnlineArgs * this_object = I_FACE_LOG_ONLINE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogOnlineArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "device", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->device), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_online_args_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  IFaceLogOnlineArgs *self = I_FACE_LOG_ONLINE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ONLINE_ARGS_DEVICE:
      if (self->device != NULL)
        g_object_unref (self->device);
      self->device = g_value_dup_object (value);
      self->__isset_device = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_online_args_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  IFaceLogOnlineArgs *self = I_FACE_LOG_ONLINE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ONLINE_ARGS_DEVICE:
      g_value_set_object (value, self->device);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_online_args_instance_init (IFaceLogOnlineArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->device = g_object_new (TYPE_DEVICE_BEAN, NULL);
  object->__isset_device = FALSE;
}

static void 
i_face_log_online_args_finalize (GObject *object)
{
  IFaceLogOnlineArgs *tobject = I_FACE_LOG_ONLINE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->device != NULL)
  {
    g_object_unref(tobject->device);
    tobject->device = NULL;
  }
}

static void
i_face_log_online_args_class_init (IFaceLogOnlineArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_online_args_read;
  struct_class->write = i_face_log_online_args_write;

  gobject_class->finalize = i_face_log_online_args_finalize;
  gobject_class->get_property = i_face_log_online_args_get_property;
  gobject_class->set_property = i_face_log_online_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ONLINE_ARGS_DEVICE,
     g_param_spec_object ("device",
                         NULL,
                         NULL,
                         TYPE_DEVICE_BEAN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_online_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogOnlineArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_online_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogOnlineArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_online_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogOnlineArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogOnlineResultProperties
{
  PROP_I_FACE_LOG_ONLINE_RESULT_0,
  PROP_I_FACE_LOG_ONLINE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_ONLINE_RESULT_EX1,
  PROP_I_FACE_LOG_ONLINE_RESULT_EX2
};

/* reads a i_face_log_online_result object */
static gint32
i_face_log_online_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogOnlineResult * this_object = I_FACE_LOG_ONLINE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_SECURITY_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex2 != NULL)
          {
            g_object_unref (this_object->ex2);
          }
          this_object->ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex2);
            this_object->ex2 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_online_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogOnlineResult * this_object = I_FACE_LOG_ONLINE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogOnlineResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex2", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_online_result_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  IFaceLogOnlineResult *self = I_FACE_LOG_ONLINE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ONLINE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_ONLINE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    case PROP_I_FACE_LOG_ONLINE_RESULT_EX2:
      if (self->ex2 != NULL)
        g_object_unref (self->ex2);
      self->ex2 = g_value_dup_object (value);
      self->__isset_ex2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_online_result_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  IFaceLogOnlineResult *self = I_FACE_LOG_ONLINE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ONLINE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_ONLINE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    case PROP_I_FACE_LOG_ONLINE_RESULT_EX2:
      g_value_set_object (value, self->ex2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_online_result_instance_init (IFaceLogOnlineResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
  object->ex2 = NULL;
  object->__isset_ex2 = FALSE;
}

static void 
i_face_log_online_result_finalize (GObject *object)
{
  IFaceLogOnlineResult *tobject = I_FACE_LOG_ONLINE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
  if (tobject->ex2 != NULL)
  {
    g_object_unref(tobject->ex2);
    tobject->ex2 = NULL;
  }
}

static void
i_face_log_online_result_class_init (IFaceLogOnlineResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_online_result_read;
  struct_class->write = i_face_log_online_result_write;

  gobject_class->finalize = i_face_log_online_result_finalize;
  gobject_class->get_property = i_face_log_online_result_get_property;
  gobject_class->set_property = i_face_log_online_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ONLINE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ONLINE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_SECURITY_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ONLINE_RESULT_EX2,
     g_param_spec_object ("ex2",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_online_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogOnlineResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_online_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogOnlineResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_online_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogOnlineResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogRegisterDeviceArgsProperties
{
  PROP_I_FACE_LOG_REGISTER_DEVICE_ARGS_0,
  PROP_I_FACE_LOG_REGISTER_DEVICE_ARGS_NEW_DEVICE
};

/* reads a i_face_log_register_device_args object */
static gint32
i_face_log_register_device_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogRegisterDeviceArgs * this_object = I_FACE_LOG_REGISTER_DEVICE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->newDevice), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_newDevice = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_register_device_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogRegisterDeviceArgs * this_object = I_FACE_LOG_REGISTER_DEVICE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogRegisterDeviceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "newDevice", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->newDevice), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_register_device_args_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogRegisterDeviceArgs *self = I_FACE_LOG_REGISTER_DEVICE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_REGISTER_DEVICE_ARGS_NEW_DEVICE:
      if (self->newDevice != NULL)
        g_object_unref (self->newDevice);
      self->newDevice = g_value_dup_object (value);
      self->__isset_newDevice = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_register_device_args_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogRegisterDeviceArgs *self = I_FACE_LOG_REGISTER_DEVICE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_REGISTER_DEVICE_ARGS_NEW_DEVICE:
      g_value_set_object (value, self->newDevice);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_register_device_args_instance_init (IFaceLogRegisterDeviceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->newDevice = g_object_new (TYPE_DEVICE_BEAN, NULL);
  object->__isset_newDevice = FALSE;
}

static void 
i_face_log_register_device_args_finalize (GObject *object)
{
  IFaceLogRegisterDeviceArgs *tobject = I_FACE_LOG_REGISTER_DEVICE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->newDevice != NULL)
  {
    g_object_unref(tobject->newDevice);
    tobject->newDevice = NULL;
  }
}

static void
i_face_log_register_device_args_class_init (IFaceLogRegisterDeviceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_register_device_args_read;
  struct_class->write = i_face_log_register_device_args_write;

  gobject_class->finalize = i_face_log_register_device_args_finalize;
  gobject_class->get_property = i_face_log_register_device_args_get_property;
  gobject_class->set_property = i_face_log_register_device_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_REGISTER_DEVICE_ARGS_NEW_DEVICE,
     g_param_spec_object ("newDevice",
                         NULL,
                         NULL,
                         TYPE_DEVICE_BEAN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_register_device_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogRegisterDeviceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_register_device_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogRegisterDeviceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_register_device_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogRegisterDeviceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogRegisterDeviceResultProperties
{
  PROP_I_FACE_LOG_REGISTER_DEVICE_RESULT_0,
  PROP_I_FACE_LOG_REGISTER_DEVICE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_REGISTER_DEVICE_RESULT_EX1,
  PROP_I_FACE_LOG_REGISTER_DEVICE_RESULT_EX2
};

/* reads a i_face_log_register_device_result object */
static gint32
i_face_log_register_device_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogRegisterDeviceResult * this_object = I_FACE_LOG_REGISTER_DEVICE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_SECURITY_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex2 != NULL)
          {
            g_object_unref (this_object->ex2);
          }
          this_object->ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex2);
            this_object->ex2 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_register_device_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogRegisterDeviceResult * this_object = I_FACE_LOG_REGISTER_DEVICE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogRegisterDeviceResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex2", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_register_device_result_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogRegisterDeviceResult *self = I_FACE_LOG_REGISTER_DEVICE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_REGISTER_DEVICE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_REGISTER_DEVICE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    case PROP_I_FACE_LOG_REGISTER_DEVICE_RESULT_EX2:
      if (self->ex2 != NULL)
        g_object_unref (self->ex2);
      self->ex2 = g_value_dup_object (value);
      self->__isset_ex2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_register_device_result_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogRegisterDeviceResult *self = I_FACE_LOG_REGISTER_DEVICE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_REGISTER_DEVICE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_REGISTER_DEVICE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    case PROP_I_FACE_LOG_REGISTER_DEVICE_RESULT_EX2:
      g_value_set_object (value, self->ex2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_register_device_result_instance_init (IFaceLogRegisterDeviceResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_DEVICE_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
  object->ex2 = NULL;
  object->__isset_ex2 = FALSE;
}

static void 
i_face_log_register_device_result_finalize (GObject *object)
{
  IFaceLogRegisterDeviceResult *tobject = I_FACE_LOG_REGISTER_DEVICE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
  if (tobject->ex2 != NULL)
  {
    g_object_unref(tobject->ex2);
    tobject->ex2 = NULL;
  }
}

static void
i_face_log_register_device_result_class_init (IFaceLogRegisterDeviceResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_register_device_result_read;
  struct_class->write = i_face_log_register_device_result_write;

  gobject_class->finalize = i_face_log_register_device_result_finalize;
  gobject_class->get_property = i_face_log_register_device_result_get_property;
  gobject_class->set_property = i_face_log_register_device_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_REGISTER_DEVICE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_DEVICE_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_REGISTER_DEVICE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_SECURITY_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_REGISTER_DEVICE_RESULT_EX2,
     g_param_spec_object ("ex2",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_register_device_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogRegisterDeviceResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_register_device_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogRegisterDeviceResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_register_device_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogRegisterDeviceResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogReleasePersonTokenArgsProperties
{
  PROP_I_FACE_LOG_RELEASE_PERSON_TOKEN_ARGS_0,
  PROP_I_FACE_LOG_RELEASE_PERSON_TOKEN_ARGS_TOKEN
};

/* reads a i_face_log_release_person_token_args object */
static gint32
i_face_log_release_person_token_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogReleasePersonTokenArgs * this_object = I_FACE_LOG_RELEASE_PERSON_TOKEN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_release_person_token_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogReleasePersonTokenArgs * this_object = I_FACE_LOG_RELEASE_PERSON_TOKEN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogReleasePersonTokenArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_release_person_token_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogReleasePersonTokenArgs *self = I_FACE_LOG_RELEASE_PERSON_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_RELEASE_PERSON_TOKEN_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_release_person_token_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogReleasePersonTokenArgs *self = I_FACE_LOG_RELEASE_PERSON_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_RELEASE_PERSON_TOKEN_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_release_person_token_args_instance_init (IFaceLogReleasePersonTokenArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_release_person_token_args_finalize (GObject *object)
{
  IFaceLogReleasePersonTokenArgs *tobject = I_FACE_LOG_RELEASE_PERSON_TOKEN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_release_person_token_args_class_init (IFaceLogReleasePersonTokenArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_release_person_token_args_read;
  struct_class->write = i_face_log_release_person_token_args_write;

  gobject_class->finalize = i_face_log_release_person_token_args_finalize;
  gobject_class->get_property = i_face_log_release_person_token_args_get_property;
  gobject_class->set_property = i_face_log_release_person_token_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RELEASE_PERSON_TOKEN_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_release_person_token_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogReleasePersonTokenArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_release_person_token_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogReleasePersonTokenArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_release_person_token_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogReleasePersonTokenArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogReleasePersonTokenResultProperties
{
  PROP_I_FACE_LOG_RELEASE_PERSON_TOKEN_RESULT_0,
  PROP_I_FACE_LOG_RELEASE_PERSON_TOKEN_RESULT_EX1,
  PROP_I_FACE_LOG_RELEASE_PERSON_TOKEN_RESULT_EX2
};

/* reads a i_face_log_release_person_token_result object */
static gint32
i_face_log_release_person_token_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogReleasePersonTokenResult * this_object = I_FACE_LOG_RELEASE_PERSON_TOKEN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_SECURITY_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex2 != NULL)
          {
            g_object_unref (this_object->ex2);
          }
          this_object->ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex2);
            this_object->ex2 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_release_person_token_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogReleasePersonTokenResult * this_object = I_FACE_LOG_RELEASE_PERSON_TOKEN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogReleasePersonTokenResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex2", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_release_person_token_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogReleasePersonTokenResult *self = I_FACE_LOG_RELEASE_PERSON_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_RELEASE_PERSON_TOKEN_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    case PROP_I_FACE_LOG_RELEASE_PERSON_TOKEN_RESULT_EX2:
      if (self->ex2 != NULL)
        g_object_unref (self->ex2);
      self->ex2 = g_value_dup_object (value);
      self->__isset_ex2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_release_person_token_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogReleasePersonTokenResult *self = I_FACE_LOG_RELEASE_PERSON_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_RELEASE_PERSON_TOKEN_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    case PROP_I_FACE_LOG_RELEASE_PERSON_TOKEN_RESULT_EX2:
      g_value_set_object (value, self->ex2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_release_person_token_result_instance_init (IFaceLogReleasePersonTokenResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
  object->ex2 = NULL;
  object->__isset_ex2 = FALSE;
}

static void 
i_face_log_release_person_token_result_finalize (GObject *object)
{
  IFaceLogReleasePersonTokenResult *tobject = I_FACE_LOG_RELEASE_PERSON_TOKEN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
  if (tobject->ex2 != NULL)
  {
    g_object_unref(tobject->ex2);
    tobject->ex2 = NULL;
  }
}

static void
i_face_log_release_person_token_result_class_init (IFaceLogReleasePersonTokenResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_release_person_token_result_read;
  struct_class->write = i_face_log_release_person_token_result_write;

  gobject_class->finalize = i_face_log_release_person_token_result_finalize;
  gobject_class->get_property = i_face_log_release_person_token_result_get_property;
  gobject_class->set_property = i_face_log_release_person_token_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RELEASE_PERSON_TOKEN_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_SECURITY_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RELEASE_PERSON_TOKEN_RESULT_EX2,
     g_param_spec_object ("ex2",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_release_person_token_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogReleasePersonTokenResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_release_person_token_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogReleasePersonTokenResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_release_person_token_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogReleasePersonTokenResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogReleaseRootTokenArgsProperties
{
  PROP_I_FACE_LOG_RELEASE_ROOT_TOKEN_ARGS_0,
  PROP_I_FACE_LOG_RELEASE_ROOT_TOKEN_ARGS_TOKEN
};

/* reads a i_face_log_release_root_token_args object */
static gint32
i_face_log_release_root_token_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogReleaseRootTokenArgs * this_object = I_FACE_LOG_RELEASE_ROOT_TOKEN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_release_root_token_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogReleaseRootTokenArgs * this_object = I_FACE_LOG_RELEASE_ROOT_TOKEN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogReleaseRootTokenArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_release_root_token_args_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogReleaseRootTokenArgs *self = I_FACE_LOG_RELEASE_ROOT_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_RELEASE_ROOT_TOKEN_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_release_root_token_args_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogReleaseRootTokenArgs *self = I_FACE_LOG_RELEASE_ROOT_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_RELEASE_ROOT_TOKEN_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_release_root_token_args_instance_init (IFaceLogReleaseRootTokenArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_release_root_token_args_finalize (GObject *object)
{
  IFaceLogReleaseRootTokenArgs *tobject = I_FACE_LOG_RELEASE_ROOT_TOKEN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_release_root_token_args_class_init (IFaceLogReleaseRootTokenArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_release_root_token_args_read;
  struct_class->write = i_face_log_release_root_token_args_write;

  gobject_class->finalize = i_face_log_release_root_token_args_finalize;
  gobject_class->get_property = i_face_log_release_root_token_args_get_property;
  gobject_class->set_property = i_face_log_release_root_token_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RELEASE_ROOT_TOKEN_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_release_root_token_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogReleaseRootTokenArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_release_root_token_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogReleaseRootTokenArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_release_root_token_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogReleaseRootTokenArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogReleaseRootTokenResultProperties
{
  PROP_I_FACE_LOG_RELEASE_ROOT_TOKEN_RESULT_0,
  PROP_I_FACE_LOG_RELEASE_ROOT_TOKEN_RESULT_EX1,
  PROP_I_FACE_LOG_RELEASE_ROOT_TOKEN_RESULT_EX2
};

/* reads a i_face_log_release_root_token_result object */
static gint32
i_face_log_release_root_token_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogReleaseRootTokenResult * this_object = I_FACE_LOG_RELEASE_ROOT_TOKEN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_SECURITY_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex2 != NULL)
          {
            g_object_unref (this_object->ex2);
          }
          this_object->ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex2);
            this_object->ex2 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_release_root_token_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogReleaseRootTokenResult * this_object = I_FACE_LOG_RELEASE_ROOT_TOKEN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogReleaseRootTokenResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex2", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_release_root_token_result_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogReleaseRootTokenResult *self = I_FACE_LOG_RELEASE_ROOT_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_RELEASE_ROOT_TOKEN_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    case PROP_I_FACE_LOG_RELEASE_ROOT_TOKEN_RESULT_EX2:
      if (self->ex2 != NULL)
        g_object_unref (self->ex2);
      self->ex2 = g_value_dup_object (value);
      self->__isset_ex2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_release_root_token_result_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogReleaseRootTokenResult *self = I_FACE_LOG_RELEASE_ROOT_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_RELEASE_ROOT_TOKEN_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    case PROP_I_FACE_LOG_RELEASE_ROOT_TOKEN_RESULT_EX2:
      g_value_set_object (value, self->ex2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_release_root_token_result_instance_init (IFaceLogReleaseRootTokenResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
  object->ex2 = NULL;
  object->__isset_ex2 = FALSE;
}

static void 
i_face_log_release_root_token_result_finalize (GObject *object)
{
  IFaceLogReleaseRootTokenResult *tobject = I_FACE_LOG_RELEASE_ROOT_TOKEN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
  if (tobject->ex2 != NULL)
  {
    g_object_unref(tobject->ex2);
    tobject->ex2 = NULL;
  }
}

static void
i_face_log_release_root_token_result_class_init (IFaceLogReleaseRootTokenResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_release_root_token_result_read;
  struct_class->write = i_face_log_release_root_token_result_write;

  gobject_class->finalize = i_face_log_release_root_token_result_finalize;
  gobject_class->get_property = i_face_log_release_root_token_result_get_property;
  gobject_class->set_property = i_face_log_release_root_token_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RELEASE_ROOT_TOKEN_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_SECURITY_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RELEASE_ROOT_TOKEN_RESULT_EX2,
     g_param_spec_object ("ex2",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_release_root_token_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogReleaseRootTokenResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_release_root_token_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogReleaseRootTokenResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_release_root_token_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogReleaseRootTokenResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogReleaseUserTokenArgsProperties
{
  PROP_I_FACE_LOG_RELEASE_USER_TOKEN_ARGS_0,
  PROP_I_FACE_LOG_RELEASE_USER_TOKEN_ARGS_TOKEN
};

/* reads a i_face_log_release_user_token_args object */
static gint32
i_face_log_release_user_token_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogReleaseUserTokenArgs * this_object = I_FACE_LOG_RELEASE_USER_TOKEN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_release_user_token_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogReleaseUserTokenArgs * this_object = I_FACE_LOG_RELEASE_USER_TOKEN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogReleaseUserTokenArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_release_user_token_args_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogReleaseUserTokenArgs *self = I_FACE_LOG_RELEASE_USER_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_RELEASE_USER_TOKEN_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_release_user_token_args_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogReleaseUserTokenArgs *self = I_FACE_LOG_RELEASE_USER_TOKEN_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_RELEASE_USER_TOKEN_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_release_user_token_args_instance_init (IFaceLogReleaseUserTokenArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_release_user_token_args_finalize (GObject *object)
{
  IFaceLogReleaseUserTokenArgs *tobject = I_FACE_LOG_RELEASE_USER_TOKEN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_release_user_token_args_class_init (IFaceLogReleaseUserTokenArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_release_user_token_args_read;
  struct_class->write = i_face_log_release_user_token_args_write;

  gobject_class->finalize = i_face_log_release_user_token_args_finalize;
  gobject_class->get_property = i_face_log_release_user_token_args_get_property;
  gobject_class->set_property = i_face_log_release_user_token_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RELEASE_USER_TOKEN_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_release_user_token_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogReleaseUserTokenArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_release_user_token_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogReleaseUserTokenArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_release_user_token_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogReleaseUserTokenArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogReleaseUserTokenResultProperties
{
  PROP_I_FACE_LOG_RELEASE_USER_TOKEN_RESULT_0,
  PROP_I_FACE_LOG_RELEASE_USER_TOKEN_RESULT_EX1,
  PROP_I_FACE_LOG_RELEASE_USER_TOKEN_RESULT_EX2
};

/* reads a i_face_log_release_user_token_result object */
static gint32
i_face_log_release_user_token_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogReleaseUserTokenResult * this_object = I_FACE_LOG_RELEASE_USER_TOKEN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_SECURITY_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex2 != NULL)
          {
            g_object_unref (this_object->ex2);
          }
          this_object->ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex2);
            this_object->ex2 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_release_user_token_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogReleaseUserTokenResult * this_object = I_FACE_LOG_RELEASE_USER_TOKEN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogReleaseUserTokenResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex2", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_release_user_token_result_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogReleaseUserTokenResult *self = I_FACE_LOG_RELEASE_USER_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_RELEASE_USER_TOKEN_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    case PROP_I_FACE_LOG_RELEASE_USER_TOKEN_RESULT_EX2:
      if (self->ex2 != NULL)
        g_object_unref (self->ex2);
      self->ex2 = g_value_dup_object (value);
      self->__isset_ex2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_release_user_token_result_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogReleaseUserTokenResult *self = I_FACE_LOG_RELEASE_USER_TOKEN_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_RELEASE_USER_TOKEN_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    case PROP_I_FACE_LOG_RELEASE_USER_TOKEN_RESULT_EX2:
      g_value_set_object (value, self->ex2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_release_user_token_result_instance_init (IFaceLogReleaseUserTokenResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
  object->ex2 = NULL;
  object->__isset_ex2 = FALSE;
}

static void 
i_face_log_release_user_token_result_finalize (GObject *object)
{
  IFaceLogReleaseUserTokenResult *tobject = I_FACE_LOG_RELEASE_USER_TOKEN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
  if (tobject->ex2 != NULL)
  {
    g_object_unref(tobject->ex2);
    tobject->ex2 = NULL;
  }
}

static void
i_face_log_release_user_token_result_class_init (IFaceLogReleaseUserTokenResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_release_user_token_result_read;
  struct_class->write = i_face_log_release_user_token_result_write;

  gobject_class->finalize = i_face_log_release_user_token_result_finalize;
  gobject_class->get_property = i_face_log_release_user_token_result_get_property;
  gobject_class->set_property = i_face_log_release_user_token_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RELEASE_USER_TOKEN_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_SECURITY_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RELEASE_USER_TOKEN_RESULT_EX2,
     g_param_spec_object ("ex2",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_release_user_token_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogReleaseUserTokenResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_release_user_token_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogReleaseUserTokenResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_release_user_token_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogReleaseUserTokenResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogReplaceFeatureArgsProperties
{
  PROP_I_FACE_LOG_REPLACE_FEATURE_ARGS_0,
  PROP_I_FACE_LOG_REPLACE_FEATURE_ARGS_PERSON_ID,
  PROP_I_FACE_LOG_REPLACE_FEATURE_ARGS_FEATURE_MD5,
  PROP_I_FACE_LOG_REPLACE_FEATURE_ARGS_DELETE_OLD_FEATURE_IMAGE,
  PROP_I_FACE_LOG_REPLACE_FEATURE_ARGS_TOKEN
};

/* reads a i_face_log_replace_feature_args object */
static gint32
i_face_log_replace_feature_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogReplaceFeatureArgs * this_object = I_FACE_LOG_REPLACE_FEATURE_ARGS(object);
  gboolean isset_deleteOldFeatureImage = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->featureMd5 != NULL)
          {
            g_free(this_object->featureMd5);
            this_object->featureMd5 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->featureMd5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_featureMd5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->deleteOldFeatureImage, error)) < 0)
            return -1;
          xfer += ret;
          isset_deleteOldFeatureImage = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_deleteOldFeatureImage)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_replace_feature_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogReplaceFeatureArgs * this_object = I_FACE_LOG_REPLACE_FEATURE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogReplaceFeatureArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "featureMd5", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->featureMd5, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deleteOldFeatureImage", T_BOOL, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->deleteOldFeatureImage, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_replace_feature_args_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogReplaceFeatureArgs *self = I_FACE_LOG_REPLACE_FEATURE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_REPLACE_FEATURE_ARGS_PERSON_ID:
      self->personId = g_value_get_int (value);
      self->__isset_personId = TRUE;
      break;

    case PROP_I_FACE_LOG_REPLACE_FEATURE_ARGS_FEATURE_MD5:
      if (self->featureMd5 != NULL)
        g_free (self->featureMd5);
      self->featureMd5 = g_value_dup_string (value);
      self->__isset_featureMd5 = TRUE;
      break;

    case PROP_I_FACE_LOG_REPLACE_FEATURE_ARGS_DELETE_OLD_FEATURE_IMAGE:
      self->deleteOldFeatureImage = g_value_get_boolean (value);
      break;

    case PROP_I_FACE_LOG_REPLACE_FEATURE_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_replace_feature_args_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogReplaceFeatureArgs *self = I_FACE_LOG_REPLACE_FEATURE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_REPLACE_FEATURE_ARGS_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    case PROP_I_FACE_LOG_REPLACE_FEATURE_ARGS_FEATURE_MD5:
      g_value_set_string (value, self->featureMd5);
      break;

    case PROP_I_FACE_LOG_REPLACE_FEATURE_ARGS_DELETE_OLD_FEATURE_IMAGE:
      g_value_set_boolean (value, self->deleteOldFeatureImage);
      break;

    case PROP_I_FACE_LOG_REPLACE_FEATURE_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_replace_feature_args_instance_init (IFaceLogReplaceFeatureArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personId = 0;
  object->__isset_personId = FALSE;
  object->featureMd5 = NULL;
  object->__isset_featureMd5 = FALSE;
  object->deleteOldFeatureImage = 0;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_replace_feature_args_finalize (GObject *object)
{
  IFaceLogReplaceFeatureArgs *tobject = I_FACE_LOG_REPLACE_FEATURE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->featureMd5 != NULL)
  {
    g_free(tobject->featureMd5);
    tobject->featureMd5 = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_replace_feature_args_class_init (IFaceLogReplaceFeatureArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_replace_feature_args_read;
  struct_class->write = i_face_log_replace_feature_args_write;

  gobject_class->finalize = i_face_log_replace_feature_args_finalize;
  gobject_class->get_property = i_face_log_replace_feature_args_get_property;
  gobject_class->set_property = i_face_log_replace_feature_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_REPLACE_FEATURE_ARGS_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_REPLACE_FEATURE_ARGS_FEATURE_MD5,
     g_param_spec_string ("featureMd5",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_REPLACE_FEATURE_ARGS_DELETE_OLD_FEATURE_IMAGE,
     g_param_spec_boolean ("deleteOldFeatureImage",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_REPLACE_FEATURE_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_replace_feature_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogReplaceFeatureArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_replace_feature_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogReplaceFeatureArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_replace_feature_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogReplaceFeatureArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogReplaceFeatureResultProperties
{
  PROP_I_FACE_LOG_REPLACE_FEATURE_RESULT_0,
  PROP_I_FACE_LOG_REPLACE_FEATURE_RESULT_EX1
};

/* reads a i_face_log_replace_feature_result object */
static gint32
i_face_log_replace_feature_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogReplaceFeatureResult * this_object = I_FACE_LOG_REPLACE_FEATURE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_replace_feature_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogReplaceFeatureResult * this_object = I_FACE_LOG_REPLACE_FEATURE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogReplaceFeatureResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_replace_feature_result_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogReplaceFeatureResult *self = I_FACE_LOG_REPLACE_FEATURE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_REPLACE_FEATURE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_replace_feature_result_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogReplaceFeatureResult *self = I_FACE_LOG_REPLACE_FEATURE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_REPLACE_FEATURE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_replace_feature_result_instance_init (IFaceLogReplaceFeatureResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_replace_feature_result_finalize (GObject *object)
{
  IFaceLogReplaceFeatureResult *tobject = I_FACE_LOG_REPLACE_FEATURE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_replace_feature_result_class_init (IFaceLogReplaceFeatureResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_replace_feature_result_read;
  struct_class->write = i_face_log_replace_feature_result_write;

  gobject_class->finalize = i_face_log_replace_feature_result_finalize;
  gobject_class->get_property = i_face_log_replace_feature_result_get_property;
  gobject_class->set_property = i_face_log_replace_feature_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_REPLACE_FEATURE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_replace_feature_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogReplaceFeatureResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_replace_feature_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogReplaceFeatureResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_replace_feature_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogReplaceFeatureResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogRootGroupOfDeviceArgsProperties
{
  PROP_I_FACE_LOG_ROOT_GROUP_OF_DEVICE_ARGS_0,
  PROP_I_FACE_LOG_ROOT_GROUP_OF_DEVICE_ARGS_DEVICE_ID
};

/* reads a i_face_log_root_group_of_device_args object */
static gint32
i_face_log_root_group_of_device_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogRootGroupOfDeviceArgs * this_object = I_FACE_LOG_ROOT_GROUP_OF_DEVICE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_deviceId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_root_group_of_device_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogRootGroupOfDeviceArgs * this_object = I_FACE_LOG_ROOT_GROUP_OF_DEVICE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogRootGroupOfDeviceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_root_group_of_device_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogRootGroupOfDeviceArgs *self = I_FACE_LOG_ROOT_GROUP_OF_DEVICE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ROOT_GROUP_OF_DEVICE_ARGS_DEVICE_ID:
      self->deviceId = g_value_get_int (value);
      self->__isset_deviceId = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_root_group_of_device_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogRootGroupOfDeviceArgs *self = I_FACE_LOG_ROOT_GROUP_OF_DEVICE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ROOT_GROUP_OF_DEVICE_ARGS_DEVICE_ID:
      g_value_set_int (value, self->deviceId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_root_group_of_device_args_instance_init (IFaceLogRootGroupOfDeviceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->deviceId = 0;
  object->__isset_deviceId = FALSE;
}

static void 
i_face_log_root_group_of_device_args_finalize (GObject *object)
{
  IFaceLogRootGroupOfDeviceArgs *tobject = I_FACE_LOG_ROOT_GROUP_OF_DEVICE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_root_group_of_device_args_class_init (IFaceLogRootGroupOfDeviceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_root_group_of_device_args_read;
  struct_class->write = i_face_log_root_group_of_device_args_write;

  gobject_class->finalize = i_face_log_root_group_of_device_args_finalize;
  gobject_class->get_property = i_face_log_root_group_of_device_args_get_property;
  gobject_class->set_property = i_face_log_root_group_of_device_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ROOT_GROUP_OF_DEVICE_ARGS_DEVICE_ID,
     g_param_spec_int ("deviceId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_root_group_of_device_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogRootGroupOfDeviceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_root_group_of_device_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogRootGroupOfDeviceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_root_group_of_device_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogRootGroupOfDeviceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogRootGroupOfDeviceResultProperties
{
  PROP_I_FACE_LOG_ROOT_GROUP_OF_DEVICE_RESULT_0,
  PROP_I_FACE_LOG_ROOT_GROUP_OF_DEVICE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_ROOT_GROUP_OF_DEVICE_RESULT_EX1
};

/* reads a i_face_log_root_group_of_device_result object */
static gint32
i_face_log_root_group_of_device_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogRootGroupOfDeviceResult * this_object = I_FACE_LOG_ROOT_GROUP_OF_DEVICE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_root_group_of_device_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogRootGroupOfDeviceResult * this_object = I_FACE_LOG_ROOT_GROUP_OF_DEVICE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogRootGroupOfDeviceResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_root_group_of_device_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogRootGroupOfDeviceResult *self = I_FACE_LOG_ROOT_GROUP_OF_DEVICE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ROOT_GROUP_OF_DEVICE_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_ROOT_GROUP_OF_DEVICE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_root_group_of_device_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogRootGroupOfDeviceResult *self = I_FACE_LOG_ROOT_GROUP_OF_DEVICE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ROOT_GROUP_OF_DEVICE_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_ROOT_GROUP_OF_DEVICE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_root_group_of_device_result_instance_init (IFaceLogRootGroupOfDeviceResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_root_group_of_device_result_finalize (GObject *object)
{
  IFaceLogRootGroupOfDeviceResult *tobject = I_FACE_LOG_ROOT_GROUP_OF_DEVICE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_root_group_of_device_result_class_init (IFaceLogRootGroupOfDeviceResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_root_group_of_device_result_read;
  struct_class->write = i_face_log_root_group_of_device_result_write;

  gobject_class->finalize = i_face_log_root_group_of_device_result_finalize;
  gobject_class->get_property = i_face_log_root_group_of_device_result_get_property;
  gobject_class->set_property = i_face_log_root_group_of_device_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ROOT_GROUP_OF_DEVICE_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ROOT_GROUP_OF_DEVICE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_root_group_of_device_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogRootGroupOfDeviceResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_root_group_of_device_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogRootGroupOfDeviceResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_root_group_of_device_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogRootGroupOfDeviceResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogRootGroupOfPersonArgsProperties
{
  PROP_I_FACE_LOG_ROOT_GROUP_OF_PERSON_ARGS_0,
  PROP_I_FACE_LOG_ROOT_GROUP_OF_PERSON_ARGS_PERSON_ID
};

/* reads a i_face_log_root_group_of_person_args object */
static gint32
i_face_log_root_group_of_person_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogRootGroupOfPersonArgs * this_object = I_FACE_LOG_ROOT_GROUP_OF_PERSON_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_root_group_of_person_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogRootGroupOfPersonArgs * this_object = I_FACE_LOG_ROOT_GROUP_OF_PERSON_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogRootGroupOfPersonArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_root_group_of_person_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogRootGroupOfPersonArgs *self = I_FACE_LOG_ROOT_GROUP_OF_PERSON_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ROOT_GROUP_OF_PERSON_ARGS_PERSON_ID:
      self->personId = g_value_get_int (value);
      self->__isset_personId = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_root_group_of_person_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  IFaceLogRootGroupOfPersonArgs *self = I_FACE_LOG_ROOT_GROUP_OF_PERSON_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ROOT_GROUP_OF_PERSON_ARGS_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_root_group_of_person_args_instance_init (IFaceLogRootGroupOfPersonArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personId = 0;
  object->__isset_personId = FALSE;
}

static void 
i_face_log_root_group_of_person_args_finalize (GObject *object)
{
  IFaceLogRootGroupOfPersonArgs *tobject = I_FACE_LOG_ROOT_GROUP_OF_PERSON_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_root_group_of_person_args_class_init (IFaceLogRootGroupOfPersonArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_root_group_of_person_args_read;
  struct_class->write = i_face_log_root_group_of_person_args_write;

  gobject_class->finalize = i_face_log_root_group_of_person_args_finalize;
  gobject_class->get_property = i_face_log_root_group_of_person_args_get_property;
  gobject_class->set_property = i_face_log_root_group_of_person_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ROOT_GROUP_OF_PERSON_ARGS_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
i_face_log_root_group_of_person_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogRootGroupOfPersonArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_root_group_of_person_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogRootGroupOfPersonArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_root_group_of_person_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogRootGroupOfPersonArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogRootGroupOfPersonResultProperties
{
  PROP_I_FACE_LOG_ROOT_GROUP_OF_PERSON_RESULT_0,
  PROP_I_FACE_LOG_ROOT_GROUP_OF_PERSON_RESULT_SUCCESS,
  PROP_I_FACE_LOG_ROOT_GROUP_OF_PERSON_RESULT_EX1
};

/* reads a i_face_log_root_group_of_person_result object */
static gint32
i_face_log_root_group_of_person_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogRootGroupOfPersonResult * this_object = I_FACE_LOG_ROOT_GROUP_OF_PERSON_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_root_group_of_person_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogRootGroupOfPersonResult * this_object = I_FACE_LOG_ROOT_GROUP_OF_PERSON_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogRootGroupOfPersonResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_root_group_of_person_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogRootGroupOfPersonResult *self = I_FACE_LOG_ROOT_GROUP_OF_PERSON_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ROOT_GROUP_OF_PERSON_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_ROOT_GROUP_OF_PERSON_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_root_group_of_person_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogRootGroupOfPersonResult *self = I_FACE_LOG_ROOT_GROUP_OF_PERSON_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_ROOT_GROUP_OF_PERSON_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_ROOT_GROUP_OF_PERSON_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_root_group_of_person_result_instance_init (IFaceLogRootGroupOfPersonResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_root_group_of_person_result_finalize (GObject *object)
{
  IFaceLogRootGroupOfPersonResult *tobject = I_FACE_LOG_ROOT_GROUP_OF_PERSON_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_root_group_of_person_result_class_init (IFaceLogRootGroupOfPersonResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_root_group_of_person_result_read;
  struct_class->write = i_face_log_root_group_of_person_result_write;

  gobject_class->finalize = i_face_log_root_group_of_person_result_finalize;
  gobject_class->get_property = i_face_log_root_group_of_person_result_get_property;
  gobject_class->set_property = i_face_log_root_group_of_person_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ROOT_GROUP_OF_PERSON_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_ROOT_GROUP_OF_PERSON_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_root_group_of_person_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogRootGroupOfPersonResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_root_group_of_person_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogRootGroupOfPersonResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_root_group_of_person_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogRootGroupOfPersonResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogRunCmdArgsProperties
{
  PROP_I_FACE_LOG_RUN_CMD_ARGS_0,
  PROP_I_FACE_LOG_RUN_CMD_ARGS_TARGET,
  PROP_I_FACE_LOG_RUN_CMD_ARGS_GROUP,
  PROP_I_FACE_LOG_RUN_CMD_ARGS_CMDPATH,
  PROP_I_FACE_LOG_RUN_CMD_ARGS_JSON_ARGS,
  PROP_I_FACE_LOG_RUN_CMD_ARGS_ACK_CHANNEL,
  PROP_I_FACE_LOG_RUN_CMD_ARGS_TOKEN
};

/* reads a i_face_log_run_cmd_args object */
static gint32
i_face_log_run_cmd_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogRunCmdArgs * this_object = I_FACE_LOG_RUN_CMD_ARGS(object);
  gboolean isset_group = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem139 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem139, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->target, _elem139, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_target = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->group, error)) < 0)
            return -1;
          xfer += ret;
          isset_group = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->cmdpath != NULL)
          {
            g_free(this_object->cmdpath);
            this_object->cmdpath = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->cmdpath, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cmdpath = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key140 = NULL;
              gchar * val141 = NULL;
              if (key140 != NULL)
              {
                g_free(key140);
                key140 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key140, error)) < 0)
                return -1;
              xfer += ret;
              if (val141 != NULL)
              {
                g_free(val141);
                val141 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val141, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->jsonArgs && key140)
                g_hash_table_insert ((GHashTable *)this_object->jsonArgs, (gpointer) key140, (gpointer) val141);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_jsonArgs = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->ackChannel != NULL)
          {
            g_free(this_object->ackChannel);
            this_object->ackChannel = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->ackChannel, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ackChannel = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_group)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_run_cmd_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogRunCmdArgs * this_object = I_FACE_LOG_RUN_CMD_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogRunCmdArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "target", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i142;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->target ? this_object->target->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i142 = 0; i142 < (this_object->target ? this_object->target->len : 0); i142++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->target, gint32, i142)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "group", T_BOOL, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_bool (protocol, this_object->group, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cmdpath", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->cmdpath, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "jsonArgs", T_MAP, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    gchar * key143 = NULL;
    gchar * val144 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gchar ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->jsonArgs ? (gint32) g_hash_table_size ((GHashTable *) this_object->jsonArgs) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->jsonArgs)
      g_hash_table_foreach ((GHashTable *) this_object->jsonArgs, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gchar *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gchar *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key143 = keys[i];
      val144 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->jsonArgs), (gpointer) key143);

      if ((ret = thrift_protocol_write_string (protocol,  key143, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_string (protocol,  val144, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ackChannel", T_STRING, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->ackChannel, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_run_cmd_args_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  IFaceLogRunCmdArgs *self = I_FACE_LOG_RUN_CMD_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_RUN_CMD_ARGS_TARGET:
      if (self->target != NULL)
        g_array_unref (self->target);
      self->target = g_value_dup_boxed (value);
      self->__isset_target = TRUE;
      break;

    case PROP_I_FACE_LOG_RUN_CMD_ARGS_GROUP:
      self->group = g_value_get_boolean (value);
      break;

    case PROP_I_FACE_LOG_RUN_CMD_ARGS_CMDPATH:
      if (self->cmdpath != NULL)
        g_free (self->cmdpath);
      self->cmdpath = g_value_dup_string (value);
      self->__isset_cmdpath = TRUE;
      break;

    case PROP_I_FACE_LOG_RUN_CMD_ARGS_JSON_ARGS:
      if (self->jsonArgs != NULL)
        g_hash_table_unref (self->jsonArgs);
      self->jsonArgs = g_value_dup_boxed (value);
      self->__isset_jsonArgs = TRUE;
      break;

    case PROP_I_FACE_LOG_RUN_CMD_ARGS_ACK_CHANNEL:
      if (self->ackChannel != NULL)
        g_free (self->ackChannel);
      self->ackChannel = g_value_dup_string (value);
      self->__isset_ackChannel = TRUE;
      break;

    case PROP_I_FACE_LOG_RUN_CMD_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_run_cmd_args_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  IFaceLogRunCmdArgs *self = I_FACE_LOG_RUN_CMD_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_RUN_CMD_ARGS_TARGET:
      g_value_set_boxed (value, self->target);
      break;

    case PROP_I_FACE_LOG_RUN_CMD_ARGS_GROUP:
      g_value_set_boolean (value, self->group);
      break;

    case PROP_I_FACE_LOG_RUN_CMD_ARGS_CMDPATH:
      g_value_set_string (value, self->cmdpath);
      break;

    case PROP_I_FACE_LOG_RUN_CMD_ARGS_JSON_ARGS:
      g_value_set_boxed (value, self->jsonArgs);
      break;

    case PROP_I_FACE_LOG_RUN_CMD_ARGS_ACK_CHANNEL:
      g_value_set_string (value, self->ackChannel);
      break;

    case PROP_I_FACE_LOG_RUN_CMD_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_run_cmd_args_instance_init (IFaceLogRunCmdArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->target = g_array_new (0, 1, sizeof (gint32));
  object->__isset_target = FALSE;
  object->group = 0;
  object->cmdpath = NULL;
  object->__isset_cmdpath = FALSE;
  object->jsonArgs = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_jsonArgs = FALSE;
  object->ackChannel = NULL;
  object->__isset_ackChannel = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_run_cmd_args_finalize (GObject *object)
{
  IFaceLogRunCmdArgs *tobject = I_FACE_LOG_RUN_CMD_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->target != NULL)
  {
    g_array_unref (tobject->target);
    tobject->target = NULL;
  }
  if (tobject->cmdpath != NULL)
  {
    g_free(tobject->cmdpath);
    tobject->cmdpath = NULL;
  }
  if (tobject->jsonArgs != NULL)
  {
    g_hash_table_destroy (tobject->jsonArgs);
    tobject->jsonArgs = NULL;
  }
  if (tobject->ackChannel != NULL)
  {
    g_free(tobject->ackChannel);
    tobject->ackChannel = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_run_cmd_args_class_init (IFaceLogRunCmdArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_run_cmd_args_read;
  struct_class->write = i_face_log_run_cmd_args_write;

  gobject_class->finalize = i_face_log_run_cmd_args_finalize;
  gobject_class->get_property = i_face_log_run_cmd_args_get_property;
  gobject_class->set_property = i_face_log_run_cmd_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RUN_CMD_ARGS_TARGET,
     g_param_spec_boxed ("target",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RUN_CMD_ARGS_GROUP,
     g_param_spec_boolean ("group",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RUN_CMD_ARGS_CMDPATH,
     g_param_spec_string ("cmdpath",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RUN_CMD_ARGS_JSON_ARGS,
     g_param_spec_boxed ("jsonArgs",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RUN_CMD_ARGS_ACK_CHANNEL,
     g_param_spec_string ("ackChannel",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RUN_CMD_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_run_cmd_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogRunCmdArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_run_cmd_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogRunCmdArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_run_cmd_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogRunCmdArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogRunCmdResultProperties
{
  PROP_I_FACE_LOG_RUN_CMD_RESULT_0,
  PROP_I_FACE_LOG_RUN_CMD_RESULT_SUCCESS,
  PROP_I_FACE_LOG_RUN_CMD_RESULT_EX1
};

/* reads a i_face_log_run_cmd_result object */
static gint32
i_face_log_run_cmd_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogRunCmdResult * this_object = I_FACE_LOG_RUN_CMD_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_run_cmd_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogRunCmdResult * this_object = I_FACE_LOG_RUN_CMD_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogRunCmdResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_run_cmd_result_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  IFaceLogRunCmdResult *self = I_FACE_LOG_RUN_CMD_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_RUN_CMD_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_RUN_CMD_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_run_cmd_result_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  IFaceLogRunCmdResult *self = I_FACE_LOG_RUN_CMD_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_RUN_CMD_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_RUN_CMD_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_run_cmd_result_instance_init (IFaceLogRunCmdResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_run_cmd_result_finalize (GObject *object)
{
  IFaceLogRunCmdResult *tobject = I_FACE_LOG_RUN_CMD_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_run_cmd_result_class_init (IFaceLogRunCmdResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_run_cmd_result_read;
  struct_class->write = i_face_log_run_cmd_result_write;

  gobject_class->finalize = i_face_log_run_cmd_result_finalize;
  gobject_class->get_property = i_face_log_run_cmd_result_get_property;
  gobject_class->set_property = i_face_log_run_cmd_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RUN_CMD_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RUN_CMD_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_run_cmd_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogRunCmdResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_run_cmd_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogRunCmdResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_run_cmd_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogRunCmdResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogRunTaskArgsProperties
{
  PROP_I_FACE_LOG_RUN_TASK_ARGS_0,
  PROP_I_FACE_LOG_RUN_TASK_ARGS_TASK_QUEUE,
  PROP_I_FACE_LOG_RUN_TASK_ARGS_CMDPATH,
  PROP_I_FACE_LOG_RUN_TASK_ARGS_JSON_ARGS,
  PROP_I_FACE_LOG_RUN_TASK_ARGS_ACK_CHANNEL,
  PROP_I_FACE_LOG_RUN_TASK_ARGS_TOKEN
};

/* reads a i_face_log_run_task_args object */
static gint32
i_face_log_run_task_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogRunTaskArgs * this_object = I_FACE_LOG_RUN_TASK_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->taskQueue != NULL)
          {
            g_free(this_object->taskQueue);
            this_object->taskQueue = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->taskQueue, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_taskQueue = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->cmdpath != NULL)
          {
            g_free(this_object->cmdpath);
            this_object->cmdpath = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->cmdpath, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cmdpath = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key145 = NULL;
              gchar * val146 = NULL;
              if (key145 != NULL)
              {
                g_free(key145);
                key145 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key145, error)) < 0)
                return -1;
              xfer += ret;
              if (val146 != NULL)
              {
                g_free(val146);
                val146 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val146, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->jsonArgs && key145)
                g_hash_table_insert ((GHashTable *)this_object->jsonArgs, (gpointer) key145, (gpointer) val146);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_jsonArgs = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->ackChannel != NULL)
          {
            g_free(this_object->ackChannel);
            this_object->ackChannel = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->ackChannel, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ackChannel = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_run_task_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogRunTaskArgs * this_object = I_FACE_LOG_RUN_TASK_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogRunTaskArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "taskQueue", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->taskQueue, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cmdpath", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->cmdpath, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "jsonArgs", T_MAP, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    gchar * key147 = NULL;
    gchar * val148 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gchar ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->jsonArgs ? (gint32) g_hash_table_size ((GHashTable *) this_object->jsonArgs) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->jsonArgs)
      g_hash_table_foreach ((GHashTable *) this_object->jsonArgs, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gchar *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gchar *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key147 = keys[i];
      val148 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->jsonArgs), (gpointer) key147);

      if ((ret = thrift_protocol_write_string (protocol,  key147, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_string (protocol,  val148, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ackChannel", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->ackChannel, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_run_task_args_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  IFaceLogRunTaskArgs *self = I_FACE_LOG_RUN_TASK_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_RUN_TASK_ARGS_TASK_QUEUE:
      if (self->taskQueue != NULL)
        g_free (self->taskQueue);
      self->taskQueue = g_value_dup_string (value);
      self->__isset_taskQueue = TRUE;
      break;

    case PROP_I_FACE_LOG_RUN_TASK_ARGS_CMDPATH:
      if (self->cmdpath != NULL)
        g_free (self->cmdpath);
      self->cmdpath = g_value_dup_string (value);
      self->__isset_cmdpath = TRUE;
      break;

    case PROP_I_FACE_LOG_RUN_TASK_ARGS_JSON_ARGS:
      if (self->jsonArgs != NULL)
        g_hash_table_unref (self->jsonArgs);
      self->jsonArgs = g_value_dup_boxed (value);
      self->__isset_jsonArgs = TRUE;
      break;

    case PROP_I_FACE_LOG_RUN_TASK_ARGS_ACK_CHANNEL:
      if (self->ackChannel != NULL)
        g_free (self->ackChannel);
      self->ackChannel = g_value_dup_string (value);
      self->__isset_ackChannel = TRUE;
      break;

    case PROP_I_FACE_LOG_RUN_TASK_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_run_task_args_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  IFaceLogRunTaskArgs *self = I_FACE_LOG_RUN_TASK_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_RUN_TASK_ARGS_TASK_QUEUE:
      g_value_set_string (value, self->taskQueue);
      break;

    case PROP_I_FACE_LOG_RUN_TASK_ARGS_CMDPATH:
      g_value_set_string (value, self->cmdpath);
      break;

    case PROP_I_FACE_LOG_RUN_TASK_ARGS_JSON_ARGS:
      g_value_set_boxed (value, self->jsonArgs);
      break;

    case PROP_I_FACE_LOG_RUN_TASK_ARGS_ACK_CHANNEL:
      g_value_set_string (value, self->ackChannel);
      break;

    case PROP_I_FACE_LOG_RUN_TASK_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_run_task_args_instance_init (IFaceLogRunTaskArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->taskQueue = NULL;
  object->__isset_taskQueue = FALSE;
  object->cmdpath = NULL;
  object->__isset_cmdpath = FALSE;
  object->jsonArgs = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_jsonArgs = FALSE;
  object->ackChannel = NULL;
  object->__isset_ackChannel = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_run_task_args_finalize (GObject *object)
{
  IFaceLogRunTaskArgs *tobject = I_FACE_LOG_RUN_TASK_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->taskQueue != NULL)
  {
    g_free(tobject->taskQueue);
    tobject->taskQueue = NULL;
  }
  if (tobject->cmdpath != NULL)
  {
    g_free(tobject->cmdpath);
    tobject->cmdpath = NULL;
  }
  if (tobject->jsonArgs != NULL)
  {
    g_hash_table_destroy (tobject->jsonArgs);
    tobject->jsonArgs = NULL;
  }
  if (tobject->ackChannel != NULL)
  {
    g_free(tobject->ackChannel);
    tobject->ackChannel = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_run_task_args_class_init (IFaceLogRunTaskArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_run_task_args_read;
  struct_class->write = i_face_log_run_task_args_write;

  gobject_class->finalize = i_face_log_run_task_args_finalize;
  gobject_class->get_property = i_face_log_run_task_args_get_property;
  gobject_class->set_property = i_face_log_run_task_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RUN_TASK_ARGS_TASK_QUEUE,
     g_param_spec_string ("taskQueue",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RUN_TASK_ARGS_CMDPATH,
     g_param_spec_string ("cmdpath",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RUN_TASK_ARGS_JSON_ARGS,
     g_param_spec_boxed ("jsonArgs",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RUN_TASK_ARGS_ACK_CHANNEL,
     g_param_spec_string ("ackChannel",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RUN_TASK_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_run_task_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogRunTaskArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_run_task_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogRunTaskArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_run_task_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogRunTaskArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogRunTaskResultProperties
{
  PROP_I_FACE_LOG_RUN_TASK_RESULT_0,
  PROP_I_FACE_LOG_RUN_TASK_RESULT_SUCCESS,
  PROP_I_FACE_LOG_RUN_TASK_RESULT_EX1
};

/* reads a i_face_log_run_task_result object */
static gint32
i_face_log_run_task_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogRunTaskResult * this_object = I_FACE_LOG_RUN_TASK_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_run_task_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogRunTaskResult * this_object = I_FACE_LOG_RUN_TASK_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogRunTaskResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_BOOL, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_run_task_result_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  IFaceLogRunTaskResult *self = I_FACE_LOG_RUN_TASK_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_RUN_TASK_RESULT_SUCCESS:
      self->success = g_value_get_boolean (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_RUN_TASK_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_run_task_result_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  IFaceLogRunTaskResult *self = I_FACE_LOG_RUN_TASK_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_RUN_TASK_RESULT_SUCCESS:
      g_value_set_boolean (value, self->success);
      break;

    case PROP_I_FACE_LOG_RUN_TASK_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_run_task_result_instance_init (IFaceLogRunTaskResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_run_task_result_finalize (GObject *object)
{
  IFaceLogRunTaskResult *tobject = I_FACE_LOG_RUN_TASK_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_run_task_result_class_init (IFaceLogRunTaskResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_run_task_result_read;
  struct_class->write = i_face_log_run_task_result_write;

  gobject_class->finalize = i_face_log_run_task_result_finalize;
  gobject_class->get_property = i_face_log_run_task_result_get_property;
  gobject_class->set_property = i_face_log_run_task_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RUN_TASK_RESULT_SUCCESS,
     g_param_spec_boolean ("success",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_RUN_TASK_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_run_task_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogRunTaskResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_run_task_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogRunTaskResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_run_task_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogRunTaskResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSaveDeviceArgsProperties
{
  PROP_I_FACE_LOG_SAVE_DEVICE_ARGS_0,
  PROP_I_FACE_LOG_SAVE_DEVICE_ARGS_DEVICE_BEAN,
  PROP_I_FACE_LOG_SAVE_DEVICE_ARGS_TOKEN
};

/* reads a i_face_log_save_device_args object */
static gint32
i_face_log_save_device_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSaveDeviceArgs * this_object = I_FACE_LOG_SAVE_DEVICE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->deviceBean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_deviceBean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_device_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSaveDeviceArgs * this_object = I_FACE_LOG_SAVE_DEVICE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSaveDeviceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceBean", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->deviceBean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_device_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  IFaceLogSaveDeviceArgs *self = I_FACE_LOG_SAVE_DEVICE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_DEVICE_ARGS_DEVICE_BEAN:
      if (self->deviceBean != NULL)
        g_object_unref (self->deviceBean);
      self->deviceBean = g_value_dup_object (value);
      self->__isset_deviceBean = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_DEVICE_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_device_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  IFaceLogSaveDeviceArgs *self = I_FACE_LOG_SAVE_DEVICE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_DEVICE_ARGS_DEVICE_BEAN:
      g_value_set_object (value, self->deviceBean);
      break;

    case PROP_I_FACE_LOG_SAVE_DEVICE_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_device_args_instance_init (IFaceLogSaveDeviceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->deviceBean = g_object_new (TYPE_DEVICE_BEAN, NULL);
  object->__isset_deviceBean = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_save_device_args_finalize (GObject *object)
{
  IFaceLogSaveDeviceArgs *tobject = I_FACE_LOG_SAVE_DEVICE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->deviceBean != NULL)
  {
    g_object_unref(tobject->deviceBean);
    tobject->deviceBean = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_save_device_args_class_init (IFaceLogSaveDeviceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_device_args_read;
  struct_class->write = i_face_log_save_device_args_write;

  gobject_class->finalize = i_face_log_save_device_args_finalize;
  gobject_class->get_property = i_face_log_save_device_args_get_property;
  gobject_class->set_property = i_face_log_save_device_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_DEVICE_ARGS_DEVICE_BEAN,
     g_param_spec_object ("deviceBean",
                         NULL,
                         NULL,
                         TYPE_DEVICE_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_DEVICE_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_device_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSaveDeviceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_device_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSaveDeviceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_device_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSaveDeviceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSaveDeviceResultProperties
{
  PROP_I_FACE_LOG_SAVE_DEVICE_RESULT_0,
  PROP_I_FACE_LOG_SAVE_DEVICE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_SAVE_DEVICE_RESULT_EX1
};

/* reads a i_face_log_save_device_result object */
static gint32
i_face_log_save_device_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSaveDeviceResult * this_object = I_FACE_LOG_SAVE_DEVICE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_device_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSaveDeviceResult * this_object = I_FACE_LOG_SAVE_DEVICE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSaveDeviceResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_device_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogSaveDeviceResult *self = I_FACE_LOG_SAVE_DEVICE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_DEVICE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_DEVICE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_device_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogSaveDeviceResult *self = I_FACE_LOG_SAVE_DEVICE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_DEVICE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_SAVE_DEVICE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_device_result_instance_init (IFaceLogSaveDeviceResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_DEVICE_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_save_device_result_finalize (GObject *object)
{
  IFaceLogSaveDeviceResult *tobject = I_FACE_LOG_SAVE_DEVICE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_save_device_result_class_init (IFaceLogSaveDeviceResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_device_result_read;
  struct_class->write = i_face_log_save_device_result_write;

  gobject_class->finalize = i_face_log_save_device_result_finalize;
  gobject_class->get_property = i_face_log_save_device_result_get_property;
  gobject_class->set_property = i_face_log_save_device_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_DEVICE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_DEVICE_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_DEVICE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_device_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSaveDeviceResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_device_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSaveDeviceResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_device_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSaveDeviceResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSaveDeviceGroupArgsProperties
{
  PROP_I_FACE_LOG_SAVE_DEVICE_GROUP_ARGS_0,
  PROP_I_FACE_LOG_SAVE_DEVICE_GROUP_ARGS_DEVICE_GROUP_BEAN,
  PROP_I_FACE_LOG_SAVE_DEVICE_GROUP_ARGS_TOKEN
};

/* reads a i_face_log_save_device_group_args object */
static gint32
i_face_log_save_device_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSaveDeviceGroupArgs * this_object = I_FACE_LOG_SAVE_DEVICE_GROUP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->deviceGroupBean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_deviceGroupBean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_device_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSaveDeviceGroupArgs * this_object = I_FACE_LOG_SAVE_DEVICE_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSaveDeviceGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupBean", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->deviceGroupBean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_device_group_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogSaveDeviceGroupArgs *self = I_FACE_LOG_SAVE_DEVICE_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_DEVICE_GROUP_ARGS_DEVICE_GROUP_BEAN:
      if (self->deviceGroupBean != NULL)
        g_object_unref (self->deviceGroupBean);
      self->deviceGroupBean = g_value_dup_object (value);
      self->__isset_deviceGroupBean = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_DEVICE_GROUP_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_device_group_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogSaveDeviceGroupArgs *self = I_FACE_LOG_SAVE_DEVICE_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_DEVICE_GROUP_ARGS_DEVICE_GROUP_BEAN:
      g_value_set_object (value, self->deviceGroupBean);
      break;

    case PROP_I_FACE_LOG_SAVE_DEVICE_GROUP_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_device_group_args_instance_init (IFaceLogSaveDeviceGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->deviceGroupBean = g_object_new (TYPE_DEVICE_GROUP_BEAN, NULL);
  object->__isset_deviceGroupBean = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_save_device_group_args_finalize (GObject *object)
{
  IFaceLogSaveDeviceGroupArgs *tobject = I_FACE_LOG_SAVE_DEVICE_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->deviceGroupBean != NULL)
  {
    g_object_unref(tobject->deviceGroupBean);
    tobject->deviceGroupBean = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_save_device_group_args_class_init (IFaceLogSaveDeviceGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_device_group_args_read;
  struct_class->write = i_face_log_save_device_group_args_write;

  gobject_class->finalize = i_face_log_save_device_group_args_finalize;
  gobject_class->get_property = i_face_log_save_device_group_args_get_property;
  gobject_class->set_property = i_face_log_save_device_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_DEVICE_GROUP_ARGS_DEVICE_GROUP_BEAN,
     g_param_spec_object ("deviceGroupBean",
                         NULL,
                         NULL,
                         TYPE_DEVICE_GROUP_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_DEVICE_GROUP_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_device_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSaveDeviceGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_device_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSaveDeviceGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_device_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSaveDeviceGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSaveDeviceGroupResultProperties
{
  PROP_I_FACE_LOG_SAVE_DEVICE_GROUP_RESULT_0,
  PROP_I_FACE_LOG_SAVE_DEVICE_GROUP_RESULT_SUCCESS,
  PROP_I_FACE_LOG_SAVE_DEVICE_GROUP_RESULT_EX1
};

/* reads a i_face_log_save_device_group_result object */
static gint32
i_face_log_save_device_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSaveDeviceGroupResult * this_object = I_FACE_LOG_SAVE_DEVICE_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_device_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSaveDeviceGroupResult * this_object = I_FACE_LOG_SAVE_DEVICE_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSaveDeviceGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_device_group_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogSaveDeviceGroupResult *self = I_FACE_LOG_SAVE_DEVICE_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_DEVICE_GROUP_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_DEVICE_GROUP_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_device_group_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogSaveDeviceGroupResult *self = I_FACE_LOG_SAVE_DEVICE_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_DEVICE_GROUP_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_SAVE_DEVICE_GROUP_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_device_group_result_instance_init (IFaceLogSaveDeviceGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_DEVICE_GROUP_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_save_device_group_result_finalize (GObject *object)
{
  IFaceLogSaveDeviceGroupResult *tobject = I_FACE_LOG_SAVE_DEVICE_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_save_device_group_result_class_init (IFaceLogSaveDeviceGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_device_group_result_read;
  struct_class->write = i_face_log_save_device_group_result_write;

  gobject_class->finalize = i_face_log_save_device_group_result_finalize;
  gobject_class->get_property = i_face_log_save_device_group_result_get_property;
  gobject_class->set_property = i_face_log_save_device_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_DEVICE_GROUP_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_DEVICE_GROUP_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_DEVICE_GROUP_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_device_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSaveDeviceGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_device_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSaveDeviceGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_device_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSaveDeviceGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePermitArgsProperties
{
  PROP_I_FACE_LOG_SAVE_PERMIT_ARGS_0,
  PROP_I_FACE_LOG_SAVE_PERMIT_ARGS_PERMIT_BEAN,
  PROP_I_FACE_LOG_SAVE_PERMIT_ARGS_TOKEN
};

/* reads a i_face_log_save_permit_args object */
static gint32
i_face_log_save_permit_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePermitArgs * this_object = I_FACE_LOG_SAVE_PERMIT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->permitBean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_permitBean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_permit_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePermitArgs * this_object = I_FACE_LOG_SAVE_PERMIT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePermitArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "permitBean", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->permitBean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_permit_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  IFaceLogSavePermitArgs *self = I_FACE_LOG_SAVE_PERMIT_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERMIT_ARGS_PERMIT_BEAN:
      if (self->permitBean != NULL)
        g_object_unref (self->permitBean);
      self->permitBean = g_value_dup_object (value);
      self->__isset_permitBean = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERMIT_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_permit_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  IFaceLogSavePermitArgs *self = I_FACE_LOG_SAVE_PERMIT_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERMIT_ARGS_PERMIT_BEAN:
      g_value_set_object (value, self->permitBean);
      break;

    case PROP_I_FACE_LOG_SAVE_PERMIT_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_permit_args_instance_init (IFaceLogSavePermitArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->permitBean = g_object_new (TYPE_PERMIT_BEAN, NULL);
  object->__isset_permitBean = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_save_permit_args_finalize (GObject *object)
{
  IFaceLogSavePermitArgs *tobject = I_FACE_LOG_SAVE_PERMIT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->permitBean != NULL)
  {
    g_object_unref(tobject->permitBean);
    tobject->permitBean = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_save_permit_args_class_init (IFaceLogSavePermitArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_permit_args_read;
  struct_class->write = i_face_log_save_permit_args_write;

  gobject_class->finalize = i_face_log_save_permit_args_finalize;
  gobject_class->get_property = i_face_log_save_permit_args_get_property;
  gobject_class->set_property = i_face_log_save_permit_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERMIT_ARGS_PERMIT_BEAN,
     g_param_spec_object ("permitBean",
                         NULL,
                         NULL,
                         TYPE_PERMIT_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERMIT_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_permit_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePermitArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_permit_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePermitArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_permit_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePermitArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePermitResultProperties
{
  PROP_I_FACE_LOG_SAVE_PERMIT_RESULT_0,
  PROP_I_FACE_LOG_SAVE_PERMIT_RESULT_SUCCESS,
  PROP_I_FACE_LOG_SAVE_PERMIT_RESULT_EX1
};

/* reads a i_face_log_save_permit_result object */
static gint32
i_face_log_save_permit_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePermitResult * this_object = I_FACE_LOG_SAVE_PERMIT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_permit_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePermitResult * this_object = I_FACE_LOG_SAVE_PERMIT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePermitResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_permit_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogSavePermitResult *self = I_FACE_LOG_SAVE_PERMIT_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERMIT_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERMIT_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_permit_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogSavePermitResult *self = I_FACE_LOG_SAVE_PERMIT_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERMIT_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_SAVE_PERMIT_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_permit_result_instance_init (IFaceLogSavePermitResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_PERMIT_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_save_permit_result_finalize (GObject *object)
{
  IFaceLogSavePermitResult *tobject = I_FACE_LOG_SAVE_PERMIT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_save_permit_result_class_init (IFaceLogSavePermitResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_permit_result_read;
  struct_class->write = i_face_log_save_permit_result_write;

  gobject_class->finalize = i_face_log_save_permit_result_finalize;
  gobject_class->get_property = i_face_log_save_permit_result_get_property;
  gobject_class->set_property = i_face_log_save_permit_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERMIT_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_PERMIT_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERMIT_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_permit_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePermitResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_permit_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePermitResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_permit_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePermitResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePermitWithScheduleArgsProperties
{
  PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS_0,
  PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS_DEVICE_GROUP_ID,
  PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS_PERSON_GROUP_ID,
  PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS_SCHEDULE,
  PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS_TOKEN
};

/* reads a i_face_log_save_permit_with_schedule_args object */
static gint32
i_face_log_save_permit_with_schedule_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePermitWithScheduleArgs * this_object = I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS(object);
  gboolean isset_deviceGroupId = FALSE;
  gboolean isset_personGroupId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_deviceGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personGroupId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->schedule != NULL)
          {
            g_free(this_object->schedule);
            this_object->schedule = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->schedule, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_schedule = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_deviceGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_personGroupId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_save_permit_with_schedule_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePermitWithScheduleArgs * this_object = I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePermitWithScheduleArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "schedule", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->schedule, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_permit_with_schedule_args_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  IFaceLogSavePermitWithScheduleArgs *self = I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS_DEVICE_GROUP_ID:
      self->deviceGroupId = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS_PERSON_GROUP_ID:
      self->personGroupId = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS_SCHEDULE:
      if (self->schedule != NULL)
        g_free (self->schedule);
      self->schedule = g_value_dup_string (value);
      self->__isset_schedule = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_permit_with_schedule_args_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  IFaceLogSavePermitWithScheduleArgs *self = I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS_DEVICE_GROUP_ID:
      g_value_set_int (value, self->deviceGroupId);
      break;

    case PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS_PERSON_GROUP_ID:
      g_value_set_int (value, self->personGroupId);
      break;

    case PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS_SCHEDULE:
      g_value_set_string (value, self->schedule);
      break;

    case PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_permit_with_schedule_args_instance_init (IFaceLogSavePermitWithScheduleArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->deviceGroupId = 0;
  object->personGroupId = 0;
  object->schedule = NULL;
  object->__isset_schedule = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_save_permit_with_schedule_args_finalize (GObject *object)
{
  IFaceLogSavePermitWithScheduleArgs *tobject = I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->schedule != NULL)
  {
    g_free(tobject->schedule);
    tobject->schedule = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_save_permit_with_schedule_args_class_init (IFaceLogSavePermitWithScheduleArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_permit_with_schedule_args_read;
  struct_class->write = i_face_log_save_permit_with_schedule_args_write;

  gobject_class->finalize = i_face_log_save_permit_with_schedule_args_finalize;
  gobject_class->get_property = i_face_log_save_permit_with_schedule_args_get_property;
  gobject_class->set_property = i_face_log_save_permit_with_schedule_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS_DEVICE_GROUP_ID,
     g_param_spec_int ("deviceGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS_PERSON_GROUP_ID,
     g_param_spec_int ("personGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS_SCHEDULE,
     g_param_spec_string ("schedule",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_permit_with_schedule_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePermitWithScheduleArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_permit_with_schedule_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePermitWithScheduleArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_permit_with_schedule_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePermitWithScheduleArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePermitWithScheduleResultProperties
{
  PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_RESULT_0,
  PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_RESULT_EX1
};

/* reads a i_face_log_save_permit_with_schedule_result object */
static gint32
i_face_log_save_permit_with_schedule_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePermitWithScheduleResult * this_object = I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_permit_with_schedule_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePermitWithScheduleResult * this_object = I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePermitWithScheduleResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_permit_with_schedule_result_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  IFaceLogSavePermitWithScheduleResult *self = I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_permit_with_schedule_result_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  IFaceLogSavePermitWithScheduleResult *self = I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_permit_with_schedule_result_instance_init (IFaceLogSavePermitWithScheduleResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_PERMIT_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_save_permit_with_schedule_result_finalize (GObject *object)
{
  IFaceLogSavePermitWithScheduleResult *tobject = I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_save_permit_with_schedule_result_class_init (IFaceLogSavePermitWithScheduleResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_permit_with_schedule_result_read;
  struct_class->write = i_face_log_save_permit_with_schedule_result_write;

  gobject_class->finalize = i_face_log_save_permit_with_schedule_result_finalize;
  gobject_class->get_property = i_face_log_save_permit_with_schedule_result_get_property;
  gobject_class->set_property = i_face_log_save_permit_with_schedule_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_PERMIT_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_permit_with_schedule_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePermitWithScheduleResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_permit_with_schedule_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePermitWithScheduleResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_permit_with_schedule_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePermitWithScheduleResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePersonArgsProperties
{
  PROP_I_FACE_LOG_SAVE_PERSON_ARGS_0,
  PROP_I_FACE_LOG_SAVE_PERSON_ARGS_PERSON_BEAN,
  PROP_I_FACE_LOG_SAVE_PERSON_ARGS_TOKEN
};

/* reads a i_face_log_save_person_args object */
static gint32
i_face_log_save_person_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePersonArgs * this_object = I_FACE_LOG_SAVE_PERSON_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->personBean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_personBean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_person_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePersonArgs * this_object = I_FACE_LOG_SAVE_PERSON_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePersonArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personBean", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->personBean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_person_args_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  IFaceLogSavePersonArgs *self = I_FACE_LOG_SAVE_PERSON_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_ARGS_PERSON_BEAN:
      if (self->personBean != NULL)
        g_object_unref (self->personBean);
      self->personBean = g_value_dup_object (value);
      self->__isset_personBean = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_person_args_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  IFaceLogSavePersonArgs *self = I_FACE_LOG_SAVE_PERSON_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_ARGS_PERSON_BEAN:
      g_value_set_object (value, self->personBean);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_person_args_instance_init (IFaceLogSavePersonArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personBean = g_object_new (TYPE_PERSON_BEAN, NULL);
  object->__isset_personBean = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_save_person_args_finalize (GObject *object)
{
  IFaceLogSavePersonArgs *tobject = I_FACE_LOG_SAVE_PERSON_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->personBean != NULL)
  {
    g_object_unref(tobject->personBean);
    tobject->personBean = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_save_person_args_class_init (IFaceLogSavePersonArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_person_args_read;
  struct_class->write = i_face_log_save_person_args_write;

  gobject_class->finalize = i_face_log_save_person_args_finalize;
  gobject_class->get_property = i_face_log_save_person_args_get_property;
  gobject_class->set_property = i_face_log_save_person_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_ARGS_PERSON_BEAN,
     g_param_spec_object ("personBean",
                         NULL,
                         NULL,
                         TYPE_PERSON_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_person_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePersonArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_person_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePersonArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_person_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePersonArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePersonResultProperties
{
  PROP_I_FACE_LOG_SAVE_PERSON_RESULT_0,
  PROP_I_FACE_LOG_SAVE_PERSON_RESULT_SUCCESS,
  PROP_I_FACE_LOG_SAVE_PERSON_RESULT_EX1
};

/* reads a i_face_log_save_person_result object */
static gint32
i_face_log_save_person_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePersonResult * this_object = I_FACE_LOG_SAVE_PERSON_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_person_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePersonResult * this_object = I_FACE_LOG_SAVE_PERSON_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePersonResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_person_result_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogSavePersonResult *self = I_FACE_LOG_SAVE_PERSON_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_person_result_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogSavePersonResult *self = I_FACE_LOG_SAVE_PERSON_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_person_result_instance_init (IFaceLogSavePersonResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_PERSON_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_save_person_result_finalize (GObject *object)
{
  IFaceLogSavePersonResult *tobject = I_FACE_LOG_SAVE_PERSON_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_save_person_result_class_init (IFaceLogSavePersonResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_person_result_read;
  struct_class->write = i_face_log_save_person_result_write;

  gobject_class->finalize = i_face_log_save_person_result_finalize;
  gobject_class->get_property = i_face_log_save_person_result_get_property;
  gobject_class->set_property = i_face_log_save_person_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_PERSON_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_person_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePersonResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_person_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePersonResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_person_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePersonResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePersonFullArgsProperties
{
  PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_0,
  PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_PERSON_BEAN,
  PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_ID_PHOTO,
  PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_FEATURE,
  PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_FEATURE_VERSION,
  PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_FEATURE_IMAGE,
  PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_FEATURE_FACE_BEAN,
  PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_TOKEN
};

/* reads a i_face_log_save_person_full_args object */
static gint32
i_face_log_save_person_full_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePersonFullArgs * this_object = I_FACE_LOG_SAVE_PERSON_FULL_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->personBean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_personBean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->idPhoto != NULL)
          {
            g_free(this_object->idPhoto);
            this_object->idPhoto = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->idPhoto = g_byte_array_new();
          g_byte_array_append (this_object->idPhoto, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_idPhoto = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->feature != NULL)
          {
            g_free(this_object->feature);
            this_object->feature = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->feature = g_byte_array_new();
          g_byte_array_append (this_object->feature, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_feature = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->featureVersion != NULL)
          {
            g_free(this_object->featureVersion);
            this_object->featureVersion = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->featureVersion, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_featureVersion = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->featureImage != NULL)
          {
            g_free(this_object->featureImage);
            this_object->featureImage = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->featureImage = g_byte_array_new();
          g_byte_array_append (this_object->featureImage, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_featureImage = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->featureFaceBean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_featureFaceBean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_person_full_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePersonFullArgs * this_object = I_FACE_LOG_SAVE_PERSON_FULL_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePersonFullArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personBean", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->personBean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "idPhoto", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->idPhoto ? ((GByteArray *) this_object->idPhoto)->data : NULL, this_object->idPhoto ? ((GByteArray *) this_object->idPhoto)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "feature", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->feature ? ((GByteArray *) this_object->feature)->data : NULL, this_object->feature ? ((GByteArray *) this_object->feature)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "featureVersion", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->featureVersion, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "featureImage", T_STRING, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->featureImage ? ((GByteArray *) this_object->featureImage)->data : NULL, this_object->featureImage ? ((GByteArray *) this_object->featureImage)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "featureFaceBean", T_STRUCT, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->featureFaceBean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_person_full_args_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogSavePersonFullArgs *self = I_FACE_LOG_SAVE_PERSON_FULL_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_PERSON_BEAN:
      if (self->personBean != NULL)
        g_object_unref (self->personBean);
      self->personBean = g_value_dup_object (value);
      self->__isset_personBean = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_ID_PHOTO:
      if (self->idPhoto != NULL)
        g_byte_array_unref (self->idPhoto);
      self->idPhoto = g_value_dup_boxed (value);
      self->__isset_idPhoto = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_FEATURE:
      if (self->feature != NULL)
        g_byte_array_unref (self->feature);
      self->feature = g_value_dup_boxed (value);
      self->__isset_feature = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_FEATURE_VERSION:
      if (self->featureVersion != NULL)
        g_free (self->featureVersion);
      self->featureVersion = g_value_dup_string (value);
      self->__isset_featureVersion = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_FEATURE_IMAGE:
      if (self->featureImage != NULL)
        g_byte_array_unref (self->featureImage);
      self->featureImage = g_value_dup_boxed (value);
      self->__isset_featureImage = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_FEATURE_FACE_BEAN:
      if (self->featureFaceBean != NULL)
        g_object_unref (self->featureFaceBean);
      self->featureFaceBean = g_value_dup_object (value);
      self->__isset_featureFaceBean = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_person_full_args_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogSavePersonFullArgs *self = I_FACE_LOG_SAVE_PERSON_FULL_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_PERSON_BEAN:
      g_value_set_object (value, self->personBean);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_ID_PHOTO:
      g_value_set_boxed (value, self->idPhoto);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_FEATURE:
      g_value_set_boxed (value, self->feature);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_FEATURE_VERSION:
      g_value_set_string (value, self->featureVersion);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_FEATURE_IMAGE:
      g_value_set_boxed (value, self->featureImage);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_FEATURE_FACE_BEAN:
      g_value_set_object (value, self->featureFaceBean);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_person_full_args_instance_init (IFaceLogSavePersonFullArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personBean = g_object_new (TYPE_PERSON_BEAN, NULL);
  object->__isset_personBean = FALSE;
  object->idPhoto = NULL;
  object->__isset_idPhoto = FALSE;
  object->feature = NULL;
  object->__isset_feature = FALSE;
  object->featureVersion = NULL;
  object->__isset_featureVersion = FALSE;
  object->featureImage = NULL;
  object->__isset_featureImage = FALSE;
  object->featureFaceBean = g_object_new (TYPE_FACE_BEAN, NULL);
  object->__isset_featureFaceBean = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_save_person_full_args_finalize (GObject *object)
{
  IFaceLogSavePersonFullArgs *tobject = I_FACE_LOG_SAVE_PERSON_FULL_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->personBean != NULL)
  {
    g_object_unref(tobject->personBean);
    tobject->personBean = NULL;
  }
  if (tobject->idPhoto != NULL)
  {
    thrift_string_free(tobject->idPhoto);
    tobject->idPhoto = NULL;
  }
  if (tobject->feature != NULL)
  {
    thrift_string_free(tobject->feature);
    tobject->feature = NULL;
  }
  if (tobject->featureVersion != NULL)
  {
    g_free(tobject->featureVersion);
    tobject->featureVersion = NULL;
  }
  if (tobject->featureImage != NULL)
  {
    thrift_string_free(tobject->featureImage);
    tobject->featureImage = NULL;
  }
  if (tobject->featureFaceBean != NULL)
  {
    g_object_unref(tobject->featureFaceBean);
    tobject->featureFaceBean = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_save_person_full_args_class_init (IFaceLogSavePersonFullArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_person_full_args_read;
  struct_class->write = i_face_log_save_person_full_args_write;

  gobject_class->finalize = i_face_log_save_person_full_args_finalize;
  gobject_class->get_property = i_face_log_save_person_full_args_get_property;
  gobject_class->set_property = i_face_log_save_person_full_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_PERSON_BEAN,
     g_param_spec_object ("personBean",
                         NULL,
                         NULL,
                         TYPE_PERSON_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_ID_PHOTO,
     g_param_spec_boxed ("idPhoto",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_FEATURE,
     g_param_spec_boxed ("feature",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_FEATURE_VERSION,
     g_param_spec_string ("featureVersion",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_FEATURE_IMAGE,
     g_param_spec_boxed ("featureImage",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_FEATURE_FACE_BEAN,
     g_param_spec_object ("featureFaceBean",
                         NULL,
                         NULL,
                         TYPE_FACE_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_FULL_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_person_full_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePersonFullArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_person_full_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePersonFullArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_person_full_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePersonFullArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePersonFullResultProperties
{
  PROP_I_FACE_LOG_SAVE_PERSON_FULL_RESULT_0,
  PROP_I_FACE_LOG_SAVE_PERSON_FULL_RESULT_SUCCESS,
  PROP_I_FACE_LOG_SAVE_PERSON_FULL_RESULT_EX1
};

/* reads a i_face_log_save_person_full_result object */
static gint32
i_face_log_save_person_full_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePersonFullResult * this_object = I_FACE_LOG_SAVE_PERSON_FULL_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_person_full_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePersonFullResult * this_object = I_FACE_LOG_SAVE_PERSON_FULL_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePersonFullResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_person_full_result_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogSavePersonFullResult *self = I_FACE_LOG_SAVE_PERSON_FULL_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_FULL_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_FULL_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_person_full_result_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  IFaceLogSavePersonFullResult *self = I_FACE_LOG_SAVE_PERSON_FULL_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_FULL_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_FULL_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_person_full_result_instance_init (IFaceLogSavePersonFullResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_PERSON_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_save_person_full_result_finalize (GObject *object)
{
  IFaceLogSavePersonFullResult *tobject = I_FACE_LOG_SAVE_PERSON_FULL_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_save_person_full_result_class_init (IFaceLogSavePersonFullResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_person_full_result_read;
  struct_class->write = i_face_log_save_person_full_result_write;

  gobject_class->finalize = i_face_log_save_person_full_result_finalize;
  gobject_class->get_property = i_face_log_save_person_full_result_get_property;
  gobject_class->set_property = i_face_log_save_person_full_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_FULL_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_PERSON_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_FULL_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_person_full_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePersonFullResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_person_full_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePersonFullResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_person_full_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePersonFullResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePersonGroupArgsProperties
{
  PROP_I_FACE_LOG_SAVE_PERSON_GROUP_ARGS_0,
  PROP_I_FACE_LOG_SAVE_PERSON_GROUP_ARGS_PERSON_GROUP_BEAN,
  PROP_I_FACE_LOG_SAVE_PERSON_GROUP_ARGS_TOKEN
};

/* reads a i_face_log_save_person_group_args object */
static gint32
i_face_log_save_person_group_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePersonGroupArgs * this_object = I_FACE_LOG_SAVE_PERSON_GROUP_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->personGroupBean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_personGroupBean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_person_group_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePersonGroupArgs * this_object = I_FACE_LOG_SAVE_PERSON_GROUP_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePersonGroupArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupBean", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->personGroupBean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_person_group_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogSavePersonGroupArgs *self = I_FACE_LOG_SAVE_PERSON_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_GROUP_ARGS_PERSON_GROUP_BEAN:
      if (self->personGroupBean != NULL)
        g_object_unref (self->personGroupBean);
      self->personGroupBean = g_value_dup_object (value);
      self->__isset_personGroupBean = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_GROUP_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_person_group_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogSavePersonGroupArgs *self = I_FACE_LOG_SAVE_PERSON_GROUP_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_GROUP_ARGS_PERSON_GROUP_BEAN:
      g_value_set_object (value, self->personGroupBean);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_GROUP_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_person_group_args_instance_init (IFaceLogSavePersonGroupArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personGroupBean = g_object_new (TYPE_PERSON_GROUP_BEAN, NULL);
  object->__isset_personGroupBean = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_save_person_group_args_finalize (GObject *object)
{
  IFaceLogSavePersonGroupArgs *tobject = I_FACE_LOG_SAVE_PERSON_GROUP_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->personGroupBean != NULL)
  {
    g_object_unref(tobject->personGroupBean);
    tobject->personGroupBean = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_save_person_group_args_class_init (IFaceLogSavePersonGroupArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_person_group_args_read;
  struct_class->write = i_face_log_save_person_group_args_write;

  gobject_class->finalize = i_face_log_save_person_group_args_finalize;
  gobject_class->get_property = i_face_log_save_person_group_args_get_property;
  gobject_class->set_property = i_face_log_save_person_group_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_GROUP_ARGS_PERSON_GROUP_BEAN,
     g_param_spec_object ("personGroupBean",
                         NULL,
                         NULL,
                         TYPE_PERSON_GROUP_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_GROUP_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_person_group_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePersonGroupArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_person_group_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePersonGroupArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_person_group_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePersonGroupArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePersonGroupResultProperties
{
  PROP_I_FACE_LOG_SAVE_PERSON_GROUP_RESULT_0,
  PROP_I_FACE_LOG_SAVE_PERSON_GROUP_RESULT_SUCCESS,
  PROP_I_FACE_LOG_SAVE_PERSON_GROUP_RESULT_EX1
};

/* reads a i_face_log_save_person_group_result object */
static gint32
i_face_log_save_person_group_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePersonGroupResult * this_object = I_FACE_LOG_SAVE_PERSON_GROUP_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_person_group_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePersonGroupResult * this_object = I_FACE_LOG_SAVE_PERSON_GROUP_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePersonGroupResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_person_group_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogSavePersonGroupResult *self = I_FACE_LOG_SAVE_PERSON_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_GROUP_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_GROUP_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_person_group_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogSavePersonGroupResult *self = I_FACE_LOG_SAVE_PERSON_GROUP_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_GROUP_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_GROUP_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_person_group_result_instance_init (IFaceLogSavePersonGroupResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_PERSON_GROUP_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_save_person_group_result_finalize (GObject *object)
{
  IFaceLogSavePersonGroupResult *tobject = I_FACE_LOG_SAVE_PERSON_GROUP_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_save_person_group_result_class_init (IFaceLogSavePersonGroupResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_person_group_result_read;
  struct_class->write = i_face_log_save_person_group_result_write;

  gobject_class->finalize = i_face_log_save_person_group_result_finalize;
  gobject_class->get_property = i_face_log_save_person_group_result_get_property;
  gobject_class->set_property = i_face_log_save_person_group_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_GROUP_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_PERSON_GROUP_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_GROUP_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_person_group_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePersonGroupResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_person_group_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePersonGroupResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_person_group_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePersonGroupResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePersonWithPhotoArgsProperties
{
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_ARGS_0,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_ARGS_PERSON_BEAN,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_ARGS_ID_PHOTO,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_ARGS_TOKEN
};

/* reads a i_face_log_save_person_with_photo_args object */
static gint32
i_face_log_save_person_with_photo_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePersonWithPhotoArgs * this_object = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->personBean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_personBean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->idPhoto != NULL)
          {
            g_free(this_object->idPhoto);
            this_object->idPhoto = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->idPhoto = g_byte_array_new();
          g_byte_array_append (this_object->idPhoto, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_idPhoto = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_person_with_photo_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePersonWithPhotoArgs * this_object = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePersonWithPhotoArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personBean", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->personBean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "idPhoto", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->idPhoto ? ((GByteArray *) this_object->idPhoto)->data : NULL, this_object->idPhoto ? ((GByteArray *) this_object->idPhoto)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_person_with_photo_args_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogSavePersonWithPhotoArgs *self = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_ARGS_PERSON_BEAN:
      if (self->personBean != NULL)
        g_object_unref (self->personBean);
      self->personBean = g_value_dup_object (value);
      self->__isset_personBean = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_ARGS_ID_PHOTO:
      if (self->idPhoto != NULL)
        g_byte_array_unref (self->idPhoto);
      self->idPhoto = g_value_dup_boxed (value);
      self->__isset_idPhoto = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_person_with_photo_args_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogSavePersonWithPhotoArgs *self = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_ARGS_PERSON_BEAN:
      g_value_set_object (value, self->personBean);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_ARGS_ID_PHOTO:
      g_value_set_boxed (value, self->idPhoto);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_person_with_photo_args_instance_init (IFaceLogSavePersonWithPhotoArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personBean = g_object_new (TYPE_PERSON_BEAN, NULL);
  object->__isset_personBean = FALSE;
  object->idPhoto = NULL;
  object->__isset_idPhoto = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_save_person_with_photo_args_finalize (GObject *object)
{
  IFaceLogSavePersonWithPhotoArgs *tobject = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->personBean != NULL)
  {
    g_object_unref(tobject->personBean);
    tobject->personBean = NULL;
  }
  if (tobject->idPhoto != NULL)
  {
    thrift_string_free(tobject->idPhoto);
    tobject->idPhoto = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_save_person_with_photo_args_class_init (IFaceLogSavePersonWithPhotoArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_person_with_photo_args_read;
  struct_class->write = i_face_log_save_person_with_photo_args_write;

  gobject_class->finalize = i_face_log_save_person_with_photo_args_finalize;
  gobject_class->get_property = i_face_log_save_person_with_photo_args_get_property;
  gobject_class->set_property = i_face_log_save_person_with_photo_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_ARGS_PERSON_BEAN,
     g_param_spec_object ("personBean",
                         NULL,
                         NULL,
                         TYPE_PERSON_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_ARGS_ID_PHOTO,
     g_param_spec_boxed ("idPhoto",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_person_with_photo_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePersonWithPhotoArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_person_with_photo_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePersonWithPhotoArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_person_with_photo_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePersonWithPhotoArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePersonWithPhotoResultProperties
{
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_RESULT_0,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_RESULT_SUCCESS,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_RESULT_EX1
};

/* reads a i_face_log_save_person_with_photo_result object */
static gint32
i_face_log_save_person_with_photo_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePersonWithPhotoResult * this_object = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_person_with_photo_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePersonWithPhotoResult * this_object = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePersonWithPhotoResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_person_with_photo_result_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  IFaceLogSavePersonWithPhotoResult *self = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_person_with_photo_result_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  IFaceLogSavePersonWithPhotoResult *self = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_person_with_photo_result_instance_init (IFaceLogSavePersonWithPhotoResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_PERSON_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_save_person_with_photo_result_finalize (GObject *object)
{
  IFaceLogSavePersonWithPhotoResult *tobject = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_save_person_with_photo_result_class_init (IFaceLogSavePersonWithPhotoResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_person_with_photo_result_read;
  struct_class->write = i_face_log_save_person_with_photo_result_write;

  gobject_class->finalize = i_face_log_save_person_with_photo_result_finalize;
  gobject_class->get_property = i_face_log_save_person_with_photo_result_get_property;
  gobject_class->set_property = i_face_log_save_person_with_photo_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_PERSON_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_person_with_photo_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePersonWithPhotoResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_person_with_photo_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePersonWithPhotoResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_person_with_photo_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePersonWithPhotoResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePersonWithPhotoAndFeatureArgsProperties
{
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS_0,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS_PERSON_BEAN,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS_ID_PHOTO,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS_FEATURE_BEAN,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS_TOKEN
};

/* reads a i_face_log_save_person_with_photo_and_feature_args object */
static gint32
i_face_log_save_person_with_photo_and_feature_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePersonWithPhotoAndFeatureArgs * this_object = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->personBean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_personBean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->idPhoto != NULL)
          {
            g_free(this_object->idPhoto);
            this_object->idPhoto = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->idPhoto = g_byte_array_new();
          g_byte_array_append (this_object->idPhoto, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_idPhoto = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->featureBean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_featureBean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_person_with_photo_and_feature_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePersonWithPhotoAndFeatureArgs * this_object = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePersonWithPhotoAndFeatureArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personBean", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->personBean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "idPhoto", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->idPhoto ? ((GByteArray *) this_object->idPhoto)->data : NULL, this_object->idPhoto ? ((GByteArray *) this_object->idPhoto)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "featureBean", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->featureBean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_person_with_photo_and_feature_args_set_property (GObject *object,
                                                                 guint property_id,
                                                                 const GValue *value,
                                                                 GParamSpec *pspec)
{
  IFaceLogSavePersonWithPhotoAndFeatureArgs *self = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS_PERSON_BEAN:
      if (self->personBean != NULL)
        g_object_unref (self->personBean);
      self->personBean = g_value_dup_object (value);
      self->__isset_personBean = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS_ID_PHOTO:
      if (self->idPhoto != NULL)
        g_byte_array_unref (self->idPhoto);
      self->idPhoto = g_value_dup_boxed (value);
      self->__isset_idPhoto = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS_FEATURE_BEAN:
      if (self->featureBean != NULL)
        g_object_unref (self->featureBean);
      self->featureBean = g_value_dup_object (value);
      self->__isset_featureBean = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_person_with_photo_and_feature_args_get_property (GObject *object,
                                                                 guint property_id,
                                                                 GValue *value,
                                                                 GParamSpec *pspec)
{
  IFaceLogSavePersonWithPhotoAndFeatureArgs *self = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS_PERSON_BEAN:
      g_value_set_object (value, self->personBean);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS_ID_PHOTO:
      g_value_set_boxed (value, self->idPhoto);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS_FEATURE_BEAN:
      g_value_set_object (value, self->featureBean);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_person_with_photo_and_feature_args_instance_init (IFaceLogSavePersonWithPhotoAndFeatureArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personBean = g_object_new (TYPE_PERSON_BEAN, NULL);
  object->__isset_personBean = FALSE;
  object->idPhoto = NULL;
  object->__isset_idPhoto = FALSE;
  object->featureBean = g_object_new (TYPE_FEATURE_BEAN, NULL);
  object->__isset_featureBean = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_save_person_with_photo_and_feature_args_finalize (GObject *object)
{
  IFaceLogSavePersonWithPhotoAndFeatureArgs *tobject = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->personBean != NULL)
  {
    g_object_unref(tobject->personBean);
    tobject->personBean = NULL;
  }
  if (tobject->idPhoto != NULL)
  {
    thrift_string_free(tobject->idPhoto);
    tobject->idPhoto = NULL;
  }
  if (tobject->featureBean != NULL)
  {
    g_object_unref(tobject->featureBean);
    tobject->featureBean = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_save_person_with_photo_and_feature_args_class_init (IFaceLogSavePersonWithPhotoAndFeatureArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_person_with_photo_and_feature_args_read;
  struct_class->write = i_face_log_save_person_with_photo_and_feature_args_write;

  gobject_class->finalize = i_face_log_save_person_with_photo_and_feature_args_finalize;
  gobject_class->get_property = i_face_log_save_person_with_photo_and_feature_args_get_property;
  gobject_class->set_property = i_face_log_save_person_with_photo_and_feature_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS_PERSON_BEAN,
     g_param_spec_object ("personBean",
                         NULL,
                         NULL,
                         TYPE_PERSON_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS_ID_PHOTO,
     g_param_spec_boxed ("idPhoto",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS_FEATURE_BEAN,
     g_param_spec_object ("featureBean",
                         NULL,
                         NULL,
                         TYPE_FEATURE_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_person_with_photo_and_feature_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePersonWithPhotoAndFeatureArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_person_with_photo_and_feature_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePersonWithPhotoAndFeatureArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_person_with_photo_and_feature_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePersonWithPhotoAndFeatureArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePersonWithPhotoAndFeatureResultProperties
{
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_RESULT_0,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_RESULT_EX1
};

/* reads a i_face_log_save_person_with_photo_and_feature_result object */
static gint32
i_face_log_save_person_with_photo_and_feature_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePersonWithPhotoAndFeatureResult * this_object = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_person_with_photo_and_feature_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePersonWithPhotoAndFeatureResult * this_object = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePersonWithPhotoAndFeatureResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_person_with_photo_and_feature_result_set_property (GObject *object,
                                                                   guint property_id,
                                                                   const GValue *value,
                                                                   GParamSpec *pspec)
{
  IFaceLogSavePersonWithPhotoAndFeatureResult *self = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_person_with_photo_and_feature_result_get_property (GObject *object,
                                                                   guint property_id,
                                                                   GValue *value,
                                                                   GParamSpec *pspec)
{
  IFaceLogSavePersonWithPhotoAndFeatureResult *self = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_person_with_photo_and_feature_result_instance_init (IFaceLogSavePersonWithPhotoAndFeatureResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_PERSON_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_save_person_with_photo_and_feature_result_finalize (GObject *object)
{
  IFaceLogSavePersonWithPhotoAndFeatureResult *tobject = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_save_person_with_photo_and_feature_result_class_init (IFaceLogSavePersonWithPhotoAndFeatureResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_person_with_photo_and_feature_result_read;
  struct_class->write = i_face_log_save_person_with_photo_and_feature_result_write;

  gobject_class->finalize = i_face_log_save_person_with_photo_and_feature_result_finalize;
  gobject_class->get_property = i_face_log_save_person_with_photo_and_feature_result_get_property;
  gobject_class->set_property = i_face_log_save_person_with_photo_and_feature_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_PERSON_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_person_with_photo_and_feature_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePersonWithPhotoAndFeatureResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_person_with_photo_and_feature_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePersonWithPhotoAndFeatureResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_person_with_photo_and_feature_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePersonWithPhotoAndFeatureResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePersonWithPhotoAndFeatureMultiFacesArgsProperties
{
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_0,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_PERSON_BEAN,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_ID_PHOTO,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_FEATURE,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_FEATURE_VERSION,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_FACE_BEANS,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_TOKEN
};

/* reads a i_face_log_save_person_with_photo_and_feature_multi_faces_args object */
static gint32
i_face_log_save_person_with_photo_and_feature_multi_faces_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePersonWithPhotoAndFeatureMultiFacesArgs * this_object = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->personBean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_personBean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->idPhoto != NULL)
          {
            g_free(this_object->idPhoto);
            this_object->idPhoto = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->idPhoto = g_byte_array_new();
          g_byte_array_append (this_object->idPhoto, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_idPhoto = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->feature != NULL)
          {
            g_free(this_object->feature);
            this_object->feature = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->feature = g_byte_array_new();
          g_byte_array_append (this_object->feature, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_feature = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->featureVersion != NULL)
          {
            g_free(this_object->featureVersion);
            this_object->featureVersion = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->featureVersion, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_featureVersion = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              FaceBean * _elem149 = NULL;
              if ( _elem149 != NULL)
              {
                g_object_unref (_elem149);
              }
              _elem149 = g_object_new (TYPE_FACE_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem149), protocol, error)) < 0)
              {
                g_object_unref (_elem149);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->faceBeans, _elem149);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_faceBeans = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_person_with_photo_and_feature_multi_faces_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePersonWithPhotoAndFeatureMultiFacesArgs * this_object = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePersonWithPhotoAndFeatureMultiFacesArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personBean", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->personBean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "idPhoto", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->idPhoto ? ((GByteArray *) this_object->idPhoto)->data : NULL, this_object->idPhoto ? ((GByteArray *) this_object->idPhoto)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "feature", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->feature ? ((GByteArray *) this_object->feature)->data : NULL, this_object->feature ? ((GByteArray *) this_object->feature)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "featureVersion", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->featureVersion, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "faceBeans", T_LIST, 5, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i150;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->faceBeans ? this_object->faceBeans->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i150 = 0; i150 < (this_object->faceBeans ? this_object->faceBeans->len : 0); i150++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->faceBeans, i150))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_person_with_photo_and_feature_multi_faces_args_set_property (GObject *object,
                                                                             guint property_id,
                                                                             const GValue *value,
                                                                             GParamSpec *pspec)
{
  IFaceLogSavePersonWithPhotoAndFeatureMultiFacesArgs *self = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_PERSON_BEAN:
      if (self->personBean != NULL)
        g_object_unref (self->personBean);
      self->personBean = g_value_dup_object (value);
      self->__isset_personBean = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_ID_PHOTO:
      if (self->idPhoto != NULL)
        g_byte_array_unref (self->idPhoto);
      self->idPhoto = g_value_dup_boxed (value);
      self->__isset_idPhoto = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_FEATURE:
      if (self->feature != NULL)
        g_byte_array_unref (self->feature);
      self->feature = g_value_dup_boxed (value);
      self->__isset_feature = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_FEATURE_VERSION:
      if (self->featureVersion != NULL)
        g_free (self->featureVersion);
      self->featureVersion = g_value_dup_string (value);
      self->__isset_featureVersion = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_FACE_BEANS:
      if (self->faceBeans != NULL)
        g_ptr_array_unref (self->faceBeans);
      self->faceBeans = g_value_dup_boxed (value);
      self->__isset_faceBeans = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_person_with_photo_and_feature_multi_faces_args_get_property (GObject *object,
                                                                             guint property_id,
                                                                             GValue *value,
                                                                             GParamSpec *pspec)
{
  IFaceLogSavePersonWithPhotoAndFeatureMultiFacesArgs *self = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_PERSON_BEAN:
      g_value_set_object (value, self->personBean);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_ID_PHOTO:
      g_value_set_boxed (value, self->idPhoto);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_FEATURE:
      g_value_set_boxed (value, self->feature);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_FEATURE_VERSION:
      g_value_set_string (value, self->featureVersion);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_FACE_BEANS:
      g_value_set_boxed (value, self->faceBeans);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_person_with_photo_and_feature_multi_faces_args_instance_init (IFaceLogSavePersonWithPhotoAndFeatureMultiFacesArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personBean = g_object_new (TYPE_PERSON_BEAN, NULL);
  object->__isset_personBean = FALSE;
  object->idPhoto = NULL;
  object->__isset_idPhoto = FALSE;
  object->feature = NULL;
  object->__isset_feature = FALSE;
  object->featureVersion = NULL;
  object->__isset_featureVersion = FALSE;
  object->faceBeans = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_faceBeans = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_save_person_with_photo_and_feature_multi_faces_args_finalize (GObject *object)
{
  IFaceLogSavePersonWithPhotoAndFeatureMultiFacesArgs *tobject = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->personBean != NULL)
  {
    g_object_unref(tobject->personBean);
    tobject->personBean = NULL;
  }
  if (tobject->idPhoto != NULL)
  {
    thrift_string_free(tobject->idPhoto);
    tobject->idPhoto = NULL;
  }
  if (tobject->feature != NULL)
  {
    thrift_string_free(tobject->feature);
    tobject->feature = NULL;
  }
  if (tobject->featureVersion != NULL)
  {
    g_free(tobject->featureVersion);
    tobject->featureVersion = NULL;
  }
  if (tobject->faceBeans != NULL)
  {
    g_ptr_array_unref (tobject->faceBeans);
    tobject->faceBeans = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_save_person_with_photo_and_feature_multi_faces_args_class_init (IFaceLogSavePersonWithPhotoAndFeatureMultiFacesArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_person_with_photo_and_feature_multi_faces_args_read;
  struct_class->write = i_face_log_save_person_with_photo_and_feature_multi_faces_args_write;

  gobject_class->finalize = i_face_log_save_person_with_photo_and_feature_multi_faces_args_finalize;
  gobject_class->get_property = i_face_log_save_person_with_photo_and_feature_multi_faces_args_get_property;
  gobject_class->set_property = i_face_log_save_person_with_photo_and_feature_multi_faces_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_PERSON_BEAN,
     g_param_spec_object ("personBean",
                         NULL,
                         NULL,
                         TYPE_PERSON_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_ID_PHOTO,
     g_param_spec_boxed ("idPhoto",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_FEATURE,
     g_param_spec_boxed ("feature",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_FEATURE_VERSION,
     g_param_spec_string ("featureVersion",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_FACE_BEANS,
     g_param_spec_boxed ("faceBeans",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_person_with_photo_and_feature_multi_faces_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePersonWithPhotoAndFeatureMultiFacesArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_person_with_photo_and_feature_multi_faces_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePersonWithPhotoAndFeatureMultiFacesArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_person_with_photo_and_feature_multi_faces_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePersonWithPhotoAndFeatureMultiFacesArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePersonWithPhotoAndFeatureMultiFacesResultProperties
{
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_RESULT_0,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_RESULT_SUCCESS,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_RESULT_EX1
};

/* reads a i_face_log_save_person_with_photo_and_feature_multi_faces_result object */
static gint32
i_face_log_save_person_with_photo_and_feature_multi_faces_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePersonWithPhotoAndFeatureMultiFacesResult * this_object = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_person_with_photo_and_feature_multi_faces_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePersonWithPhotoAndFeatureMultiFacesResult * this_object = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePersonWithPhotoAndFeatureMultiFacesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_person_with_photo_and_feature_multi_faces_result_set_property (GObject *object,
                                                                               guint property_id,
                                                                               const GValue *value,
                                                                               GParamSpec *pspec)
{
  IFaceLogSavePersonWithPhotoAndFeatureMultiFacesResult *self = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_person_with_photo_and_feature_multi_faces_result_get_property (GObject *object,
                                                                               guint property_id,
                                                                               GValue *value,
                                                                               GParamSpec *pspec)
{
  IFaceLogSavePersonWithPhotoAndFeatureMultiFacesResult *self = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_person_with_photo_and_feature_multi_faces_result_instance_init (IFaceLogSavePersonWithPhotoAndFeatureMultiFacesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_PERSON_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_save_person_with_photo_and_feature_multi_faces_result_finalize (GObject *object)
{
  IFaceLogSavePersonWithPhotoAndFeatureMultiFacesResult *tobject = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_save_person_with_photo_and_feature_multi_faces_result_class_init (IFaceLogSavePersonWithPhotoAndFeatureMultiFacesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_person_with_photo_and_feature_multi_faces_result_read;
  struct_class->write = i_face_log_save_person_with_photo_and_feature_multi_faces_result_write;

  gobject_class->finalize = i_face_log_save_person_with_photo_and_feature_multi_faces_result_finalize;
  gobject_class->get_property = i_face_log_save_person_with_photo_and_feature_multi_faces_result_get_property;
  gobject_class->set_property = i_face_log_save_person_with_photo_and_feature_multi_faces_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_PERSON_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_person_with_photo_and_feature_multi_faces_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePersonWithPhotoAndFeatureMultiFacesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_person_with_photo_and_feature_multi_faces_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePersonWithPhotoAndFeatureMultiFacesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_person_with_photo_and_feature_multi_faces_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePersonWithPhotoAndFeatureMultiFacesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePersonWithPhotoAndFeatureMultiImageArgsProperties
{
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_0,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_PERSON_BEAN,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_ID_PHOTO,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_FEATURE,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_FEATURE_VERSION,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_FACE_INFO,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_TOKEN
};

/* reads a i_face_log_save_person_with_photo_and_feature_multi_image_args object */
static gint32
i_face_log_save_person_with_photo_and_feature_multi_image_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePersonWithPhotoAndFeatureMultiImageArgs * this_object = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->personBean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_personBean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->idPhoto != NULL)
          {
            g_free(this_object->idPhoto);
            this_object->idPhoto = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->idPhoto = g_byte_array_new();
          g_byte_array_append (this_object->idPhoto, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_idPhoto = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->feature != NULL)
          {
            g_free(this_object->feature);
            this_object->feature = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->feature = g_byte_array_new();
          g_byte_array_append (this_object->feature, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_feature = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->featureVersion != NULL)
          {
            g_free(this_object->featureVersion);
            this_object->featureVersion = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->featureVersion, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_featureVersion = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              GByteArray * key151 = NULL;
              FaceBean * val152 = NULL;
              if (key151 != NULL)
              {
                g_free(key151);
                key151 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key151 = g_byte_array_new();
              g_byte_array_append (key151, (guint8 *) data, (guint) len);
              g_free (data);
              if ( val152 != NULL)
              {
                g_object_unref (val152);
              }
              val152 = g_object_new (TYPE_FACE_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (val152), protocol, error)) < 0)
              {
                g_object_unref (val152);
                return -1;
              }
              xfer += ret;
              if (this_object->faceInfo && key151)
                g_hash_table_insert ((GHashTable *)this_object->faceInfo, (gpointer) key151, (gpointer) val152);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_faceInfo = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_person_with_photo_and_feature_multi_image_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePersonWithPhotoAndFeatureMultiImageArgs * this_object = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePersonWithPhotoAndFeatureMultiImageArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personBean", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->personBean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "idPhoto", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->idPhoto ? ((GByteArray *) this_object->idPhoto)->data : NULL, this_object->idPhoto ? ((GByteArray *) this_object->idPhoto)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "feature", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->feature ? ((GByteArray *) this_object->feature)->data : NULL, this_object->feature ? ((GByteArray *) this_object->feature)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "featureVersion", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->featureVersion, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "faceInfo", T_MAP, 5, error)) < 0)
    return -1;
  xfer += ret;
  {
    GByteArray * key153 = NULL;
    FaceBean * val154 = NULL;
    GList *key_list = NULL, *iter = NULL;
    GByteArray ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRUCT, this_object->faceInfo ? (gint32) g_hash_table_size ((GHashTable *) this_object->faceInfo) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->faceInfo)
      g_hash_table_foreach ((GHashTable *) this_object->faceInfo, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (GByteArray *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (GByteArray *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key153 = keys[i];
      val154 = (FaceBean *) g_hash_table_lookup (((GHashTable *) this_object->faceInfo), (gpointer) key153);

      if ((ret = thrift_protocol_write_binary (protocol,  key153 ? ((GByteArray *)  key153)->data : NULL,  key153 ? ((GByteArray *)  key153)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_struct_write (THRIFT_STRUCT ( val154), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_person_with_photo_and_feature_multi_image_args_set_property (GObject *object,
                                                                             guint property_id,
                                                                             const GValue *value,
                                                                             GParamSpec *pspec)
{
  IFaceLogSavePersonWithPhotoAndFeatureMultiImageArgs *self = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_PERSON_BEAN:
      if (self->personBean != NULL)
        g_object_unref (self->personBean);
      self->personBean = g_value_dup_object (value);
      self->__isset_personBean = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_ID_PHOTO:
      if (self->idPhoto != NULL)
        g_byte_array_unref (self->idPhoto);
      self->idPhoto = g_value_dup_boxed (value);
      self->__isset_idPhoto = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_FEATURE:
      if (self->feature != NULL)
        g_byte_array_unref (self->feature);
      self->feature = g_value_dup_boxed (value);
      self->__isset_feature = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_FEATURE_VERSION:
      if (self->featureVersion != NULL)
        g_free (self->featureVersion);
      self->featureVersion = g_value_dup_string (value);
      self->__isset_featureVersion = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_FACE_INFO:
      if (self->faceInfo != NULL)
        g_hash_table_unref (self->faceInfo);
      self->faceInfo = g_value_dup_boxed (value);
      self->__isset_faceInfo = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_person_with_photo_and_feature_multi_image_args_get_property (GObject *object,
                                                                             guint property_id,
                                                                             GValue *value,
                                                                             GParamSpec *pspec)
{
  IFaceLogSavePersonWithPhotoAndFeatureMultiImageArgs *self = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_PERSON_BEAN:
      g_value_set_object (value, self->personBean);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_ID_PHOTO:
      g_value_set_boxed (value, self->idPhoto);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_FEATURE:
      g_value_set_boxed (value, self->feature);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_FEATURE_VERSION:
      g_value_set_string (value, self->featureVersion);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_FACE_INFO:
      g_value_set_boxed (value, self->faceInfo);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_person_with_photo_and_feature_multi_image_args_instance_init (IFaceLogSavePersonWithPhotoAndFeatureMultiImageArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personBean = g_object_new (TYPE_PERSON_BEAN, NULL);
  object->__isset_personBean = FALSE;
  object->idPhoto = NULL;
  object->__isset_idPhoto = FALSE;
  object->feature = NULL;
  object->__isset_feature = FALSE;
  object->featureVersion = NULL;
  object->__isset_featureVersion = FALSE;
  object->faceInfo = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, g_object_unref);
  object->__isset_faceInfo = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_save_person_with_photo_and_feature_multi_image_args_finalize (GObject *object)
{
  IFaceLogSavePersonWithPhotoAndFeatureMultiImageArgs *tobject = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->personBean != NULL)
  {
    g_object_unref(tobject->personBean);
    tobject->personBean = NULL;
  }
  if (tobject->idPhoto != NULL)
  {
    thrift_string_free(tobject->idPhoto);
    tobject->idPhoto = NULL;
  }
  if (tobject->feature != NULL)
  {
    thrift_string_free(tobject->feature);
    tobject->feature = NULL;
  }
  if (tobject->featureVersion != NULL)
  {
    g_free(tobject->featureVersion);
    tobject->featureVersion = NULL;
  }
  if (tobject->faceInfo != NULL)
  {
    g_hash_table_destroy (tobject->faceInfo);
    tobject->faceInfo = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_save_person_with_photo_and_feature_multi_image_args_class_init (IFaceLogSavePersonWithPhotoAndFeatureMultiImageArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_person_with_photo_and_feature_multi_image_args_read;
  struct_class->write = i_face_log_save_person_with_photo_and_feature_multi_image_args_write;

  gobject_class->finalize = i_face_log_save_person_with_photo_and_feature_multi_image_args_finalize;
  gobject_class->get_property = i_face_log_save_person_with_photo_and_feature_multi_image_args_get_property;
  gobject_class->set_property = i_face_log_save_person_with_photo_and_feature_multi_image_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_PERSON_BEAN,
     g_param_spec_object ("personBean",
                         NULL,
                         NULL,
                         TYPE_PERSON_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_ID_PHOTO,
     g_param_spec_boxed ("idPhoto",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_FEATURE,
     g_param_spec_boxed ("feature",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_FEATURE_VERSION,
     g_param_spec_string ("featureVersion",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_FACE_INFO,
     g_param_spec_boxed ("faceInfo",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_person_with_photo_and_feature_multi_image_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePersonWithPhotoAndFeatureMultiImageArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_person_with_photo_and_feature_multi_image_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePersonWithPhotoAndFeatureMultiImageArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_person_with_photo_and_feature_multi_image_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePersonWithPhotoAndFeatureMultiImageArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePersonWithPhotoAndFeatureMultiImageResultProperties
{
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_RESULT_0,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_RESULT_EX1
};

/* reads a i_face_log_save_person_with_photo_and_feature_multi_image_result object */
static gint32
i_face_log_save_person_with_photo_and_feature_multi_image_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePersonWithPhotoAndFeatureMultiImageResult * this_object = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_person_with_photo_and_feature_multi_image_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePersonWithPhotoAndFeatureMultiImageResult * this_object = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePersonWithPhotoAndFeatureMultiImageResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_person_with_photo_and_feature_multi_image_result_set_property (GObject *object,
                                                                               guint property_id,
                                                                               const GValue *value,
                                                                               GParamSpec *pspec)
{
  IFaceLogSavePersonWithPhotoAndFeatureMultiImageResult *self = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_person_with_photo_and_feature_multi_image_result_get_property (GObject *object,
                                                                               guint property_id,
                                                                               GValue *value,
                                                                               GParamSpec *pspec)
{
  IFaceLogSavePersonWithPhotoAndFeatureMultiImageResult *self = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_person_with_photo_and_feature_multi_image_result_instance_init (IFaceLogSavePersonWithPhotoAndFeatureMultiImageResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_PERSON_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_save_person_with_photo_and_feature_multi_image_result_finalize (GObject *object)
{
  IFaceLogSavePersonWithPhotoAndFeatureMultiImageResult *tobject = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_save_person_with_photo_and_feature_multi_image_result_class_init (IFaceLogSavePersonWithPhotoAndFeatureMultiImageResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_person_with_photo_and_feature_multi_image_result_read;
  struct_class->write = i_face_log_save_person_with_photo_and_feature_multi_image_result_write;

  gobject_class->finalize = i_face_log_save_person_with_photo_and_feature_multi_image_result_finalize;
  gobject_class->get_property = i_face_log_save_person_with_photo_and_feature_multi_image_result_get_property;
  gobject_class->set_property = i_face_log_save_person_with_photo_and_feature_multi_image_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_PERSON_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_person_with_photo_and_feature_multi_image_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePersonWithPhotoAndFeatureMultiImageResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_person_with_photo_and_feature_multi_image_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePersonWithPhotoAndFeatureMultiImageResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_person_with_photo_and_feature_multi_image_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePersonWithPhotoAndFeatureMultiImageResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePersonWithPhotoAndFeatureSavedArgsProperties
{
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS_0,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS_PERSON_BEAN,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS_ID_PHOTO_MD5,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS_FEATURE_MD5,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS_TOKEN
};

/* reads a i_face_log_save_person_with_photo_and_feature_saved_args object */
static gint32
i_face_log_save_person_with_photo_and_feature_saved_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePersonWithPhotoAndFeatureSavedArgs * this_object = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->personBean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_personBean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->idPhotoMd5 != NULL)
          {
            g_free(this_object->idPhotoMd5);
            this_object->idPhotoMd5 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->idPhotoMd5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_idPhotoMd5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->featureMd5 != NULL)
          {
            g_free(this_object->featureMd5);
            this_object->featureMd5 = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->featureMd5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_featureMd5 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_person_with_photo_and_feature_saved_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePersonWithPhotoAndFeatureSavedArgs * this_object = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePersonWithPhotoAndFeatureSavedArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personBean", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->personBean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "idPhotoMd5", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->idPhotoMd5, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "featureMd5", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->featureMd5, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_person_with_photo_and_feature_saved_args_set_property (GObject *object,
                                                                       guint property_id,
                                                                       const GValue *value,
                                                                       GParamSpec *pspec)
{
  IFaceLogSavePersonWithPhotoAndFeatureSavedArgs *self = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS_PERSON_BEAN:
      if (self->personBean != NULL)
        g_object_unref (self->personBean);
      self->personBean = g_value_dup_object (value);
      self->__isset_personBean = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS_ID_PHOTO_MD5:
      if (self->idPhotoMd5 != NULL)
        g_free (self->idPhotoMd5);
      self->idPhotoMd5 = g_value_dup_string (value);
      self->__isset_idPhotoMd5 = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS_FEATURE_MD5:
      if (self->featureMd5 != NULL)
        g_free (self->featureMd5);
      self->featureMd5 = g_value_dup_string (value);
      self->__isset_featureMd5 = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_person_with_photo_and_feature_saved_args_get_property (GObject *object,
                                                                       guint property_id,
                                                                       GValue *value,
                                                                       GParamSpec *pspec)
{
  IFaceLogSavePersonWithPhotoAndFeatureSavedArgs *self = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS_PERSON_BEAN:
      g_value_set_object (value, self->personBean);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS_ID_PHOTO_MD5:
      g_value_set_string (value, self->idPhotoMd5);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS_FEATURE_MD5:
      g_value_set_string (value, self->featureMd5);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_person_with_photo_and_feature_saved_args_instance_init (IFaceLogSavePersonWithPhotoAndFeatureSavedArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personBean = g_object_new (TYPE_PERSON_BEAN, NULL);
  object->__isset_personBean = FALSE;
  object->idPhotoMd5 = NULL;
  object->__isset_idPhotoMd5 = FALSE;
  object->featureMd5 = NULL;
  object->__isset_featureMd5 = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_save_person_with_photo_and_feature_saved_args_finalize (GObject *object)
{
  IFaceLogSavePersonWithPhotoAndFeatureSavedArgs *tobject = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->personBean != NULL)
  {
    g_object_unref(tobject->personBean);
    tobject->personBean = NULL;
  }
  if (tobject->idPhotoMd5 != NULL)
  {
    g_free(tobject->idPhotoMd5);
    tobject->idPhotoMd5 = NULL;
  }
  if (tobject->featureMd5 != NULL)
  {
    g_free(tobject->featureMd5);
    tobject->featureMd5 = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_save_person_with_photo_and_feature_saved_args_class_init (IFaceLogSavePersonWithPhotoAndFeatureSavedArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_person_with_photo_and_feature_saved_args_read;
  struct_class->write = i_face_log_save_person_with_photo_and_feature_saved_args_write;

  gobject_class->finalize = i_face_log_save_person_with_photo_and_feature_saved_args_finalize;
  gobject_class->get_property = i_face_log_save_person_with_photo_and_feature_saved_args_get_property;
  gobject_class->set_property = i_face_log_save_person_with_photo_and_feature_saved_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS_PERSON_BEAN,
     g_param_spec_object ("personBean",
                         NULL,
                         NULL,
                         TYPE_PERSON_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS_ID_PHOTO_MD5,
     g_param_spec_string ("idPhotoMd5",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS_FEATURE_MD5,
     g_param_spec_string ("featureMd5",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_person_with_photo_and_feature_saved_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePersonWithPhotoAndFeatureSavedArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_person_with_photo_and_feature_saved_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePersonWithPhotoAndFeatureSavedArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_person_with_photo_and_feature_saved_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePersonWithPhotoAndFeatureSavedArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePersonWithPhotoAndFeatureSavedResultProperties
{
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_RESULT_0,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_RESULT_SUCCESS,
  PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_RESULT_EX1
};

/* reads a i_face_log_save_person_with_photo_and_feature_saved_result object */
static gint32
i_face_log_save_person_with_photo_and_feature_saved_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePersonWithPhotoAndFeatureSavedResult * this_object = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_person_with_photo_and_feature_saved_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePersonWithPhotoAndFeatureSavedResult * this_object = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePersonWithPhotoAndFeatureSavedResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_person_with_photo_and_feature_saved_result_set_property (GObject *object,
                                                                         guint property_id,
                                                                         const GValue *value,
                                                                         GParamSpec *pspec)
{
  IFaceLogSavePersonWithPhotoAndFeatureSavedResult *self = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_person_with_photo_and_feature_saved_result_get_property (GObject *object,
                                                                         guint property_id,
                                                                         GValue *value,
                                                                         GParamSpec *pspec)
{
  IFaceLogSavePersonWithPhotoAndFeatureSavedResult *self = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_person_with_photo_and_feature_saved_result_instance_init (IFaceLogSavePersonWithPhotoAndFeatureSavedResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_PERSON_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_save_person_with_photo_and_feature_saved_result_finalize (GObject *object)
{
  IFaceLogSavePersonWithPhotoAndFeatureSavedResult *tobject = I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_save_person_with_photo_and_feature_saved_result_class_init (IFaceLogSavePersonWithPhotoAndFeatureSavedResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_person_with_photo_and_feature_saved_result_read;
  struct_class->write = i_face_log_save_person_with_photo_and_feature_saved_result_write;

  gobject_class->finalize = i_face_log_save_person_with_photo_and_feature_saved_result_finalize;
  gobject_class->get_property = i_face_log_save_person_with_photo_and_feature_saved_result_get_property;
  gobject_class->set_property = i_face_log_save_person_with_photo_and_feature_saved_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_PERSON_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_person_with_photo_and_feature_saved_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePersonWithPhotoAndFeatureSavedResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_person_with_photo_and_feature_saved_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePersonWithPhotoAndFeatureSavedResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_person_with_photo_and_feature_saved_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePersonWithPhotoAndFeatureSavedResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePersonsArgsProperties
{
  PROP_I_FACE_LOG_SAVE_PERSONS_ARGS_0,
  PROP_I_FACE_LOG_SAVE_PERSONS_ARGS_PERSONS,
  PROP_I_FACE_LOG_SAVE_PERSONS_ARGS_TOKEN
};

/* reads a i_face_log_save_persons_args object */
static gint32
i_face_log_save_persons_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePersonsArgs * this_object = I_FACE_LOG_SAVE_PERSONS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              PersonBean * _elem155 = NULL;
              if ( _elem155 != NULL)
              {
                g_object_unref (_elem155);
              }
              _elem155 = g_object_new (TYPE_PERSON_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem155), protocol, error)) < 0)
              {
                g_object_unref (_elem155);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->persons, _elem155);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_persons = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_persons_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePersonsArgs * this_object = I_FACE_LOG_SAVE_PERSONS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePersonsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "persons", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i156;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->persons ? this_object->persons->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i156 = 0; i156 < (this_object->persons ? this_object->persons->len : 0); i156++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->persons, i156))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_persons_args_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogSavePersonsArgs *self = I_FACE_LOG_SAVE_PERSONS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSONS_ARGS_PERSONS:
      if (self->persons != NULL)
        g_ptr_array_unref (self->persons);
      self->persons = g_value_dup_boxed (value);
      self->__isset_persons = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSONS_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_persons_args_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogSavePersonsArgs *self = I_FACE_LOG_SAVE_PERSONS_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSONS_ARGS_PERSONS:
      g_value_set_boxed (value, self->persons);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSONS_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_persons_args_instance_init (IFaceLogSavePersonsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->persons = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_persons = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_save_persons_args_finalize (GObject *object)
{
  IFaceLogSavePersonsArgs *tobject = I_FACE_LOG_SAVE_PERSONS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->persons != NULL)
  {
    g_ptr_array_unref (tobject->persons);
    tobject->persons = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_save_persons_args_class_init (IFaceLogSavePersonsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_persons_args_read;
  struct_class->write = i_face_log_save_persons_args_write;

  gobject_class->finalize = i_face_log_save_persons_args_finalize;
  gobject_class->get_property = i_face_log_save_persons_args_get_property;
  gobject_class->set_property = i_face_log_save_persons_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSONS_ARGS_PERSONS,
     g_param_spec_boxed ("persons",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSONS_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_persons_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePersonsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_persons_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePersonsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_persons_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePersonsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePersonsResultProperties
{
  PROP_I_FACE_LOG_SAVE_PERSONS_RESULT_0,
  PROP_I_FACE_LOG_SAVE_PERSONS_RESULT_EX1
};

/* reads a i_face_log_save_persons_result object */
static gint32
i_face_log_save_persons_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePersonsResult * this_object = I_FACE_LOG_SAVE_PERSONS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_persons_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePersonsResult * this_object = I_FACE_LOG_SAVE_PERSONS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePersonsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_persons_result_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogSavePersonsResult *self = I_FACE_LOG_SAVE_PERSONS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSONS_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_persons_result_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogSavePersonsResult *self = I_FACE_LOG_SAVE_PERSONS_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSONS_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_persons_result_instance_init (IFaceLogSavePersonsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_save_persons_result_finalize (GObject *object)
{
  IFaceLogSavePersonsResult *tobject = I_FACE_LOG_SAVE_PERSONS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_save_persons_result_class_init (IFaceLogSavePersonsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_persons_result_read;
  struct_class->write = i_face_log_save_persons_result_write;

  gobject_class->finalize = i_face_log_save_persons_result_finalize;
  gobject_class->get_property = i_face_log_save_persons_result_get_property;
  gobject_class->set_property = i_face_log_save_persons_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSONS_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_persons_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePersonsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_persons_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePersonsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_persons_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePersonsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePersonsWithPhotoArgsProperties
{
  PROP_I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_ARGS_0,
  PROP_I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_ARGS_PERSONS,
  PROP_I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_ARGS_TOKEN
};

/* reads a i_face_log_save_persons_with_photo_args object */
static gint32
i_face_log_save_persons_with_photo_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePersonsWithPhotoArgs * this_object = I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              GByteArray * key157 = NULL;
              PersonBean * val158 = NULL;
              if (key157 != NULL)
              {
                g_free(key157);
                key157 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key157 = g_byte_array_new();
              g_byte_array_append (key157, (guint8 *) data, (guint) len);
              g_free (data);
              if ( val158 != NULL)
              {
                g_object_unref (val158);
              }
              val158 = g_object_new (TYPE_PERSON_BEAN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (val158), protocol, error)) < 0)
              {
                g_object_unref (val158);
                return -1;
              }
              xfer += ret;
              if (this_object->persons && key157)
                g_hash_table_insert ((GHashTable *)this_object->persons, (gpointer) key157, (gpointer) val158);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_persons = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_persons_with_photo_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePersonsWithPhotoArgs * this_object = I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePersonsWithPhotoArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "persons", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    GByteArray * key159 = NULL;
    PersonBean * val160 = NULL;
    GList *key_list = NULL, *iter = NULL;
    GByteArray ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRUCT, this_object->persons ? (gint32) g_hash_table_size ((GHashTable *) this_object->persons) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->persons)
      g_hash_table_foreach ((GHashTable *) this_object->persons, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (GByteArray *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (GByteArray *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key159 = keys[i];
      val160 = (PersonBean *) g_hash_table_lookup (((GHashTable *) this_object->persons), (gpointer) key159);

      if ((ret = thrift_protocol_write_binary (protocol,  key159 ? ((GByteArray *)  key159)->data : NULL,  key159 ? ((GByteArray *)  key159)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_struct_write (THRIFT_STRUCT ( val160), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_persons_with_photo_args_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  IFaceLogSavePersonsWithPhotoArgs *self = I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_ARGS_PERSONS:
      if (self->persons != NULL)
        g_hash_table_unref (self->persons);
      self->persons = g_value_dup_boxed (value);
      self->__isset_persons = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_persons_with_photo_args_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  IFaceLogSavePersonsWithPhotoArgs *self = I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_ARGS_PERSONS:
      g_value_set_boxed (value, self->persons);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_persons_with_photo_args_instance_init (IFaceLogSavePersonsWithPhotoArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->persons = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, g_object_unref);
  object->__isset_persons = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_save_persons_with_photo_args_finalize (GObject *object)
{
  IFaceLogSavePersonsWithPhotoArgs *tobject = I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->persons != NULL)
  {
    g_hash_table_destroy (tobject->persons);
    tobject->persons = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_save_persons_with_photo_args_class_init (IFaceLogSavePersonsWithPhotoArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_persons_with_photo_args_read;
  struct_class->write = i_face_log_save_persons_with_photo_args_write;

  gobject_class->finalize = i_face_log_save_persons_with_photo_args_finalize;
  gobject_class->get_property = i_face_log_save_persons_with_photo_args_get_property;
  gobject_class->set_property = i_face_log_save_persons_with_photo_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_ARGS_PERSONS,
     g_param_spec_boxed ("persons",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_persons_with_photo_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePersonsWithPhotoArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_persons_with_photo_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePersonsWithPhotoArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_persons_with_photo_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePersonsWithPhotoArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSavePersonsWithPhotoResultProperties
{
  PROP_I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_RESULT_0,
  PROP_I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_RESULT_SUCCESS,
  PROP_I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_RESULT_EX1
};

/* reads a i_face_log_save_persons_with_photo_result object */
static gint32
i_face_log_save_persons_with_photo_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSavePersonsWithPhotoResult * this_object = I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_persons_with_photo_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSavePersonsWithPhotoResult * this_object = I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSavePersonsWithPhotoResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I32, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_persons_with_photo_result_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  IFaceLogSavePersonsWithPhotoResult *self = I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_RESULT_SUCCESS:
      self->success = g_value_get_int (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_persons_with_photo_result_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  IFaceLogSavePersonsWithPhotoResult *self = I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_RESULT_SUCCESS:
      g_value_set_int (value, self->success);
      break;

    case PROP_I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_persons_with_photo_result_instance_init (IFaceLogSavePersonsWithPhotoResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_save_persons_with_photo_result_finalize (GObject *object)
{
  IFaceLogSavePersonsWithPhotoResult *tobject = I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_save_persons_with_photo_result_class_init (IFaceLogSavePersonsWithPhotoResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_persons_with_photo_result_read;
  struct_class->write = i_face_log_save_persons_with_photo_result_write;

  gobject_class->finalize = i_face_log_save_persons_with_photo_result_finalize;
  gobject_class->get_property = i_face_log_save_persons_with_photo_result_get_property;
  gobject_class->set_property = i_face_log_save_persons_with_photo_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_RESULT_SUCCESS,
     g_param_spec_int ("success",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_persons_with_photo_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSavePersonsWithPhotoResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_persons_with_photo_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSavePersonsWithPhotoResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_persons_with_photo_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSavePersonsWithPhotoResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSaveServiceConfigArgsProperties
{
  PROP_I_FACE_LOG_SAVE_SERVICE_CONFIG_ARGS_0,
  PROP_I_FACE_LOG_SAVE_SERVICE_CONFIG_ARGS_TOKEN
};

/* reads a i_face_log_save_service_config_args object */
static gint32
i_face_log_save_service_config_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSaveServiceConfigArgs * this_object = I_FACE_LOG_SAVE_SERVICE_CONFIG_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_service_config_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSaveServiceConfigArgs * this_object = I_FACE_LOG_SAVE_SERVICE_CONFIG_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSaveServiceConfigArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_service_config_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogSaveServiceConfigArgs *self = I_FACE_LOG_SAVE_SERVICE_CONFIG_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_SERVICE_CONFIG_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_service_config_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogSaveServiceConfigArgs *self = I_FACE_LOG_SAVE_SERVICE_CONFIG_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_SERVICE_CONFIG_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_service_config_args_instance_init (IFaceLogSaveServiceConfigArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_save_service_config_args_finalize (GObject *object)
{
  IFaceLogSaveServiceConfigArgs *tobject = I_FACE_LOG_SAVE_SERVICE_CONFIG_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_save_service_config_args_class_init (IFaceLogSaveServiceConfigArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_service_config_args_read;
  struct_class->write = i_face_log_save_service_config_args_write;

  gobject_class->finalize = i_face_log_save_service_config_args_finalize;
  gobject_class->get_property = i_face_log_save_service_config_args_get_property;
  gobject_class->set_property = i_face_log_save_service_config_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_SERVICE_CONFIG_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_service_config_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSaveServiceConfigArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_service_config_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSaveServiceConfigArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_service_config_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSaveServiceConfigArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSaveServiceConfigResultProperties
{
  PROP_I_FACE_LOG_SAVE_SERVICE_CONFIG_RESULT_0,
  PROP_I_FACE_LOG_SAVE_SERVICE_CONFIG_RESULT_EX1
};

/* reads a i_face_log_save_service_config_result object */
static gint32
i_face_log_save_service_config_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSaveServiceConfigResult * this_object = I_FACE_LOG_SAVE_SERVICE_CONFIG_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_save_service_config_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSaveServiceConfigResult * this_object = I_FACE_LOG_SAVE_SERVICE_CONFIG_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSaveServiceConfigResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_save_service_config_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogSaveServiceConfigResult *self = I_FACE_LOG_SAVE_SERVICE_CONFIG_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_SERVICE_CONFIG_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_save_service_config_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  IFaceLogSaveServiceConfigResult *self = I_FACE_LOG_SAVE_SERVICE_CONFIG_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SAVE_SERVICE_CONFIG_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_save_service_config_result_instance_init (IFaceLogSaveServiceConfigResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_save_service_config_result_finalize (GObject *object)
{
  IFaceLogSaveServiceConfigResult *tobject = I_FACE_LOG_SAVE_SERVICE_CONFIG_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_save_service_config_result_class_init (IFaceLogSaveServiceConfigResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_save_service_config_result_read;
  struct_class->write = i_face_log_save_service_config_result_write;

  gobject_class->finalize = i_face_log_save_service_config_result_finalize;
  gobject_class->get_property = i_face_log_save_service_config_result_get_property;
  gobject_class->set_property = i_face_log_save_service_config_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SAVE_SERVICE_CONFIG_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_save_service_config_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSaveServiceConfigResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_save_service_config_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSaveServiceConfigResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_save_service_config_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSaveServiceConfigResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSdkTaskQueueOfArgsProperties
{
  PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_ARGS_0,
  PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_ARGS_TASK,
  PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_ARGS_SDK_VERSION,
  PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_ARGS_TOKEN
};

/* reads a i_face_log_sdk_task_queue_of_args object */
static gint32
i_face_log_sdk_task_queue_of_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSdkTaskQueueOfArgs * this_object = I_FACE_LOG_SDK_TASK_QUEUE_OF_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->task != NULL)
          {
            g_free(this_object->task);
            this_object->task = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->task, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_task = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->sdkVersion != NULL)
          {
            g_free(this_object->sdkVersion);
            this_object->sdkVersion = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sdkVersion, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sdkVersion = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_sdk_task_queue_of_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSdkTaskQueueOfArgs * this_object = I_FACE_LOG_SDK_TASK_QUEUE_OF_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSdkTaskQueueOfArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "task", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->task, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sdkVersion", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sdkVersion, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_sdk_task_queue_of_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogSdkTaskQueueOfArgs *self = I_FACE_LOG_SDK_TASK_QUEUE_OF_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_ARGS_TASK:
      if (self->task != NULL)
        g_free (self->task);
      self->task = g_value_dup_string (value);
      self->__isset_task = TRUE;
      break;

    case PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_ARGS_SDK_VERSION:
      if (self->sdkVersion != NULL)
        g_free (self->sdkVersion);
      self->sdkVersion = g_value_dup_string (value);
      self->__isset_sdkVersion = TRUE;
      break;

    case PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_sdk_task_queue_of_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogSdkTaskQueueOfArgs *self = I_FACE_LOG_SDK_TASK_QUEUE_OF_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_ARGS_TASK:
      g_value_set_string (value, self->task);
      break;

    case PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_ARGS_SDK_VERSION:
      g_value_set_string (value, self->sdkVersion);
      break;

    case PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_sdk_task_queue_of_args_instance_init (IFaceLogSdkTaskQueueOfArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->task = NULL;
  object->__isset_task = FALSE;
  object->sdkVersion = NULL;
  object->__isset_sdkVersion = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_sdk_task_queue_of_args_finalize (GObject *object)
{
  IFaceLogSdkTaskQueueOfArgs *tobject = I_FACE_LOG_SDK_TASK_QUEUE_OF_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->task != NULL)
  {
    g_free(tobject->task);
    tobject->task = NULL;
  }
  if (tobject->sdkVersion != NULL)
  {
    g_free(tobject->sdkVersion);
    tobject->sdkVersion = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_sdk_task_queue_of_args_class_init (IFaceLogSdkTaskQueueOfArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_sdk_task_queue_of_args_read;
  struct_class->write = i_face_log_sdk_task_queue_of_args_write;

  gobject_class->finalize = i_face_log_sdk_task_queue_of_args_finalize;
  gobject_class->get_property = i_face_log_sdk_task_queue_of_args_get_property;
  gobject_class->set_property = i_face_log_sdk_task_queue_of_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_ARGS_TASK,
     g_param_spec_string ("task",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_ARGS_SDK_VERSION,
     g_param_spec_string ("sdkVersion",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_sdk_task_queue_of_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSdkTaskQueueOfArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_sdk_task_queue_of_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSdkTaskQueueOfArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_sdk_task_queue_of_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSdkTaskQueueOfArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSdkTaskQueueOfResultProperties
{
  PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_RESULT_0,
  PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_RESULT_SUCCESS,
  PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_RESULT_EX1
};

/* reads a i_face_log_sdk_task_queue_of_result object */
static gint32
i_face_log_sdk_task_queue_of_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSdkTaskQueueOfResult * this_object = I_FACE_LOG_SDK_TASK_QUEUE_OF_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_sdk_task_queue_of_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSdkTaskQueueOfResult * this_object = I_FACE_LOG_SDK_TASK_QUEUE_OF_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSdkTaskQueueOfResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_sdk_task_queue_of_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogSdkTaskQueueOfResult *self = I_FACE_LOG_SDK_TASK_QUEUE_OF_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_RESULT_SUCCESS:
      if (self->success != NULL)
        g_free (self->success);
      self->success = g_value_dup_string (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_sdk_task_queue_of_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogSdkTaskQueueOfResult *self = I_FACE_LOG_SDK_TASK_QUEUE_OF_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_RESULT_SUCCESS:
      g_value_set_string (value, self->success);
      break;

    case PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_sdk_task_queue_of_result_instance_init (IFaceLogSdkTaskQueueOfResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_sdk_task_queue_of_result_finalize (GObject *object)
{
  IFaceLogSdkTaskQueueOfResult *tobject = I_FACE_LOG_SDK_TASK_QUEUE_OF_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_sdk_task_queue_of_result_class_init (IFaceLogSdkTaskQueueOfResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_sdk_task_queue_of_result_read;
  struct_class->write = i_face_log_sdk_task_queue_of_result_write;

  gobject_class->finalize = i_face_log_sdk_task_queue_of_result_finalize;
  gobject_class->get_property = i_face_log_sdk_task_queue_of_result_get_property;
  gobject_class->set_property = i_face_log_sdk_task_queue_of_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_RESULT_SUCCESS,
     g_param_spec_string ("success",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SDK_TASK_QUEUE_OF_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_sdk_task_queue_of_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSdkTaskQueueOfResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_sdk_task_queue_of_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSdkTaskQueueOfResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_sdk_task_queue_of_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSdkTaskQueueOfResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSetPersonExpiryDateArgsProperties
{
  PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_ARGS_0,
  PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_ARGS_PERSON_ID,
  PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_ARGS_EXPIRY_DATE,
  PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_ARGS_TOKEN
};

/* reads a i_face_log_set_person_expiry_date_args object */
static gint32
i_face_log_set_person_expiry_date_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSetPersonExpiryDateArgs * this_object = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_ARGS(object);
  gboolean isset_personId = FALSE;
  gboolean isset_expiryDate = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->expiryDate, error)) < 0)
            return -1;
          xfer += ret;
          isset_expiryDate = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  if (!isset_expiryDate)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_set_person_expiry_date_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSetPersonExpiryDateArgs * this_object = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSetPersonExpiryDateArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "expiryDate", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->expiryDate, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_set_person_expiry_date_args_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogSetPersonExpiryDateArgs *self = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_ARGS_PERSON_ID:
      self->personId = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_ARGS_EXPIRY_DATE:
      self->expiryDate = g_value_get_int64 (value);
      break;

    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_set_person_expiry_date_args_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  IFaceLogSetPersonExpiryDateArgs *self = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_ARGS_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_ARGS_EXPIRY_DATE:
      g_value_set_int64 (value, self->expiryDate);
      break;

    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_set_person_expiry_date_args_instance_init (IFaceLogSetPersonExpiryDateArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personId = 0;
  object->expiryDate = 0;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_set_person_expiry_date_args_finalize (GObject *object)
{
  IFaceLogSetPersonExpiryDateArgs *tobject = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_set_person_expiry_date_args_class_init (IFaceLogSetPersonExpiryDateArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_set_person_expiry_date_args_read;
  struct_class->write = i_face_log_set_person_expiry_date_args_write;

  gobject_class->finalize = i_face_log_set_person_expiry_date_args_finalize;
  gobject_class->get_property = i_face_log_set_person_expiry_date_args_get_property;
  gobject_class->set_property = i_face_log_set_person_expiry_date_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_ARGS_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_ARGS_EXPIRY_DATE,
     g_param_spec_int64 ("expiryDate",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_set_person_expiry_date_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSetPersonExpiryDateArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_set_person_expiry_date_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSetPersonExpiryDateArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_set_person_expiry_date_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSetPersonExpiryDateArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSetPersonExpiryDateResultProperties
{
  PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_RESULT_0,
  PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_RESULT_EX1
};

/* reads a i_face_log_set_person_expiry_date_result object */
static gint32
i_face_log_set_person_expiry_date_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSetPersonExpiryDateResult * this_object = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_set_person_expiry_date_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSetPersonExpiryDateResult * this_object = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSetPersonExpiryDateResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_set_person_expiry_date_result_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  IFaceLogSetPersonExpiryDateResult *self = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_set_person_expiry_date_result_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  IFaceLogSetPersonExpiryDateResult *self = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_set_person_expiry_date_result_instance_init (IFaceLogSetPersonExpiryDateResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_set_person_expiry_date_result_finalize (GObject *object)
{
  IFaceLogSetPersonExpiryDateResult *tobject = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_set_person_expiry_date_result_class_init (IFaceLogSetPersonExpiryDateResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_set_person_expiry_date_result_read;
  struct_class->write = i_face_log_set_person_expiry_date_result_write;

  gobject_class->finalize = i_face_log_set_person_expiry_date_result_finalize;
  gobject_class->get_property = i_face_log_set_person_expiry_date_result_get_property;
  gobject_class->set_property = i_face_log_set_person_expiry_date_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_set_person_expiry_date_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSetPersonExpiryDateResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_set_person_expiry_date_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSetPersonExpiryDateResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_set_person_expiry_date_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSetPersonExpiryDateResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSetPersonExpiryDateListArgsProperties
{
  PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_ARGS_0,
  PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_ARGS_PERSON_ID_LIST,
  PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_ARGS_EXPIRY_DATE,
  PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_ARGS_TOKEN
};

/* reads a i_face_log_set_person_expiry_date_list_args object */
static gint32
i_face_log_set_person_expiry_date_list_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSetPersonExpiryDateListArgs * this_object = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_ARGS(object);
  gboolean isset_expiryDate = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint32* _elem161 = g_new (gint32, 1);
              if ((ret = thrift_protocol_read_i32 (protocol, &*_elem161, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->personIdList, _elem161, 1);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_personIdList = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->expiryDate, error)) < 0)
            return -1;
          xfer += ret;
          isset_expiryDate = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_expiryDate)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_set_person_expiry_date_list_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSetPersonExpiryDateListArgs * this_object = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSetPersonExpiryDateListArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personIdList", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i162;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (this_object->personIdList ? this_object->personIdList->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i162 = 0; i162 < (this_object->personIdList ? this_object->personIdList->len : 0); i162++)
    {
      if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (this_object->personIdList, gint32, i162)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "expiryDate", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->expiryDate, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_set_person_expiry_date_list_args_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  IFaceLogSetPersonExpiryDateListArgs *self = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_ARGS_PERSON_ID_LIST:
      if (self->personIdList != NULL)
        g_array_unref (self->personIdList);
      self->personIdList = g_value_dup_boxed (value);
      self->__isset_personIdList = TRUE;
      break;

    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_ARGS_EXPIRY_DATE:
      self->expiryDate = g_value_get_int64 (value);
      break;

    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_set_person_expiry_date_list_args_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  IFaceLogSetPersonExpiryDateListArgs *self = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_ARGS_PERSON_ID_LIST:
      g_value_set_boxed (value, self->personIdList);
      break;

    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_ARGS_EXPIRY_DATE:
      g_value_set_int64 (value, self->expiryDate);
      break;

    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_set_person_expiry_date_list_args_instance_init (IFaceLogSetPersonExpiryDateListArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personIdList = g_array_new (0, 1, sizeof (gint32));
  object->__isset_personIdList = FALSE;
  object->expiryDate = 0;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_set_person_expiry_date_list_args_finalize (GObject *object)
{
  IFaceLogSetPersonExpiryDateListArgs *tobject = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->personIdList != NULL)
  {
    g_array_unref (tobject->personIdList);
    tobject->personIdList = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_set_person_expiry_date_list_args_class_init (IFaceLogSetPersonExpiryDateListArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_set_person_expiry_date_list_args_read;
  struct_class->write = i_face_log_set_person_expiry_date_list_args_write;

  gobject_class->finalize = i_face_log_set_person_expiry_date_list_args_finalize;
  gobject_class->get_property = i_face_log_set_person_expiry_date_list_args_get_property;
  gobject_class->set_property = i_face_log_set_person_expiry_date_list_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_ARGS_PERSON_ID_LIST,
     g_param_spec_boxed ("personIdList",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_ARGS_EXPIRY_DATE,
     g_param_spec_int64 ("expiryDate",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_set_person_expiry_date_list_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSetPersonExpiryDateListArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_set_person_expiry_date_list_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSetPersonExpiryDateListArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_set_person_expiry_date_list_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSetPersonExpiryDateListArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSetPersonExpiryDateListResultProperties
{
  PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_RESULT_0,
  PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_RESULT_EX1
};

/* reads a i_face_log_set_person_expiry_date_list_result object */
static gint32
i_face_log_set_person_expiry_date_list_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSetPersonExpiryDateListResult * this_object = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_set_person_expiry_date_list_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSetPersonExpiryDateListResult * this_object = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSetPersonExpiryDateListResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_set_person_expiry_date_list_result_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogSetPersonExpiryDateListResult *self = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_set_person_expiry_date_list_result_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  IFaceLogSetPersonExpiryDateListResult *self = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_set_person_expiry_date_list_result_instance_init (IFaceLogSetPersonExpiryDateListResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_set_person_expiry_date_list_result_finalize (GObject *object)
{
  IFaceLogSetPersonExpiryDateListResult *tobject = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_set_person_expiry_date_list_result_class_init (IFaceLogSetPersonExpiryDateListResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_set_person_expiry_date_list_result_read;
  struct_class->write = i_face_log_set_person_expiry_date_list_result_write;

  gobject_class->finalize = i_face_log_set_person_expiry_date_list_result_finalize;
  gobject_class->get_property = i_face_log_set_person_expiry_date_list_result_get_property;
  gobject_class->set_property = i_face_log_set_person_expiry_date_list_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_set_person_expiry_date_list_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSetPersonExpiryDateListResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_set_person_expiry_date_list_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSetPersonExpiryDateListResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_set_person_expiry_date_list_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSetPersonExpiryDateListResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSetPersonExpiryDateTimeStrArgsProperties
{
  PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_ARGS_0,
  PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_ARGS_PERSON_ID,
  PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_ARGS_EXPIRY_DATE,
  PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_ARGS_TOKEN
};

/* reads a i_face_log_set_person_expiry_date_time_str_args object */
static gint32
i_face_log_set_person_expiry_date_time_str_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSetPersonExpiryDateTimeStrArgs * this_object = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_ARGS(object);
  gboolean isset_personId = FALSE;

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personId, error)) < 0)
            return -1;
          xfer += ret;
          isset_personId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->expiryDate != NULL)
          {
            g_free(this_object->expiryDate);
            this_object->expiryDate = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->expiryDate, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_expiryDate = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  if (!isset_personId)
  {
    g_set_error (error, THRIFT_PROTOCOL_ERROR,
                 THRIFT_PROTOCOL_ERROR_INVALID_DATA,
                 "missing field");
    return -1;
  }

  return xfer;
}

static gint32
i_face_log_set_person_expiry_date_time_str_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSetPersonExpiryDateTimeStrArgs * this_object = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSetPersonExpiryDateTimeStrArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "expiryDate", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->expiryDate, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_set_person_expiry_date_time_str_args_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  IFaceLogSetPersonExpiryDateTimeStrArgs *self = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_ARGS_PERSON_ID:
      self->personId = g_value_get_int (value);
      break;

    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_ARGS_EXPIRY_DATE:
      if (self->expiryDate != NULL)
        g_free (self->expiryDate);
      self->expiryDate = g_value_dup_string (value);
      self->__isset_expiryDate = TRUE;
      break;

    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_set_person_expiry_date_time_str_args_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  IFaceLogSetPersonExpiryDateTimeStrArgs *self = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_ARGS_PERSON_ID:
      g_value_set_int (value, self->personId);
      break;

    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_ARGS_EXPIRY_DATE:
      g_value_set_string (value, self->expiryDate);
      break;

    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_set_person_expiry_date_time_str_args_instance_init (IFaceLogSetPersonExpiryDateTimeStrArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personId = 0;
  object->expiryDate = NULL;
  object->__isset_expiryDate = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_set_person_expiry_date_time_str_args_finalize (GObject *object)
{
  IFaceLogSetPersonExpiryDateTimeStrArgs *tobject = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->expiryDate != NULL)
  {
    g_free(tobject->expiryDate);
    tobject->expiryDate = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_set_person_expiry_date_time_str_args_class_init (IFaceLogSetPersonExpiryDateTimeStrArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_set_person_expiry_date_time_str_args_read;
  struct_class->write = i_face_log_set_person_expiry_date_time_str_args_write;

  gobject_class->finalize = i_face_log_set_person_expiry_date_time_str_args_finalize;
  gobject_class->get_property = i_face_log_set_person_expiry_date_time_str_args_get_property;
  gobject_class->set_property = i_face_log_set_person_expiry_date_time_str_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_ARGS_PERSON_ID,
     g_param_spec_int ("personId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_ARGS_EXPIRY_DATE,
     g_param_spec_string ("expiryDate",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_set_person_expiry_date_time_str_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSetPersonExpiryDateTimeStrArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_set_person_expiry_date_time_str_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSetPersonExpiryDateTimeStrArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_set_person_expiry_date_time_str_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSetPersonExpiryDateTimeStrArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSetPersonExpiryDateTimeStrResultProperties
{
  PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_RESULT_0,
  PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_RESULT_EX1
};

/* reads a i_face_log_set_person_expiry_date_time_str_result object */
static gint32
i_face_log_set_person_expiry_date_time_str_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSetPersonExpiryDateTimeStrResult * this_object = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_set_person_expiry_date_time_str_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSetPersonExpiryDateTimeStrResult * this_object = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSetPersonExpiryDateTimeStrResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_set_person_expiry_date_time_str_result_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  IFaceLogSetPersonExpiryDateTimeStrResult *self = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_set_person_expiry_date_time_str_result_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  IFaceLogSetPersonExpiryDateTimeStrResult *self = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_set_person_expiry_date_time_str_result_instance_init (IFaceLogSetPersonExpiryDateTimeStrResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_set_person_expiry_date_time_str_result_finalize (GObject *object)
{
  IFaceLogSetPersonExpiryDateTimeStrResult *tobject = I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_set_person_expiry_date_time_str_result_class_init (IFaceLogSetPersonExpiryDateTimeStrResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_set_person_expiry_date_time_str_result_read;
  struct_class->write = i_face_log_set_person_expiry_date_time_str_result_write;

  gobject_class->finalize = i_face_log_set_person_expiry_date_time_str_result_finalize;
  gobject_class->get_property = i_face_log_set_person_expiry_date_time_str_result_get_property;
  gobject_class->set_property = i_face_log_set_person_expiry_date_time_str_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_set_person_expiry_date_time_str_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSetPersonExpiryDateTimeStrResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_set_person_expiry_date_time_str_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSetPersonExpiryDateTimeStrResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_set_person_expiry_date_time_str_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSetPersonExpiryDateTimeStrResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSetPropertiesArgsProperties
{
  PROP_I_FACE_LOG_SET_PROPERTIES_ARGS_0,
  PROP_I_FACE_LOG_SET_PROPERTIES_ARGS_CONFIG,
  PROP_I_FACE_LOG_SET_PROPERTIES_ARGS_TOKEN
};

/* reads a i_face_log_set_properties_args object */
static gint32
i_face_log_set_properties_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSetPropertiesArgs * this_object = I_FACE_LOG_SET_PROPERTIES_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key163 = NULL;
              gchar * val164 = NULL;
              if (key163 != NULL)
              {
                g_free(key163);
                key163 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key163, error)) < 0)
                return -1;
              xfer += ret;
              if (val164 != NULL)
              {
                g_free(val164);
                val164 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val164, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->config && key163)
                g_hash_table_insert ((GHashTable *)this_object->config, (gpointer) key163, (gpointer) val164);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_config = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_set_properties_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSetPropertiesArgs * this_object = I_FACE_LOG_SET_PROPERTIES_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSetPropertiesArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "config", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    gchar * key165 = NULL;
    gchar * val166 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gchar ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->config ? (gint32) g_hash_table_size ((GHashTable *) this_object->config) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->config)
      g_hash_table_foreach ((GHashTable *) this_object->config, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gchar *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gchar *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key165 = keys[i];
      val166 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->config), (gpointer) key165);

      if ((ret = thrift_protocol_write_string (protocol,  key165, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_string (protocol,  val166, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_set_properties_args_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogSetPropertiesArgs *self = I_FACE_LOG_SET_PROPERTIES_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SET_PROPERTIES_ARGS_CONFIG:
      if (self->config != NULL)
        g_hash_table_unref (self->config);
      self->config = g_value_dup_boxed (value);
      self->__isset_config = TRUE;
      break;

    case PROP_I_FACE_LOG_SET_PROPERTIES_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_set_properties_args_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogSetPropertiesArgs *self = I_FACE_LOG_SET_PROPERTIES_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SET_PROPERTIES_ARGS_CONFIG:
      g_value_set_boxed (value, self->config);
      break;

    case PROP_I_FACE_LOG_SET_PROPERTIES_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_set_properties_args_instance_init (IFaceLogSetPropertiesArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->config = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_config = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_set_properties_args_finalize (GObject *object)
{
  IFaceLogSetPropertiesArgs *tobject = I_FACE_LOG_SET_PROPERTIES_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->config != NULL)
  {
    g_hash_table_destroy (tobject->config);
    tobject->config = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_set_properties_args_class_init (IFaceLogSetPropertiesArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_set_properties_args_read;
  struct_class->write = i_face_log_set_properties_args_write;

  gobject_class->finalize = i_face_log_set_properties_args_finalize;
  gobject_class->get_property = i_face_log_set_properties_args_get_property;
  gobject_class->set_property = i_face_log_set_properties_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SET_PROPERTIES_ARGS_CONFIG,
     g_param_spec_boxed ("config",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SET_PROPERTIES_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_set_properties_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSetPropertiesArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_set_properties_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSetPropertiesArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_set_properties_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSetPropertiesArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSetPropertiesResultProperties
{
  PROP_I_FACE_LOG_SET_PROPERTIES_RESULT_0,
  PROP_I_FACE_LOG_SET_PROPERTIES_RESULT_EX1
};

/* reads a i_face_log_set_properties_result object */
static gint32
i_face_log_set_properties_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSetPropertiesResult * this_object = I_FACE_LOG_SET_PROPERTIES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_set_properties_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSetPropertiesResult * this_object = I_FACE_LOG_SET_PROPERTIES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSetPropertiesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_set_properties_result_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogSetPropertiesResult *self = I_FACE_LOG_SET_PROPERTIES_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SET_PROPERTIES_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_set_properties_result_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  IFaceLogSetPropertiesResult *self = I_FACE_LOG_SET_PROPERTIES_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SET_PROPERTIES_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_set_properties_result_instance_init (IFaceLogSetPropertiesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_set_properties_result_finalize (GObject *object)
{
  IFaceLogSetPropertiesResult *tobject = I_FACE_LOG_SET_PROPERTIES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_set_properties_result_class_init (IFaceLogSetPropertiesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_set_properties_result_read;
  struct_class->write = i_face_log_set_properties_result_write;

  gobject_class->finalize = i_face_log_set_properties_result_finalize;
  gobject_class->get_property = i_face_log_set_properties_result_get_property;
  gobject_class->set_property = i_face_log_set_properties_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SET_PROPERTIES_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_set_properties_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSetPropertiesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_set_properties_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSetPropertiesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_set_properties_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSetPropertiesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSetPropertyArgsProperties
{
  PROP_I_FACE_LOG_SET_PROPERTY_ARGS_0,
  PROP_I_FACE_LOG_SET_PROPERTY_ARGS_KEY,
  PROP_I_FACE_LOG_SET_PROPERTY_ARGS_VALUE,
  PROP_I_FACE_LOG_SET_PROPERTY_ARGS_TOKEN
};

/* reads a i_face_log_set_property_args object */
static gint32
i_face_log_set_property_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSetPropertyArgs * this_object = I_FACE_LOG_SET_PROPERTY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->key != NULL)
          {
            g_free(this_object->key);
            this_object->key = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->key, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->value != NULL)
          {
            g_free(this_object->value);
            this_object->value = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->value, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_set_property_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSetPropertyArgs * this_object = I_FACE_LOG_SET_PROPERTY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSetPropertyArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->key, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->value, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_set_property_args_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogSetPropertyArgs *self = I_FACE_LOG_SET_PROPERTY_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SET_PROPERTY_ARGS_KEY:
      if (self->key != NULL)
        g_free (self->key);
      self->key = g_value_dup_string (value);
      self->__isset_key = TRUE;
      break;

    case PROP_I_FACE_LOG_SET_PROPERTY_ARGS_VALUE:
      if (self->value != NULL)
        g_free (self->value);
      self->value = g_value_dup_string (value);
      self->__isset_value = TRUE;
      break;

    case PROP_I_FACE_LOG_SET_PROPERTY_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_set_property_args_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  IFaceLogSetPropertyArgs *self = I_FACE_LOG_SET_PROPERTY_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SET_PROPERTY_ARGS_KEY:
      g_value_set_string (value, self->key);
      break;

    case PROP_I_FACE_LOG_SET_PROPERTY_ARGS_VALUE:
      g_value_set_string (value, self->value);
      break;

    case PROP_I_FACE_LOG_SET_PROPERTY_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_set_property_args_instance_init (IFaceLogSetPropertyArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->key = NULL;
  object->__isset_key = FALSE;
  object->value = NULL;
  object->__isset_value = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_set_property_args_finalize (GObject *object)
{
  IFaceLogSetPropertyArgs *tobject = I_FACE_LOG_SET_PROPERTY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->key != NULL)
  {
    g_free(tobject->key);
    tobject->key = NULL;
  }
  if (tobject->value != NULL)
  {
    g_free(tobject->value);
    tobject->value = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_set_property_args_class_init (IFaceLogSetPropertyArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_set_property_args_read;
  struct_class->write = i_face_log_set_property_args_write;

  gobject_class->finalize = i_face_log_set_property_args_finalize;
  gobject_class->get_property = i_face_log_set_property_args_get_property;
  gobject_class->set_property = i_face_log_set_property_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SET_PROPERTY_ARGS_KEY,
     g_param_spec_string ("key",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SET_PROPERTY_ARGS_VALUE,
     g_param_spec_string ("value",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SET_PROPERTY_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_set_property_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSetPropertyArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_set_property_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSetPropertyArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_set_property_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSetPropertyArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogSetPropertyResultProperties
{
  PROP_I_FACE_LOG_SET_PROPERTY_RESULT_0,
  PROP_I_FACE_LOG_SET_PROPERTY_RESULT_EX1
};

/* reads a i_face_log_set_property_result object */
static gint32
i_face_log_set_property_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogSetPropertyResult * this_object = I_FACE_LOG_SET_PROPERTY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_set_property_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogSetPropertyResult * this_object = I_FACE_LOG_SET_PROPERTY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogSetPropertyResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_set_property_result_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogSetPropertyResult *self = I_FACE_LOG_SET_PROPERTY_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SET_PROPERTY_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_set_property_result_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogSetPropertyResult *self = I_FACE_LOG_SET_PROPERTY_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_SET_PROPERTY_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_set_property_result_instance_init (IFaceLogSetPropertyResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_set_property_result_finalize (GObject *object)
{
  IFaceLogSetPropertyResult *tobject = I_FACE_LOG_SET_PROPERTY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_set_property_result_class_init (IFaceLogSetPropertyResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_set_property_result_read;
  struct_class->write = i_face_log_set_property_result_write;

  gobject_class->finalize = i_face_log_set_property_result_finalize;
  gobject_class->get_property = i_face_log_set_property_result_get_property;
  gobject_class->set_property = i_face_log_set_property_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_SET_PROPERTY_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_set_property_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogSetPropertyResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_set_property_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogSetPropertyResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_set_property_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogSetPropertyResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogTaskQueueOfArgsProperties
{
  PROP_I_FACE_LOG_TASK_QUEUE_OF_ARGS_0,
  PROP_I_FACE_LOG_TASK_QUEUE_OF_ARGS_TASK,
  PROP_I_FACE_LOG_TASK_QUEUE_OF_ARGS_TOKEN
};

/* reads a i_face_log_task_queue_of_args object */
static gint32
i_face_log_task_queue_of_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogTaskQueueOfArgs * this_object = I_FACE_LOG_TASK_QUEUE_OF_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->task != NULL)
          {
            g_free(this_object->task);
            this_object->task = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->task, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_task = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_task_queue_of_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogTaskQueueOfArgs * this_object = I_FACE_LOG_TASK_QUEUE_OF_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogTaskQueueOfArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "task", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->task, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_task_queue_of_args_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogTaskQueueOfArgs *self = I_FACE_LOG_TASK_QUEUE_OF_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_TASK_QUEUE_OF_ARGS_TASK:
      if (self->task != NULL)
        g_free (self->task);
      self->task = g_value_dup_string (value);
      self->__isset_task = TRUE;
      break;

    case PROP_I_FACE_LOG_TASK_QUEUE_OF_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_task_queue_of_args_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogTaskQueueOfArgs *self = I_FACE_LOG_TASK_QUEUE_OF_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_TASK_QUEUE_OF_ARGS_TASK:
      g_value_set_string (value, self->task);
      break;

    case PROP_I_FACE_LOG_TASK_QUEUE_OF_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_task_queue_of_args_instance_init (IFaceLogTaskQueueOfArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->task = NULL;
  object->__isset_task = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_task_queue_of_args_finalize (GObject *object)
{
  IFaceLogTaskQueueOfArgs *tobject = I_FACE_LOG_TASK_QUEUE_OF_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->task != NULL)
  {
    g_free(tobject->task);
    tobject->task = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_task_queue_of_args_class_init (IFaceLogTaskQueueOfArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_task_queue_of_args_read;
  struct_class->write = i_face_log_task_queue_of_args_write;

  gobject_class->finalize = i_face_log_task_queue_of_args_finalize;
  gobject_class->get_property = i_face_log_task_queue_of_args_get_property;
  gobject_class->set_property = i_face_log_task_queue_of_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_TASK_QUEUE_OF_ARGS_TASK,
     g_param_spec_string ("task",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_TASK_QUEUE_OF_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_task_queue_of_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogTaskQueueOfArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_task_queue_of_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogTaskQueueOfArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_task_queue_of_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogTaskQueueOfArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogTaskQueueOfResultProperties
{
  PROP_I_FACE_LOG_TASK_QUEUE_OF_RESULT_0,
  PROP_I_FACE_LOG_TASK_QUEUE_OF_RESULT_SUCCESS,
  PROP_I_FACE_LOG_TASK_QUEUE_OF_RESULT_EX1
};

/* reads a i_face_log_task_queue_of_result object */
static gint32
i_face_log_task_queue_of_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogTaskQueueOfResult * this_object = I_FACE_LOG_TASK_QUEUE_OF_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_task_queue_of_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogTaskQueueOfResult * this_object = I_FACE_LOG_TASK_QUEUE_OF_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogTaskQueueOfResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_task_queue_of_result_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogTaskQueueOfResult *self = I_FACE_LOG_TASK_QUEUE_OF_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_TASK_QUEUE_OF_RESULT_SUCCESS:
      if (self->success != NULL)
        g_free (self->success);
      self->success = g_value_dup_string (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_TASK_QUEUE_OF_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_task_queue_of_result_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogTaskQueueOfResult *self = I_FACE_LOG_TASK_QUEUE_OF_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_TASK_QUEUE_OF_RESULT_SUCCESS:
      g_value_set_string (value, self->success);
      break;

    case PROP_I_FACE_LOG_TASK_QUEUE_OF_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_task_queue_of_result_instance_init (IFaceLogTaskQueueOfResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_task_queue_of_result_finalize (GObject *object)
{
  IFaceLogTaskQueueOfResult *tobject = I_FACE_LOG_TASK_QUEUE_OF_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_task_queue_of_result_class_init (IFaceLogTaskQueueOfResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_task_queue_of_result_read;
  struct_class->write = i_face_log_task_queue_of_result_write;

  gobject_class->finalize = i_face_log_task_queue_of_result_finalize;
  gobject_class->get_property = i_face_log_task_queue_of_result_get_property;
  gobject_class->set_property = i_face_log_task_queue_of_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_TASK_QUEUE_OF_RESULT_SUCCESS,
     g_param_spec_string ("success",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_TASK_QUEUE_OF_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_task_queue_of_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogTaskQueueOfResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_task_queue_of_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogTaskQueueOfResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_task_queue_of_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogTaskQueueOfResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogUnbindBorderArgsProperties
{
  PROP_I_FACE_LOG_UNBIND_BORDER_ARGS_0,
  PROP_I_FACE_LOG_UNBIND_BORDER_ARGS_PERSON_GROUP_ID,
  PROP_I_FACE_LOG_UNBIND_BORDER_ARGS_DEVICE_GROUP_ID,
  PROP_I_FACE_LOG_UNBIND_BORDER_ARGS_TOKEN
};

/* reads a i_face_log_unbind_border_args object */
static gint32
i_face_log_unbind_border_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogUnbindBorderArgs * this_object = I_FACE_LOG_UNBIND_BORDER_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->personGroupId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_personGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->deviceGroupId, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_deviceGroupId = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_unbind_border_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogUnbindBorderArgs * this_object = I_FACE_LOG_UNBIND_BORDER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogUnbindBorderArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->personGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->deviceGroupId, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_unbind_border_args_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogUnbindBorderArgs *self = I_FACE_LOG_UNBIND_BORDER_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_UNBIND_BORDER_ARGS_PERSON_GROUP_ID:
      self->personGroupId = g_value_get_int (value);
      self->__isset_personGroupId = TRUE;
      break;

    case PROP_I_FACE_LOG_UNBIND_BORDER_ARGS_DEVICE_GROUP_ID:
      self->deviceGroupId = g_value_get_int (value);
      self->__isset_deviceGroupId = TRUE;
      break;

    case PROP_I_FACE_LOG_UNBIND_BORDER_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_unbind_border_args_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogUnbindBorderArgs *self = I_FACE_LOG_UNBIND_BORDER_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_UNBIND_BORDER_ARGS_PERSON_GROUP_ID:
      g_value_set_int (value, self->personGroupId);
      break;

    case PROP_I_FACE_LOG_UNBIND_BORDER_ARGS_DEVICE_GROUP_ID:
      g_value_set_int (value, self->deviceGroupId);
      break;

    case PROP_I_FACE_LOG_UNBIND_BORDER_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_unbind_border_args_instance_init (IFaceLogUnbindBorderArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->personGroupId = 0;
  object->__isset_personGroupId = FALSE;
  object->deviceGroupId = 0;
  object->__isset_deviceGroupId = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_unbind_border_args_finalize (GObject *object)
{
  IFaceLogUnbindBorderArgs *tobject = I_FACE_LOG_UNBIND_BORDER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_unbind_border_args_class_init (IFaceLogUnbindBorderArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_unbind_border_args_read;
  struct_class->write = i_face_log_unbind_border_args_write;

  gobject_class->finalize = i_face_log_unbind_border_args_finalize;
  gobject_class->get_property = i_face_log_unbind_border_args_get_property;
  gobject_class->set_property = i_face_log_unbind_border_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_UNBIND_BORDER_ARGS_PERSON_GROUP_ID,
     g_param_spec_int ("personGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_UNBIND_BORDER_ARGS_DEVICE_GROUP_ID,
     g_param_spec_int ("deviceGroupId",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_UNBIND_BORDER_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_unbind_border_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogUnbindBorderArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_unbind_border_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogUnbindBorderArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_unbind_border_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogUnbindBorderArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogUnbindBorderResultProperties
{
  PROP_I_FACE_LOG_UNBIND_BORDER_RESULT_0,
  PROP_I_FACE_LOG_UNBIND_BORDER_RESULT_EX1
};

/* reads a i_face_log_unbind_border_result object */
static gint32
i_face_log_unbind_border_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogUnbindBorderResult * this_object = I_FACE_LOG_UNBIND_BORDER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_unbind_border_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogUnbindBorderResult * this_object = I_FACE_LOG_UNBIND_BORDER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogUnbindBorderResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_unbind_border_result_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogUnbindBorderResult *self = I_FACE_LOG_UNBIND_BORDER_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_UNBIND_BORDER_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_unbind_border_result_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogUnbindBorderResult *self = I_FACE_LOG_UNBIND_BORDER_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_UNBIND_BORDER_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_unbind_border_result_instance_init (IFaceLogUnbindBorderResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_unbind_border_result_finalize (GObject *object)
{
  IFaceLogUnbindBorderResult *tobject = I_FACE_LOG_UNBIND_BORDER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_unbind_border_result_class_init (IFaceLogUnbindBorderResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_unbind_border_result_read;
  struct_class->write = i_face_log_unbind_border_result_write;

  gobject_class->finalize = i_face_log_unbind_border_result_finalize;
  gobject_class->get_property = i_face_log_unbind_border_result_get_property;
  gobject_class->set_property = i_face_log_unbind_border_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_UNBIND_BORDER_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_unbind_border_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogUnbindBorderResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_unbind_border_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogUnbindBorderResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_unbind_border_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogUnbindBorderResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogUnregisterDeviceArgsProperties
{
  PROP_I_FACE_LOG_UNREGISTER_DEVICE_ARGS_0,
  PROP_I_FACE_LOG_UNREGISTER_DEVICE_ARGS_TOKEN
};

/* reads a i_face_log_unregister_device_args object */
static gint32
i_face_log_unregister_device_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogUnregisterDeviceArgs * this_object = I_FACE_LOG_UNREGISTER_DEVICE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_unregister_device_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogUnregisterDeviceArgs * this_object = I_FACE_LOG_UNREGISTER_DEVICE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogUnregisterDeviceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_unregister_device_args_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogUnregisterDeviceArgs *self = I_FACE_LOG_UNREGISTER_DEVICE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_UNREGISTER_DEVICE_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_unregister_device_args_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  IFaceLogUnregisterDeviceArgs *self = I_FACE_LOG_UNREGISTER_DEVICE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_UNREGISTER_DEVICE_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_unregister_device_args_instance_init (IFaceLogUnregisterDeviceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_unregister_device_args_finalize (GObject *object)
{
  IFaceLogUnregisterDeviceArgs *tobject = I_FACE_LOG_UNREGISTER_DEVICE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_unregister_device_args_class_init (IFaceLogUnregisterDeviceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_unregister_device_args_read;
  struct_class->write = i_face_log_unregister_device_args_write;

  gobject_class->finalize = i_face_log_unregister_device_args_finalize;
  gobject_class->get_property = i_face_log_unregister_device_args_get_property;
  gobject_class->set_property = i_face_log_unregister_device_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_UNREGISTER_DEVICE_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_unregister_device_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogUnregisterDeviceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_unregister_device_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogUnregisterDeviceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_unregister_device_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogUnregisterDeviceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogUnregisterDeviceResultProperties
{
  PROP_I_FACE_LOG_UNREGISTER_DEVICE_RESULT_0,
  PROP_I_FACE_LOG_UNREGISTER_DEVICE_RESULT_EX1,
  PROP_I_FACE_LOG_UNREGISTER_DEVICE_RESULT_EX2
};

/* reads a i_face_log_unregister_device_result object */
static gint32
i_face_log_unregister_device_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogUnregisterDeviceResult * this_object = I_FACE_LOG_UNREGISTER_DEVICE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_SECURITY_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex2 != NULL)
          {
            g_object_unref (this_object->ex2);
          }
          this_object->ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex2);
            this_object->ex2 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex2 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_unregister_device_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogUnregisterDeviceResult * this_object = I_FACE_LOG_UNREGISTER_DEVICE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogUnregisterDeviceResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex2 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex2", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex2), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_unregister_device_result_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogUnregisterDeviceResult *self = I_FACE_LOG_UNREGISTER_DEVICE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_UNREGISTER_DEVICE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    case PROP_I_FACE_LOG_UNREGISTER_DEVICE_RESULT_EX2:
      if (self->ex2 != NULL)
        g_object_unref (self->ex2);
      self->ex2 = g_value_dup_object (value);
      self->__isset_ex2 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_unregister_device_result_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  IFaceLogUnregisterDeviceResult *self = I_FACE_LOG_UNREGISTER_DEVICE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_UNREGISTER_DEVICE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    case PROP_I_FACE_LOG_UNREGISTER_DEVICE_RESULT_EX2:
      g_value_set_object (value, self->ex2);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_unregister_device_result_instance_init (IFaceLogUnregisterDeviceResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
  object->ex2 = NULL;
  object->__isset_ex2 = FALSE;
}

static void 
i_face_log_unregister_device_result_finalize (GObject *object)
{
  IFaceLogUnregisterDeviceResult *tobject = I_FACE_LOG_UNREGISTER_DEVICE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
  if (tobject->ex2 != NULL)
  {
    g_object_unref(tobject->ex2);
    tobject->ex2 = NULL;
  }
}

static void
i_face_log_unregister_device_result_class_init (IFaceLogUnregisterDeviceResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_unregister_device_result_read;
  struct_class->write = i_face_log_unregister_device_result_write;

  gobject_class->finalize = i_face_log_unregister_device_result_finalize;
  gobject_class->get_property = i_face_log_unregister_device_result_get_property;
  gobject_class->set_property = i_face_log_unregister_device_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_UNREGISTER_DEVICE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_SECURITY_EXCEPTION,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_UNREGISTER_DEVICE_RESULT_EX2,
     g_param_spec_object ("ex2",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_unregister_device_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogUnregisterDeviceResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_unregister_device_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogUnregisterDeviceResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_unregister_device_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogUnregisterDeviceResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogUpdateDeviceArgsProperties
{
  PROP_I_FACE_LOG_UPDATE_DEVICE_ARGS_0,
  PROP_I_FACE_LOG_UPDATE_DEVICE_ARGS_DEVICE_BEAN,
  PROP_I_FACE_LOG_UPDATE_DEVICE_ARGS_TOKEN
};

/* reads a i_face_log_update_device_args object */
static gint32
i_face_log_update_device_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogUpdateDeviceArgs * this_object = I_FACE_LOG_UPDATE_DEVICE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->deviceBean), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_deviceBean = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_token = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_update_device_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogUpdateDeviceArgs * this_object = I_FACE_LOG_UPDATE_DEVICE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogUpdateDeviceArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "deviceBean", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->deviceBean), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->token), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_update_device_args_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogUpdateDeviceArgs *self = I_FACE_LOG_UPDATE_DEVICE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_UPDATE_DEVICE_ARGS_DEVICE_BEAN:
      if (self->deviceBean != NULL)
        g_object_unref (self->deviceBean);
      self->deviceBean = g_value_dup_object (value);
      self->__isset_deviceBean = TRUE;
      break;

    case PROP_I_FACE_LOG_UPDATE_DEVICE_ARGS_TOKEN:
      if (self->token != NULL)
        g_object_unref (self->token);
      self->token = g_value_dup_object (value);
      self->__isset_token = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_update_device_args_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  IFaceLogUpdateDeviceArgs *self = I_FACE_LOG_UPDATE_DEVICE_ARGS (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_UPDATE_DEVICE_ARGS_DEVICE_BEAN:
      g_value_set_object (value, self->deviceBean);
      break;

    case PROP_I_FACE_LOG_UPDATE_DEVICE_ARGS_TOKEN:
      g_value_set_object (value, self->token);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_update_device_args_instance_init (IFaceLogUpdateDeviceArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->deviceBean = g_object_new (TYPE_DEVICE_BEAN, NULL);
  object->__isset_deviceBean = FALSE;
  object->token = g_object_new (TYPE_TOKEN, NULL);
  object->__isset_token = FALSE;
}

static void 
i_face_log_update_device_args_finalize (GObject *object)
{
  IFaceLogUpdateDeviceArgs *tobject = I_FACE_LOG_UPDATE_DEVICE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->deviceBean != NULL)
  {
    g_object_unref(tobject->deviceBean);
    tobject->deviceBean = NULL;
  }
  if (tobject->token != NULL)
  {
    g_object_unref(tobject->token);
    tobject->token = NULL;
  }
}

static void
i_face_log_update_device_args_class_init (IFaceLogUpdateDeviceArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_update_device_args_read;
  struct_class->write = i_face_log_update_device_args_write;

  gobject_class->finalize = i_face_log_update_device_args_finalize;
  gobject_class->get_property = i_face_log_update_device_args_get_property;
  gobject_class->set_property = i_face_log_update_device_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_UPDATE_DEVICE_ARGS_DEVICE_BEAN,
     g_param_spec_object ("deviceBean",
                         NULL,
                         NULL,
                         TYPE_DEVICE_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_UPDATE_DEVICE_ARGS_TOKEN,
     g_param_spec_object ("token",
                         NULL,
                         NULL,
                         TYPE_TOKEN,
                         G_PARAM_READWRITE));
}

GType
i_face_log_update_device_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogUpdateDeviceArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_update_device_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogUpdateDeviceArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_update_device_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogUpdateDeviceArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogUpdateDeviceResultProperties
{
  PROP_I_FACE_LOG_UPDATE_DEVICE_RESULT_0,
  PROP_I_FACE_LOG_UPDATE_DEVICE_RESULT_SUCCESS,
  PROP_I_FACE_LOG_UPDATE_DEVICE_RESULT_EX1
};

/* reads a i_face_log_update_device_result object */
static gint32
i_face_log_update_device_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogUpdateDeviceResult * this_object = I_FACE_LOG_UPDATE_DEVICE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_update_device_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogUpdateDeviceResult * this_object = I_FACE_LOG_UPDATE_DEVICE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogUpdateDeviceResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_update_device_result_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogUpdateDeviceResult *self = I_FACE_LOG_UPDATE_DEVICE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_UPDATE_DEVICE_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_UPDATE_DEVICE_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_update_device_result_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  IFaceLogUpdateDeviceResult *self = I_FACE_LOG_UPDATE_DEVICE_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_UPDATE_DEVICE_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_I_FACE_LOG_UPDATE_DEVICE_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_update_device_result_instance_init (IFaceLogUpdateDeviceResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_DEVICE_BEAN, NULL);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_update_device_result_finalize (GObject *object)
{
  IFaceLogUpdateDeviceResult *tobject = I_FACE_LOG_UPDATE_DEVICE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_update_device_result_class_init (IFaceLogUpdateDeviceResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_update_device_result_read;
  struct_class->write = i_face_log_update_device_result_write;

  gobject_class->finalize = i_face_log_update_device_result_finalize;
  gobject_class->get_property = i_face_log_update_device_result_get_property;
  gobject_class->set_property = i_face_log_update_device_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_UPDATE_DEVICE_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_DEVICE_BEAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_UPDATE_DEVICE_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_update_device_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogUpdateDeviceResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_update_device_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogUpdateDeviceResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_update_device_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogUpdateDeviceResultType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a i_face_log_version_args object */
static gint32
i_face_log_version_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogVersionArgs * this_object = I_FACE_LOG_VERSION_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_version_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogVersionArgs * this_object = I_FACE_LOG_VERSION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogVersionArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
i_face_log_version_args_instance_init (IFaceLogVersionArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
i_face_log_version_args_finalize (GObject *object)
{
  IFaceLogVersionArgs *tobject = I_FACE_LOG_VERSION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_version_args_class_init (IFaceLogVersionArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_version_args_read;
  struct_class->write = i_face_log_version_args_write;

  gobject_class->finalize = i_face_log_version_args_finalize;
}

GType
i_face_log_version_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogVersionArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_version_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogVersionArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_version_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogVersionArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogVersionResultProperties
{
  PROP_I_FACE_LOG_VERSION_RESULT_0,
  PROP_I_FACE_LOG_VERSION_RESULT_SUCCESS,
  PROP_I_FACE_LOG_VERSION_RESULT_EX1
};

/* reads a i_face_log_version_result object */
static gint32
i_face_log_version_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogVersionResult * this_object = I_FACE_LOG_VERSION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRING)
        {
          if (this_object->success != NULL)
          {
            g_free(this_object->success);
            this_object->success = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_version_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogVersionResult * this_object = I_FACE_LOG_VERSION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogVersionResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRING, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_version_result_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  IFaceLogVersionResult *self = I_FACE_LOG_VERSION_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_VERSION_RESULT_SUCCESS:
      if (self->success != NULL)
        g_free (self->success);
      self->success = g_value_dup_string (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_VERSION_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_version_result_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  IFaceLogVersionResult *self = I_FACE_LOG_VERSION_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_VERSION_RESULT_SUCCESS:
      g_value_set_string (value, self->success);
      break;

    case PROP_I_FACE_LOG_VERSION_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_version_result_instance_init (IFaceLogVersionResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = NULL;
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_version_result_finalize (GObject *object)
{
  IFaceLogVersionResult *tobject = I_FACE_LOG_VERSION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_free(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_version_result_class_init (IFaceLogVersionResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_version_result_read;
  struct_class->write = i_face_log_version_result_write;

  gobject_class->finalize = i_face_log_version_result_finalize;
  gobject_class->get_property = i_face_log_version_result_get_property;
  gobject_class->set_property = i_face_log_version_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_VERSION_RESULT_SUCCESS,
     g_param_spec_string ("success",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_VERSION_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_version_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogVersionResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_version_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogVersionResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_version_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogVersionResultType",
                                   &type_info, 0);
  }

  return type;
}

/* reads a i_face_log_version_info_args object */
static gint32
i_face_log_version_info_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogVersionInfoArgs * this_object = I_FACE_LOG_VERSION_INFO_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_version_info_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogVersionInfoArgs * this_object = I_FACE_LOG_VERSION_INFO_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogVersionInfoArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void 
i_face_log_version_info_args_instance_init (IFaceLogVersionInfoArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
}

static void 
i_face_log_version_info_args_finalize (GObject *object)
{
  IFaceLogVersionInfoArgs *tobject = I_FACE_LOG_VERSION_INFO_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
i_face_log_version_info_args_class_init (IFaceLogVersionInfoArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_version_info_args_read;
  struct_class->write = i_face_log_version_info_args_write;

  gobject_class->finalize = i_face_log_version_info_args_finalize;
}

GType
i_face_log_version_info_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogVersionInfoArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_version_info_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogVersionInfoArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_version_info_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogVersionInfoArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _IFaceLogVersionInfoResultProperties
{
  PROP_I_FACE_LOG_VERSION_INFO_RESULT_0,
  PROP_I_FACE_LOG_VERSION_INFO_RESULT_SUCCESS,
  PROP_I_FACE_LOG_VERSION_INFO_RESULT_EX1
};

/* reads a i_face_log_version_info_result object */
static gint32
i_face_log_version_info_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  IFaceLogVersionInfoResult * this_object = I_FACE_LOG_VERSION_INFO_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key167 = NULL;
              gchar * val168 = NULL;
              if (key167 != NULL)
              {
                g_free(key167);
                key167 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key167, error)) < 0)
                return -1;
              xfer += ret;
              if (val168 != NULL)
              {
                g_free(val168);
                val168 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val168, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->success && key167)
                g_hash_table_insert ((GHashTable *)this_object->success, (gpointer) key167, (gpointer) val168);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->ex1 != NULL)
          {
            g_object_unref (this_object->ex1);
          }
          this_object->ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
          {
            g_object_unref (this_object->ex1);
            this_object->ex1 = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_ex1 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
i_face_log_version_info_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  IFaceLogVersionInfoResult * this_object = I_FACE_LOG_VERSION_INFO_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "IFaceLogVersionInfoResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_MAP, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key169 = NULL;
      gchar * val170 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->success ? (gint32) g_hash_table_size ((GHashTable *) this_object->success) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->success)
        g_hash_table_foreach ((GHashTable *) this_object->success, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key169 = keys[i];
        val170 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->success), (gpointer) key169);

        if ((ret = thrift_protocol_write_string (protocol,  key169, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val170, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ex1 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ex1", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ex1), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
i_face_log_version_info_result_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogVersionInfoResult *self = I_FACE_LOG_VERSION_INFO_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_VERSION_INFO_RESULT_SUCCESS:
      if (self->success != NULL)
        g_hash_table_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_I_FACE_LOG_VERSION_INFO_RESULT_EX1:
      if (self->ex1 != NULL)
        g_object_unref (self->ex1);
      self->ex1 = g_value_dup_object (value);
      self->__isset_ex1 = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_version_info_result_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  IFaceLogVersionInfoResult *self = I_FACE_LOG_VERSION_INFO_RESULT (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_VERSION_INFO_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_I_FACE_LOG_VERSION_INFO_RESULT_EX1:
      g_value_set_object (value, self->ex1);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
i_face_log_version_info_result_instance_init (IFaceLogVersionInfoResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_success = FALSE;
  object->ex1 = NULL;
  object->__isset_ex1 = FALSE;
}

static void 
i_face_log_version_info_result_finalize (GObject *object)
{
  IFaceLogVersionInfoResult *tobject = I_FACE_LOG_VERSION_INFO_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_hash_table_destroy (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->ex1 != NULL)
  {
    g_object_unref(tobject->ex1);
    tobject->ex1 = NULL;
  }
}

static void
i_face_log_version_info_result_class_init (IFaceLogVersionInfoResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = i_face_log_version_info_result_read;
  struct_class->write = i_face_log_version_info_result_write;

  gobject_class->finalize = i_face_log_version_info_result_finalize;
  gobject_class->get_property = i_face_log_version_info_result_get_property;
  gobject_class->set_property = i_face_log_version_info_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_VERSION_INFO_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_I_FACE_LOG_VERSION_INFO_RESULT_EX1,
     g_param_spec_object ("ex1",
                         NULL,
                         NULL,
                         TYPE_SERVICE_RUNTIME_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
i_face_log_version_info_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (IFaceLogVersionInfoResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) i_face_log_version_info_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (IFaceLogVersionInfoResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) i_face_log_version_info_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "IFaceLogVersionInfoResultType",
                                   &type_info, 0);
  }

  return type;
}

