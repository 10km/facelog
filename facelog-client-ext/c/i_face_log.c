/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include <string.h>
#include <thrift/c_glib/thrift.h>
#include <thrift/c_glib/thrift_application_exception.h>
#include "i_face_log.h"

gboolean
i_face_log_if_add_feature (IFaceLogIf *iface, FeatureBean ** _return, const GByteArray * feature, const gchar * featureVersion, const gint32 personId, const GPtrArray * faecBeans, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->add_feature (iface, _return, feature, featureVersion, personId, faecBeans, token, ex1, ex2, error);
}

gboolean
i_face_log_if_add_feature_multi (IFaceLogIf *iface, FeatureBean ** _return, const GByteArray * feature, const gchar * featureVersion, const gint32 personId, const GPtrArray * photos, const GPtrArray * faces, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->add_feature_multi (iface, _return, feature, featureVersion, personId, photos, faces, token, ex1, ex2, error);
}

gboolean
i_face_log_if_add_feature_with_image (IFaceLogIf *iface, FeatureBean ** _return, const GByteArray * feature, const gchar * featureVersion, const gint32 personId, const gboolean asIdPhotoIfAbsent, const GByteArray * featurePhoto, const FaceBean * faceBean, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->add_feature_with_image (iface, _return, feature, featureVersion, personId, asIdPhotoIfAbsent, featurePhoto, faceBean, token, ex1, ex2, error);
}

gboolean
i_face_log_if_add_image (IFaceLogIf *iface, ImageBean ** _return, const GByteArray * imageData, const gint32 deviceId, const FaceBean * faceBean, const gint32 personId, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->add_image (iface, _return, imageData, deviceId, faceBean, personId, token, ex1, ex2, error);
}

gboolean
i_face_log_if_add_log (IFaceLogIf *iface, const LogBean * logBean, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->add_log (iface, logBean, token, ex1, ex2, error);
}

gboolean
i_face_log_if_add_log_full (IFaceLogIf *iface, const LogBean * logBean, const FaceBean * faceBean, const GByteArray * featureImage, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->add_log_full (iface, logBean, faceBean, featureImage, token, ex1, ex2, error);
}

gboolean
i_face_log_if_add_logs (IFaceLogIf *iface, const GPtrArray * beans, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->add_logs (iface, beans, token, ex1, ex2, error);
}

gboolean
i_face_log_if_add_logs_full (IFaceLogIf *iface, const GPtrArray * logBeans, const GPtrArray * faceBeans, const GPtrArray * featureImages, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->add_logs_full (iface, logBeans, faceBeans, featureImages, token, ex1, ex2, error);
}

gboolean
i_face_log_if_apply_ack_channel (IFaceLogIf *iface, gchar ** _return, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->apply_ack_channel (iface, _return, token, ex1, error);
}

gboolean
i_face_log_if_apply_ack_channel_with_duration (IFaceLogIf *iface, gchar ** _return, const gint32 duration, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->apply_ack_channel_with_duration (iface, _return, duration, token, ex1, error);
}

gboolean
i_face_log_if_apply_cmd_sn (IFaceLogIf *iface, gint32* _return, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->apply_cmd_sn (iface, _return, token, ex1, error);
}

gboolean
i_face_log_if_apply_person_token (IFaceLogIf *iface, Token ** _return, const gint32 personId, const gchar * password, const gboolean isMd5, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->apply_person_token (iface, _return, personId, password, isMd5, ex1, ex2, error);
}

gboolean
i_face_log_if_apply_root_token (IFaceLogIf *iface, Token ** _return, const gchar * password, const gboolean isMd5, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->apply_root_token (iface, _return, password, isMd5, ex1, ex2, error);
}

gboolean
i_face_log_if_apply_user_token (IFaceLogIf *iface, Token ** _return, const gint32 userid, const gchar * password, const gboolean isMd5, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->apply_user_token (iface, _return, userid, password, isMd5, ex1, ex2, error);
}

gboolean
i_face_log_if_bind_border (IFaceLogIf *iface, const gint32 personGroupId, const gint32 deviceGroupId, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->bind_border (iface, personGroupId, deviceGroupId, token, ex1, error);
}

gboolean
i_face_log_if_child_list_for_device_group (IFaceLogIf *iface, GArray ** _return, const gint32 deviceGroupId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->child_list_for_device_group (iface, _return, deviceGroupId, ex1, error);
}

gboolean
i_face_log_if_child_list_for_person_group (IFaceLogIf *iface, GArray ** _return, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->child_list_for_person_group (iface, _return, personGroupId, ex1, error);
}

gboolean
i_face_log_if_count_device_by_where (IFaceLogIf *iface, gint32* _return, const gchar * where, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->count_device_by_where (iface, _return, where, ex1, error);
}

gboolean
i_face_log_if_count_device_group_by_where (IFaceLogIf *iface, gint32* _return, const gchar * where, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->count_device_group_by_where (iface, _return, where, ex1, error);
}

gboolean
i_face_log_if_count_log_by_where (IFaceLogIf *iface, gint32* _return, const gchar * where, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->count_log_by_where (iface, _return, where, ex1, error);
}

gboolean
i_face_log_if_count_log_light_by_verify_time (IFaceLogIf *iface, gint32* _return, const gint64 timestamp, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->count_log_light_by_verify_time (iface, _return, timestamp, ex1, error);
}

gboolean
i_face_log_if_count_log_light_by_verify_time_timestr (IFaceLogIf *iface, gint32* _return, const gchar * timestamp, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->count_log_light_by_verify_time_timestr (iface, _return, timestamp, ex1, error);
}

gboolean
i_face_log_if_count_log_light_by_where (IFaceLogIf *iface, gint32* _return, const gchar * where, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->count_log_light_by_where (iface, _return, where, ex1, error);
}

gboolean
i_face_log_if_count_person_by_where (IFaceLogIf *iface, gint32* _return, const gchar * where, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->count_person_by_where (iface, _return, where, ex1, error);
}

gboolean
i_face_log_if_count_person_group_by_where (IFaceLogIf *iface, gint32* _return, const gchar * where, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->count_person_group_by_where (iface, _return, where, ex1, error);
}

gboolean
i_face_log_if_delete_all_features_by_person_id (IFaceLogIf *iface, gint32* _return, const gint32 personId, const gboolean deleteImage, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->delete_all_features_by_person_id (iface, _return, personId, deleteImage, token, ex1, error);
}

gboolean
i_face_log_if_delete_device_group (IFaceLogIf *iface, gint32* _return, const gint32 deviceGroupId, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->delete_device_group (iface, _return, deviceGroupId, token, ex1, error);
}

gboolean
i_face_log_if_delete_feature (IFaceLogIf *iface, GPtrArray ** _return, const gchar * featureMd5, const gboolean deleteImage, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->delete_feature (iface, _return, featureMd5, deleteImage, token, ex1, error);
}

gboolean
i_face_log_if_delete_group_permit_on_device_group (IFaceLogIf *iface, gint32* _return, const gint32 deviceGroupId, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->delete_group_permit_on_device_group (iface, _return, deviceGroupId, token, ex1, error);
}

gboolean
i_face_log_if_delete_image (IFaceLogIf *iface, gint32* _return, const gchar * imageMd5, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->delete_image (iface, _return, imageMd5, token, ex1, error);
}

gboolean
i_face_log_if_delete_permit_by_id (IFaceLogIf *iface, gint32* _return, const gint32 deviceGroupId, const gint32 personGroupId, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->delete_permit_by_id (iface, _return, deviceGroupId, personGroupId, token, ex1, error);
}

gboolean
i_face_log_if_delete_person (IFaceLogIf *iface, gint32* _return, const gint32 personId, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->delete_person (iface, _return, personId, token, ex1, error);
}

gboolean
i_face_log_if_delete_person_by_papers_num (IFaceLogIf *iface, gint32* _return, const gchar * papersNum, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->delete_person_by_papers_num (iface, _return, papersNum, token, ex1, error);
}

gboolean
i_face_log_if_delete_person_group (IFaceLogIf *iface, gint32* _return, const gint32 personGroupId, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->delete_person_group (iface, _return, personGroupId, token, ex1, error);
}

gboolean
i_face_log_if_delete_person_group_permit (IFaceLogIf *iface, gint32* _return, const gint32 personGroupId, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->delete_person_group_permit (iface, _return, personGroupId, token, ex1, error);
}

gboolean
i_face_log_if_delete_persons (IFaceLogIf *iface, gint32* _return, const GArray * personIdList, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->delete_persons (iface, _return, personIdList, token, ex1, error);
}

gboolean
i_face_log_if_delete_persons_by_papers_num (IFaceLogIf *iface, gint32* _return, const GPtrArray * papersNumlist, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->delete_persons_by_papers_num (iface, _return, papersNumlist, token, ex1, error);
}

gboolean
i_face_log_if_disable_person (IFaceLogIf *iface, const gint32 personId, const gint32 moveToGroupId, const gboolean deletePhoto, const gboolean deleteFeature, const gboolean deleteLog, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->disable_person (iface, personId, moveToGroupId, deletePhoto, deleteFeature, deleteLog, token, ex1, error);
}

gboolean
i_face_log_if_disable_person_list (IFaceLogIf *iface, const GArray * personIdList, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->disable_person_list (iface, personIdList, token, ex1, error);
}

gboolean
i_face_log_if_exists_device (IFaceLogIf *iface, gboolean* _return, const gint32 id, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->exists_device (iface, _return, id, ex1, error);
}

gboolean
i_face_log_if_exists_feature (IFaceLogIf *iface, gboolean* _return, const gchar * md5, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->exists_feature (iface, _return, md5, ex1, error);
}

gboolean
i_face_log_if_exists_image (IFaceLogIf *iface, gboolean* _return, const gchar * md5, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->exists_image (iface, _return, md5, ex1, error);
}

gboolean
i_face_log_if_exists_person (IFaceLogIf *iface, gboolean* _return, const gint32 persionId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->exists_person (iface, _return, persionId, ex1, error);
}

gboolean
i_face_log_if_get_device (IFaceLogIf *iface, DeviceBean ** _return, const gint32 deviceId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_device (iface, _return, deviceId, ex1, error);
}

gboolean
i_face_log_if_get_device_by_mac (IFaceLogIf *iface, DeviceBean ** _return, const gchar * mac, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_device_by_mac (iface, _return, mac, ex1, error);
}

gboolean
i_face_log_if_get_device_group (IFaceLogIf *iface, DeviceGroupBean ** _return, const gint32 deviceGroupId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_device_group (iface, _return, deviceGroupId, ex1, error);
}

gboolean
i_face_log_if_get_device_groups (IFaceLogIf *iface, GPtrArray ** _return, const GArray * groupIdList, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_device_groups (iface, _return, groupIdList, ex1, error);
}

gboolean
i_face_log_if_get_device_groups_belongs (IFaceLogIf *iface, GArray ** _return, const gint32 deviceId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_device_groups_belongs (iface, _return, deviceId, ex1, error);
}

gboolean
i_face_log_if_get_device_groups_permit (IFaceLogIf *iface, GArray ** _return, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_device_groups_permit (iface, _return, personGroupId, ex1, error);
}

gboolean
i_face_log_if_get_device_groups_permitted_by (IFaceLogIf *iface, GArray ** _return, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_device_groups_permitted_by (iface, _return, personGroupId, ex1, error);
}

gboolean
i_face_log_if_get_device_id_of_feature (IFaceLogIf *iface, gint32* _return, const gchar * featureMd5, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_device_id_of_feature (iface, _return, featureMd5, ex1, error);
}

gboolean
i_face_log_if_get_devices (IFaceLogIf *iface, GPtrArray ** _return, const GArray * idList, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_devices (iface, _return, idList, ex1, error);
}

gboolean
i_face_log_if_get_devices_of_group (IFaceLogIf *iface, GArray ** _return, const gint32 deviceGroupId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_devices_of_group (iface, _return, deviceGroupId, ex1, error);
}

gboolean
i_face_log_if_get_face (IFaceLogIf *iface, FaceBean ** _return, const gint32 faceId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_face (iface, _return, faceId, ex1, error);
}

gboolean
i_face_log_if_get_feature (IFaceLogIf *iface, FeatureBean ** _return, const gchar * md5, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_feature (iface, _return, md5, ex1, error);
}

gboolean
i_face_log_if_get_feature_bytes (IFaceLogIf *iface, GByteArray ** _return, const gchar * md5, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_feature_bytes (iface, _return, md5, ex1, error);
}

gboolean
i_face_log_if_get_features (IFaceLogIf *iface, GPtrArray ** _return, const GPtrArray * md5, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_features (iface, _return, md5, ex1, error);
}

gboolean
i_face_log_if_get_features_by_person_id_and_sdk_version (IFaceLogIf *iface, GPtrArray ** _return, const gint32 personId, const gchar * sdkVersion, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_features_by_person_id_and_sdk_version (iface, _return, personId, sdkVersion, ex1, error);
}

gboolean
i_face_log_if_get_features_of_person (IFaceLogIf *iface, GPtrArray ** _return, const gint32 personId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_features_of_person (iface, _return, personId, ex1, error);
}

gboolean
i_face_log_if_get_features_permitted_on_device (IFaceLogIf *iface, GPtrArray ** _return, const gint32 deviceId, const gboolean ignoreSchedule, const gchar * sdkVersion, const GPtrArray * excludeFeatureIds, const gint64 timestamp, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_features_permitted_on_device (iface, _return, deviceId, ignoreSchedule, sdkVersion, excludeFeatureIds, timestamp, ex1, error);
}

gboolean
i_face_log_if_get_group_permit (IFaceLogIf *iface, PermitBean ** _return, const gint32 deviceId, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_group_permit (iface, _return, deviceId, personGroupId, ex1, error);
}

gboolean
i_face_log_if_get_group_permit_on_device_group (IFaceLogIf *iface, PermitBean ** _return, const gint32 deviceGroupId, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_group_permit_on_device_group (iface, _return, deviceGroupId, personGroupId, ex1, error);
}

gboolean
i_face_log_if_get_group_permits (IFaceLogIf *iface, GPtrArray ** _return, const gint32 deviceId, const GArray * personGroupIdList, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_group_permits (iface, _return, deviceId, personGroupIdList, ex1, error);
}

gboolean
i_face_log_if_get_image (IFaceLogIf *iface, ImageBean ** _return, const gchar * imageMD5, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_image (iface, _return, imageMD5, ex1, error);
}

gboolean
i_face_log_if_get_image_bytes (IFaceLogIf *iface, GByteArray ** _return, const gchar * imageMD5, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_image_bytes (iface, _return, imageMD5, ex1, error);
}

gboolean
i_face_log_if_get_images_associated_by_feature (IFaceLogIf *iface, GPtrArray ** _return, const gchar * featureMd5, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_images_associated_by_feature (iface, _return, featureMd5, ex1, error);
}

gboolean
i_face_log_if_get_log_beans_by_person_id (IFaceLogIf *iface, GPtrArray ** _return, const gint32 personId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_log_beans_by_person_id (iface, _return, personId, ex1, error);
}

gboolean
i_face_log_if_get_person (IFaceLogIf *iface, PersonBean ** _return, const gint32 personId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_person (iface, _return, personId, ex1, error);
}

gboolean
i_face_log_if_get_person_by_mobile_phone (IFaceLogIf *iface, PersonBean ** _return, const gchar * mobilePhone, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_person_by_mobile_phone (iface, _return, mobilePhone, ex1, error);
}

gboolean
i_face_log_if_get_person_by_papers_num (IFaceLogIf *iface, PersonBean ** _return, const gchar * papersNum, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_person_by_papers_num (iface, _return, papersNum, ex1, error);
}

gboolean
i_face_log_if_get_person_group (IFaceLogIf *iface, PersonGroupBean ** _return, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_person_group (iface, _return, personGroupId, ex1, error);
}

gboolean
i_face_log_if_get_person_groups (IFaceLogIf *iface, GPtrArray ** _return, const GArray * groupIdList, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_person_groups (iface, _return, groupIdList, ex1, error);
}

gboolean
i_face_log_if_get_person_groups_belongs (IFaceLogIf *iface, GArray ** _return, const gint32 personId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_person_groups_belongs (iface, _return, personId, ex1, error);
}

gboolean
i_face_log_if_get_person_groups_permitted_by (IFaceLogIf *iface, GArray ** _return, const gint32 deviceGroupId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_person_groups_permitted_by (iface, _return, deviceGroupId, ex1, error);
}

gboolean
i_face_log_if_get_person_permit (IFaceLogIf *iface, PermitBean ** _return, const gint32 deviceId, const gint32 personId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_person_permit (iface, _return, deviceId, personId, ex1, error);
}

gboolean
i_face_log_if_get_person_permits (IFaceLogIf *iface, GPtrArray ** _return, const gint32 deviceId, const GArray * personIdList, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_person_permits (iface, _return, deviceId, personIdList, ex1, error);
}

gboolean
i_face_log_if_get_persons (IFaceLogIf *iface, GPtrArray ** _return, const GArray * idList, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_persons (iface, _return, idList, ex1, error);
}

gboolean
i_face_log_if_get_persons_of_group (IFaceLogIf *iface, GArray ** _return, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_persons_of_group (iface, _return, personGroupId, ex1, error);
}

gboolean
i_face_log_if_get_persons_permitted_on_device (IFaceLogIf *iface, GArray ** _return, const gint32 deviceId, const gboolean ignoreSchedule, const GArray * excludePersonIds, const gint64 timestamp, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_persons_permitted_on_device (iface, _return, deviceId, ignoreSchedule, excludePersonIds, timestamp, ex1, error);
}

gboolean
i_face_log_if_get_properties (IFaceLogIf *iface, GHashTable ** _return, const gchar * prefix, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_properties (iface, _return, prefix, token, ex1, error);
}

gboolean
i_face_log_if_get_property (IFaceLogIf *iface, gchar ** _return, const gchar * key, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_property (iface, _return, key, token, ex1, error);
}

gboolean
i_face_log_if_get_redis_parameters (IFaceLogIf *iface, GHashTable ** _return, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_redis_parameters (iface, _return, token, ex1, error);
}

gboolean
i_face_log_if_get_service_config (IFaceLogIf *iface, GHashTable ** _return, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_service_config (iface, _return, token, ex1, error);
}

gboolean
i_face_log_if_get_sub_device_group (IFaceLogIf *iface, GArray ** _return, const gint32 deviceGroupId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_sub_device_group (iface, _return, deviceGroupId, ex1, error);
}

gboolean
i_face_log_if_get_sub_person_group (IFaceLogIf *iface, GArray ** _return, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->get_sub_person_group (iface, _return, personGroupId, ex1, error);
}

gboolean
i_face_log_if_is_disable (IFaceLogIf *iface, gboolean* _return, const gint32 personId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->is_disable (iface, _return, personId, ex1, error);
}

gboolean
i_face_log_if_is_local (IFaceLogIf *iface, gboolean* _return, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->is_local (iface, _return, ex1, error);
}

gboolean
i_face_log_if_is_valid_ack_channel (IFaceLogIf *iface, gboolean* _return, const gchar * ackChannel, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->is_valid_ack_channel (iface, _return, ackChannel, ex1, error);
}

gboolean
i_face_log_if_is_valid_cmd_sn (IFaceLogIf *iface, gboolean* _return, const gint32 cmdSn, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->is_valid_cmd_sn (iface, _return, cmdSn, ex1, error);
}

gboolean
i_face_log_if_is_valid_device_token (IFaceLogIf *iface, gboolean* _return, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->is_valid_device_token (iface, _return, token, ex1, error);
}

gboolean
i_face_log_if_is_valid_password (IFaceLogIf *iface, gboolean* _return, const gchar * userId, const gchar * password, const gboolean isMd5, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->is_valid_password (iface, _return, userId, password, isMd5, ex1, error);
}

gboolean
i_face_log_if_is_valid_person_token (IFaceLogIf *iface, gboolean* _return, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->is_valid_person_token (iface, _return, token, ex1, error);
}

gboolean
i_face_log_if_is_valid_root_token (IFaceLogIf *iface, gboolean* _return, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->is_valid_root_token (iface, _return, token, ex1, error);
}

gboolean
i_face_log_if_is_valid_token (IFaceLogIf *iface, gboolean* _return, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->is_valid_token (iface, _return, token, ex1, error);
}

gboolean
i_face_log_if_is_valid_user_token (IFaceLogIf *iface, gboolean* _return, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->is_valid_user_token (iface, _return, token, ex1, error);
}

gboolean
i_face_log_if_list_of_parent_for_device_group (IFaceLogIf *iface, GArray ** _return, const gint32 deviceGroupId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->list_of_parent_for_device_group (iface, _return, deviceGroupId, ex1, error);
}

gboolean
i_face_log_if_list_of_parent_for_person_group (IFaceLogIf *iface, GArray ** _return, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->list_of_parent_for_person_group (iface, _return, personGroupId, ex1, error);
}

gboolean
i_face_log_if_load_all_person (IFaceLogIf *iface, GArray ** _return, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_all_person (iface, _return, ex1, error);
}

gboolean
i_face_log_if_load_device_by_where (IFaceLogIf *iface, GPtrArray ** _return, const gchar * where, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_device_by_where (iface, _return, where, startRow, numRows, ex1, error);
}

gboolean
i_face_log_if_load_device_group_by_where (IFaceLogIf *iface, GArray ** _return, const gchar * where, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_device_group_by_where (iface, _return, where, startRow, numRows, ex1, error);
}

gboolean
i_face_log_if_load_device_group_id_by_where (IFaceLogIf *iface, GArray ** _return, const gchar * where, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_device_group_id_by_where (iface, _return, where, ex1, error);
}

gboolean
i_face_log_if_load_device_id_by_where (IFaceLogIf *iface, GArray ** _return, const gchar * where, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_device_id_by_where (iface, _return, where, ex1, error);
}

gboolean
i_face_log_if_load_distinct_integer_column (IFaceLogIf *iface, GArray ** _return, const gchar * table, const gchar * column, const gchar * where, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_distinct_integer_column (iface, _return, table, column, where, ex1, error);
}

gboolean
i_face_log_if_load_distinct_string_column (IFaceLogIf *iface, GPtrArray ** _return, const gchar * table, const gchar * column, const gchar * where, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_distinct_string_column (iface, _return, table, column, where, ex1, error);
}

gboolean
i_face_log_if_load_feature_md5_by_update (IFaceLogIf *iface, GPtrArray ** _return, const gint64 timestamp, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_feature_md5_by_update (iface, _return, timestamp, ex1, error);
}

gboolean
i_face_log_if_load_feature_md5_by_update_time_str (IFaceLogIf *iface, GPtrArray ** _return, const gchar * timestamp, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_feature_md5_by_update_time_str (iface, _return, timestamp, ex1, error);
}

gboolean
i_face_log_if_load_log_by_where (IFaceLogIf *iface, GPtrArray ** _return, const gchar * where, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_log_by_where (iface, _return, where, startRow, numRows, ex1, error);
}

gboolean
i_face_log_if_load_log_light_by_verify_time (IFaceLogIf *iface, GPtrArray ** _return, const gint64 timestamp, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_log_light_by_verify_time (iface, _return, timestamp, startRow, numRows, ex1, error);
}

gboolean
i_face_log_if_load_log_light_by_verify_time_timestr (IFaceLogIf *iface, GPtrArray ** _return, const gchar * timestamp, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_log_light_by_verify_time_timestr (iface, _return, timestamp, startRow, numRows, ex1, error);
}

gboolean
i_face_log_if_load_log_light_by_where (IFaceLogIf *iface, GPtrArray ** _return, const gchar * where, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_log_light_by_where (iface, _return, where, startRow, numRows, ex1, error);
}

gboolean
i_face_log_if_load_permit_by_update (IFaceLogIf *iface, GPtrArray ** _return, const gint64 timestamp, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_permit_by_update (iface, _return, timestamp, ex1, error);
}

gboolean
i_face_log_if_load_permit_by_update_timestr (IFaceLogIf *iface, GPtrArray ** _return, const gchar * timestamp, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_permit_by_update_timestr (iface, _return, timestamp, ex1, error);
}

gboolean
i_face_log_if_load_person_by_where (IFaceLogIf *iface, GPtrArray ** _return, const gchar * where, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_person_by_where (iface, _return, where, startRow, numRows, ex1, error);
}

gboolean
i_face_log_if_load_person_group_by_where (IFaceLogIf *iface, GArray ** _return, const gchar * where, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_person_group_by_where (iface, _return, where, startRow, numRows, ex1, error);
}

gboolean
i_face_log_if_load_person_group_id_by_where (IFaceLogIf *iface, GArray ** _return, const gchar * where, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_person_group_id_by_where (iface, _return, where, ex1, error);
}

gboolean
i_face_log_if_load_person_id_by_update_time (IFaceLogIf *iface, GArray ** _return, const gint64 timestamp, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_person_id_by_update_time (iface, _return, timestamp, ex1, error);
}

gboolean
i_face_log_if_load_person_id_by_update_time_time_str (IFaceLogIf *iface, GArray ** _return, const gchar * timestamp, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_person_id_by_update_time_time_str (iface, _return, timestamp, ex1, error);
}

gboolean
i_face_log_if_load_person_id_by_where (IFaceLogIf *iface, GArray ** _return, const gchar * where, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_person_id_by_where (iface, _return, where, ex1, error);
}

gboolean
i_face_log_if_load_updated_persons (IFaceLogIf *iface, GArray ** _return, const gint64 timestamp, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_updated_persons (iface, _return, timestamp, ex1, error);
}

gboolean
i_face_log_if_load_updated_persons_timestr (IFaceLogIf *iface, GArray ** _return, const gchar * timestamp, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->load_updated_persons_timestr (iface, _return, timestamp, ex1, error);
}

gboolean
i_face_log_if_offline (IFaceLogIf *iface, const Token * token, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->offline (iface, token, ex1, ex2, error);
}

gboolean
i_face_log_if_online (IFaceLogIf *iface, Token ** _return, const DeviceBean * device, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->online (iface, _return, device, ex1, ex2, error);
}

gboolean
i_face_log_if_register_device (IFaceLogIf *iface, DeviceBean ** _return, const DeviceBean * newDevice, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->register_device (iface, _return, newDevice, ex1, ex2, error);
}

gboolean
i_face_log_if_release_person_token (IFaceLogIf *iface, const Token * token, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->release_person_token (iface, token, ex1, ex2, error);
}

gboolean
i_face_log_if_release_root_token (IFaceLogIf *iface, const Token * token, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->release_root_token (iface, token, ex1, ex2, error);
}

gboolean
i_face_log_if_release_user_token (IFaceLogIf *iface, const Token * token, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->release_user_token (iface, token, ex1, ex2, error);
}

gboolean
i_face_log_if_replace_feature (IFaceLogIf *iface, const gint32 personId, const gchar * featureMd5, const gboolean deleteOldFeatureImage, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->replace_feature (iface, personId, featureMd5, deleteOldFeatureImage, token, ex1, error);
}

gboolean
i_face_log_if_root_group_of_device (IFaceLogIf *iface, gint32* _return, const gint32 deviceId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->root_group_of_device (iface, _return, deviceId, ex1, error);
}

gboolean
i_face_log_if_root_group_of_person (IFaceLogIf *iface, gint32* _return, const gint32 personId, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->root_group_of_person (iface, _return, personId, ex1, error);
}

gboolean
i_face_log_if_run_cmd (IFaceLogIf *iface, gchar ** _return, const GArray * target, const gboolean group, const gchar * cmdpath, const gchar * jsonArgs, const gchar * ackChannel, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->run_cmd (iface, _return, target, group, cmdpath, jsonArgs, ackChannel, token, ex1, error);
}

gboolean
i_face_log_if_run_task (IFaceLogIf *iface, gint32* _return, const gchar * taskQueue, const gchar * cmdpath, const gchar * jsonArgs, const gchar * ackChannel, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->run_task (iface, _return, taskQueue, cmdpath, jsonArgs, ackChannel, token, ex1, error);
}

gboolean
i_face_log_if_save_device (IFaceLogIf *iface, DeviceBean ** _return, const DeviceBean * deviceBean, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->save_device (iface, _return, deviceBean, token, ex1, error);
}

gboolean
i_face_log_if_save_device_group (IFaceLogIf *iface, DeviceGroupBean ** _return, const DeviceGroupBean * deviceGroupBean, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->save_device_group (iface, _return, deviceGroupBean, token, ex1, error);
}

gboolean
i_face_log_if_save_permit (IFaceLogIf *iface, PermitBean ** _return, const PermitBean * permitBean, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->save_permit (iface, _return, permitBean, token, ex1, error);
}

gboolean
i_face_log_if_save_permit_with_schedule (IFaceLogIf *iface, PermitBean ** _return, const gint32 deviceGroupId, const gint32 personGroupId, const gchar * schedule, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->save_permit_with_schedule (iface, _return, deviceGroupId, personGroupId, schedule, token, ex1, error);
}

gboolean
i_face_log_if_save_person (IFaceLogIf *iface, PersonBean ** _return, const PersonBean * personBean, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->save_person (iface, _return, personBean, token, ex1, error);
}

gboolean
i_face_log_if_save_person_full (IFaceLogIf *iface, PersonBean ** _return, const PersonBean * personBean, const GByteArray * idPhoto, const GByteArray * feature, const gchar * featureVersion, const GByteArray * featureImage, const FaceBean * featureFaceBean, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->save_person_full (iface, _return, personBean, idPhoto, feature, featureVersion, featureImage, featureFaceBean, token, ex1, error);
}

gboolean
i_face_log_if_save_person_group (IFaceLogIf *iface, PersonGroupBean ** _return, const PersonGroupBean * personGroupBean, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->save_person_group (iface, _return, personGroupBean, token, ex1, error);
}

gboolean
i_face_log_if_save_person_with_photo (IFaceLogIf *iface, PersonBean ** _return, const PersonBean * personBean, const GByteArray * idPhoto, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->save_person_with_photo (iface, _return, personBean, idPhoto, token, ex1, error);
}

gboolean
i_face_log_if_save_person_with_photo_and_feature (IFaceLogIf *iface, PersonBean ** _return, const PersonBean * personBean, const GByteArray * idPhoto, const FeatureBean * featureBean, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->save_person_with_photo_and_feature (iface, _return, personBean, idPhoto, featureBean, token, ex1, error);
}

gboolean
i_face_log_if_save_person_with_photo_and_feature_multi_faces (IFaceLogIf *iface, PersonBean ** _return, const PersonBean * personBean, const GByteArray * idPhoto, const GByteArray * feature, const gchar * featureVersion, const GPtrArray * faceBeans, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->save_person_with_photo_and_feature_multi_faces (iface, _return, personBean, idPhoto, feature, featureVersion, faceBeans, token, ex1, error);
}

gboolean
i_face_log_if_save_person_with_photo_and_feature_multi_image (IFaceLogIf *iface, PersonBean ** _return, const PersonBean * personBean, const GByteArray * idPhoto, const GByteArray * feature, const gchar * featureVersion, const GPtrArray * photos, const GPtrArray * faces, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->save_person_with_photo_and_feature_multi_image (iface, _return, personBean, idPhoto, feature, featureVersion, photos, faces, token, ex1, error);
}

gboolean
i_face_log_if_save_person_with_photo_and_feature_saved (IFaceLogIf *iface, PersonBean ** _return, const PersonBean * personBean, const gchar * idPhotoMd5, const gchar * featureMd5, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->save_person_with_photo_and_feature_saved (iface, _return, personBean, idPhotoMd5, featureMd5, token, ex1, error);
}

gboolean
i_face_log_if_save_persons (IFaceLogIf *iface, const GPtrArray * persons, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->save_persons (iface, persons, token, ex1, error);
}

gboolean
i_face_log_if_save_persons_with_photo (IFaceLogIf *iface, gint32* _return, const GPtrArray * photos, const GPtrArray * persons, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->save_persons_with_photo (iface, _return, photos, persons, token, ex1, error);
}

gboolean
i_face_log_if_save_service_config (IFaceLogIf *iface, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->save_service_config (iface, token, ex1, error);
}

gboolean
i_face_log_if_sdk_task_queue_of (IFaceLogIf *iface, gchar ** _return, const gchar * task, const gchar * sdkVersion, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->sdk_task_queue_of (iface, _return, task, sdkVersion, token, ex1, error);
}

gboolean
i_face_log_if_set_person_expiry_date (IFaceLogIf *iface, const gint32 personId, const gint64 expiryDate, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->set_person_expiry_date (iface, personId, expiryDate, token, ex1, error);
}

gboolean
i_face_log_if_set_person_expiry_date_list (IFaceLogIf *iface, const GArray * personIdList, const gint64 expiryDate, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->set_person_expiry_date_list (iface, personIdList, expiryDate, token, ex1, error);
}

gboolean
i_face_log_if_set_person_expiry_date_time_str (IFaceLogIf *iface, const gint32 personId, const gchar * expiryDate, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->set_person_expiry_date_time_str (iface, personId, expiryDate, token, ex1, error);
}

gboolean
i_face_log_if_set_properties (IFaceLogIf *iface, const GHashTable * config, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->set_properties (iface, config, token, ex1, error);
}

gboolean
i_face_log_if_set_property (IFaceLogIf *iface, const gchar * key, const gchar * value, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->set_property (iface, key, value, token, ex1, error);
}

gboolean
i_face_log_if_task_queue_of (IFaceLogIf *iface, gchar ** _return, const gchar * task, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->task_queue_of (iface, _return, task, token, ex1, error);
}

gboolean
i_face_log_if_unbind_border (IFaceLogIf *iface, const gint32 personGroupId, const gint32 deviceGroupId, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->unbind_border (iface, personGroupId, deviceGroupId, token, ex1, error);
}

gboolean
i_face_log_if_unregister_device (IFaceLogIf *iface, const Token * token, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->unregister_device (iface, token, ex1, ex2, error);
}

gboolean
i_face_log_if_update_device (IFaceLogIf *iface, DeviceBean ** _return, const DeviceBean * deviceBean, const Token * token, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->update_device (iface, _return, deviceBean, token, ex1, error);
}

gboolean
i_face_log_if_version (IFaceLogIf *iface, gchar ** _return, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->version (iface, _return, ex1, error);
}

gboolean
i_face_log_if_version_info (IFaceLogIf *iface, GHashTable ** _return, ServiceRuntimeException ** ex1, GError **error)
{
  return I_FACE_LOG_IF_GET_INTERFACE (iface)->version_info (iface, _return, ex1, error);
}

GType
i_face_log_if_get_type (void)
{
  static GType type = 0;
  if (type == 0)
  {
    static const GTypeInfo type_info =
    {
      sizeof (IFaceLogIfInterface),
      NULL,  /* base_init */
      NULL,  /* base_finalize */
      NULL,  /* class_init */
      NULL,  /* class_finalize */
      NULL,  /* class_data */
      0,     /* instance_size */
      0,     /* n_preallocs */
      NULL,  /* instance_init */
      NULL   /* value_table */
    };
    type = g_type_register_static (G_TYPE_INTERFACE,
                                   "IFaceLogIf",
                                   &type_info, 0);
  }
  return type;
}

static void 
i_face_log_if_interface_init (IFaceLogIfInterface *iface);

G_DEFINE_TYPE_WITH_CODE (IFaceLogClient, i_face_log_client,
                         G_TYPE_OBJECT, 
                         G_IMPLEMENT_INTERFACE (TYPE_I_FACE_LOG_IF,
                                                i_face_log_if_interface_init))

enum _IFaceLogClientProperties
{
  PROP_0,
  PROP_I_FACE_LOG_CLIENT_INPUT_PROTOCOL,
  PROP_I_FACE_LOG_CLIENT_OUTPUT_PROTOCOL
};

void
i_face_log_client_set_property (GObject *object, guint property_id, const GValue *value, GParamSpec *pspec)
{
  IFaceLogClient *client = I_FACE_LOG_CLIENT (object);

  THRIFT_UNUSED_VAR (pspec);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_CLIENT_INPUT_PROTOCOL:
      client->input_protocol = g_value_get_object (value);
      break;
    case PROP_I_FACE_LOG_CLIENT_OUTPUT_PROTOCOL:
      client->output_protocol = g_value_get_object (value);
      break;
  }
}

void
i_face_log_client_get_property (GObject *object, guint property_id, GValue *value, GParamSpec *pspec)
{
  IFaceLogClient *client = I_FACE_LOG_CLIENT (object);

  THRIFT_UNUSED_VAR (pspec);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_CLIENT_INPUT_PROTOCOL:
      g_value_set_object (value, client->input_protocol);
      break;
    case PROP_I_FACE_LOG_CLIENT_OUTPUT_PROTOCOL:
      g_value_set_object (value, client->output_protocol);
      break;
  }
}

gboolean i_face_log_client_send_add_feature (IFaceLogIf * iface, const GByteArray * feature, const gchar * featureVersion, const gint32 personId, const GPtrArray * faecBeans, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "addFeature", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "addFeature_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "feature", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, feature ? ((GByteArray *) feature)->data : NULL, feature ? ((GByteArray *) feature)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "featureVersion", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, featureVersion, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "faecBeans", T_LIST, 4, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i177;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (faecBeans ? faecBeans->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i177 = 0; i177 < (faecBeans ? faecBeans->len : 0); i177++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) faecBeans, i177))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 5, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_add_feature (IFaceLogIf * iface, FeatureBean ** _return, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "addFeature", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected addFeature", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_DUPLICATE_RECORD_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex2 != NULL)
            {
              g_object_unref (*ex2);
            }
            *ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex2), protocol, error)) < 0)
            {
              g_object_unref (*ex2);
              *ex2 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, DUPLICATE_RECORD_EXCEPTION_ERROR, DUPLICATE_RECORD_EXCEPTION_ERROR_CODE, "DuplicateRecordException");
      return FALSE;
  }
  if (*ex2 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_add_feature (IFaceLogIf * iface, FeatureBean ** _return, const GByteArray * feature, const gchar * featureVersion, const gint32 personId, const GPtrArray * faecBeans, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  if (!i_face_log_client_send_add_feature (iface, feature, featureVersion, personId, faecBeans, token, error))
    return FALSE;
  if (!i_face_log_client_recv_add_feature (iface, _return, ex1, ex2, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_add_feature_multi (IFaceLogIf * iface, const GByteArray * feature, const gchar * featureVersion, const gint32 personId, const GPtrArray * photos, const GPtrArray * faces, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "addFeatureMulti", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "addFeatureMulti_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "feature", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, feature ? ((GByteArray *) feature)->data : NULL, feature ? ((GByteArray *) feature)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "featureVersion", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, featureVersion, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "photos", T_LIST, 4, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i178;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (photos ? photos->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i178 = 0; i178 < (photos ? photos->len : 0); i178++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) photos, i178)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) photos, i178)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) photos, i178)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) photos, i178)))->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "faces", T_LIST, 5, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i179;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (faces ? faces->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i179 = 0; i179 < (faces ? faces->len : 0); i179++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) faces, i179))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 6, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_add_feature_multi (IFaceLogIf * iface, FeatureBean ** _return, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "addFeatureMulti", 15) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected addFeatureMulti", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_DUPLICATE_RECORD_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex2 != NULL)
            {
              g_object_unref (*ex2);
            }
            *ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex2), protocol, error)) < 0)
            {
              g_object_unref (*ex2);
              *ex2 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, DUPLICATE_RECORD_EXCEPTION_ERROR, DUPLICATE_RECORD_EXCEPTION_ERROR_CODE, "DuplicateRecordException");
      return FALSE;
  }
  if (*ex2 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_add_feature_multi (IFaceLogIf * iface, FeatureBean ** _return, const GByteArray * feature, const gchar * featureVersion, const gint32 personId, const GPtrArray * photos, const GPtrArray * faces, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  if (!i_face_log_client_send_add_feature_multi (iface, feature, featureVersion, personId, photos, faces, token, error))
    return FALSE;
  if (!i_face_log_client_recv_add_feature_multi (iface, _return, ex1, ex2, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_add_feature_with_image (IFaceLogIf * iface, const GByteArray * feature, const gchar * featureVersion, const gint32 personId, const gboolean asIdPhotoIfAbsent, const GByteArray * featurePhoto, const FaceBean * faceBean, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "addFeatureWithImage", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "addFeatureWithImage_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "feature", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, feature ? ((GByteArray *) feature)->data : NULL, feature ? ((GByteArray *) feature)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "featureVersion", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, featureVersion, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "asIdPhotoIfAbsent", T_BOOL, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, asIdPhotoIfAbsent, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "featurePhoto", T_STRING, 5, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, featurePhoto ? ((GByteArray *) featurePhoto)->data : NULL, featurePhoto ? ((GByteArray *) featurePhoto)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "faceBean", T_STRUCT, 6, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (faceBean), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 7, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_add_feature_with_image (IFaceLogIf * iface, FeatureBean ** _return, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "addFeatureWithImage", 19) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected addFeatureWithImage", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_DUPLICATE_RECORD_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex2 != NULL)
            {
              g_object_unref (*ex2);
            }
            *ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex2), protocol, error)) < 0)
            {
              g_object_unref (*ex2);
              *ex2 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, DUPLICATE_RECORD_EXCEPTION_ERROR, DUPLICATE_RECORD_EXCEPTION_ERROR_CODE, "DuplicateRecordException");
      return FALSE;
  }
  if (*ex2 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_add_feature_with_image (IFaceLogIf * iface, FeatureBean ** _return, const GByteArray * feature, const gchar * featureVersion, const gint32 personId, const gboolean asIdPhotoIfAbsent, const GByteArray * featurePhoto, const FaceBean * faceBean, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  if (!i_face_log_client_send_add_feature_with_image (iface, feature, featureVersion, personId, asIdPhotoIfAbsent, featurePhoto, faceBean, token, error))
    return FALSE;
  if (!i_face_log_client_recv_add_feature_with_image (iface, _return, ex1, ex2, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_add_image (IFaceLogIf * iface, const GByteArray * imageData, const gint32 deviceId, const FaceBean * faceBean, const gint32 personId, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "addImage", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "addImage_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "imageData", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, imageData ? ((GByteArray *) imageData)->data : NULL, imageData ? ((GByteArray *) imageData)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceId", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "faceBean", T_STRUCT, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (faceBean), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 5, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_add_image (IFaceLogIf * iface, ImageBean ** _return, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "addImage", 8) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected addImage", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_DUPLICATE_RECORD_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex2 != NULL)
            {
              g_object_unref (*ex2);
            }
            *ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex2), protocol, error)) < 0)
            {
              g_object_unref (*ex2);
              *ex2 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, DUPLICATE_RECORD_EXCEPTION_ERROR, DUPLICATE_RECORD_EXCEPTION_ERROR_CODE, "DuplicateRecordException");
      return FALSE;
  }
  if (*ex2 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_add_image (IFaceLogIf * iface, ImageBean ** _return, const GByteArray * imageData, const gint32 deviceId, const FaceBean * faceBean, const gint32 personId, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  if (!i_face_log_client_send_add_image (iface, imageData, deviceId, faceBean, personId, token, error))
    return FALSE;
  if (!i_face_log_client_recv_add_image (iface, _return, ex1, ex2, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_add_log (IFaceLogIf * iface, const LogBean * logBean, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "addLog", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "addLog_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "logBean", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (logBean), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_add_log (IFaceLogIf * iface, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "addLog", 6) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected addLog", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_DUPLICATE_RECORD_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex2 != NULL)
            {
              g_object_unref (*ex2);
            }
            *ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex2), protocol, error)) < 0)
            {
              g_object_unref (*ex2);
              *ex2 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, DUPLICATE_RECORD_EXCEPTION_ERROR, DUPLICATE_RECORD_EXCEPTION_ERROR_CODE, "DuplicateRecordException");
      return FALSE;
  }
  if (*ex2 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_add_log (IFaceLogIf * iface, const LogBean * logBean, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  if (!i_face_log_client_send_add_log (iface, logBean, token, error))
    return FALSE;
  if (!i_face_log_client_recv_add_log (iface, ex1, ex2, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_add_log_full (IFaceLogIf * iface, const LogBean * logBean, const FaceBean * faceBean, const GByteArray * featureImage, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "addLogFull", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "addLogFull_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "logBean", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (logBean), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "faceBean", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (faceBean), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "featureImage", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, featureImage ? ((GByteArray *) featureImage)->data : NULL, featureImage ? ((GByteArray *) featureImage)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_add_log_full (IFaceLogIf * iface, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "addLogFull", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected addLogFull", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_DUPLICATE_RECORD_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex2 != NULL)
            {
              g_object_unref (*ex2);
            }
            *ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex2), protocol, error)) < 0)
            {
              g_object_unref (*ex2);
              *ex2 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, DUPLICATE_RECORD_EXCEPTION_ERROR, DUPLICATE_RECORD_EXCEPTION_ERROR_CODE, "DuplicateRecordException");
      return FALSE;
  }
  if (*ex2 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_add_log_full (IFaceLogIf * iface, const LogBean * logBean, const FaceBean * faceBean, const GByteArray * featureImage, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  if (!i_face_log_client_send_add_log_full (iface, logBean, faceBean, featureImage, token, error))
    return FALSE;
  if (!i_face_log_client_recv_add_log_full (iface, ex1, ex2, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_add_logs (IFaceLogIf * iface, const GPtrArray * beans, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "addLogs", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "addLogs_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "beans", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i180;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (beans ? beans->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i180 = 0; i180 < (beans ? beans->len : 0); i180++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) beans, i180))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_add_logs (IFaceLogIf * iface, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "addLogs", 7) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected addLogs", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_DUPLICATE_RECORD_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex2 != NULL)
            {
              g_object_unref (*ex2);
            }
            *ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex2), protocol, error)) < 0)
            {
              g_object_unref (*ex2);
              *ex2 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, DUPLICATE_RECORD_EXCEPTION_ERROR, DUPLICATE_RECORD_EXCEPTION_ERROR_CODE, "DuplicateRecordException");
      return FALSE;
  }
  if (*ex2 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_add_logs (IFaceLogIf * iface, const GPtrArray * beans, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  if (!i_face_log_client_send_add_logs (iface, beans, token, error))
    return FALSE;
  if (!i_face_log_client_recv_add_logs (iface, ex1, ex2, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_add_logs_full (IFaceLogIf * iface, const GPtrArray * logBeans, const GPtrArray * faceBeans, const GPtrArray * featureImages, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "addLogsFull", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "addLogsFull_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "logBeans", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i181;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (logBeans ? logBeans->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i181 = 0; i181 < (logBeans ? logBeans->len : 0); i181++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) logBeans, i181))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "faceBeans", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i182;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (faceBeans ? faceBeans->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i182 = 0; i182 < (faceBeans ? faceBeans->len : 0); i182++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) faceBeans, i182))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "featureImages", T_LIST, 3, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i183;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (featureImages ? featureImages->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i183 = 0; i183 < (featureImages ? featureImages->len : 0); i183++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) featureImages, i183)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) featureImages, i183)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) featureImages, i183)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) featureImages, i183)))->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_add_logs_full (IFaceLogIf * iface, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "addLogsFull", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected addLogsFull", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_DUPLICATE_RECORD_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex2 != NULL)
            {
              g_object_unref (*ex2);
            }
            *ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex2), protocol, error)) < 0)
            {
              g_object_unref (*ex2);
              *ex2 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, DUPLICATE_RECORD_EXCEPTION_ERROR, DUPLICATE_RECORD_EXCEPTION_ERROR_CODE, "DuplicateRecordException");
      return FALSE;
  }
  if (*ex2 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_add_logs_full (IFaceLogIf * iface, const GPtrArray * logBeans, const GPtrArray * faceBeans, const GPtrArray * featureImages, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  if (!i_face_log_client_send_add_logs_full (iface, logBeans, faceBeans, featureImages, token, error))
    return FALSE;
  if (!i_face_log_client_recv_add_logs_full (iface, ex1, ex2, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_apply_ack_channel (IFaceLogIf * iface, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "applyAckChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "applyAckChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_apply_ack_channel (IFaceLogIf * iface, gchar ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "applyAckChannel", 15) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected applyAckChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_apply_ack_channel (IFaceLogIf * iface, gchar ** _return, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_apply_ack_channel (iface, token, error))
    return FALSE;
  if (!i_face_log_client_recv_apply_ack_channel (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_apply_ack_channel_with_duration (IFaceLogIf * iface, const gint32 duration, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "applyAckChannelWithDuration", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "applyAckChannelWithDuration_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "duration", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, duration, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_apply_ack_channel_with_duration (IFaceLogIf * iface, gchar ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "applyAckChannelWithDuration", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected applyAckChannelWithDuration", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_apply_ack_channel_with_duration (IFaceLogIf * iface, gchar ** _return, const gint32 duration, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_apply_ack_channel_with_duration (iface, duration, token, error))
    return FALSE;
  if (!i_face_log_client_recv_apply_ack_channel_with_duration (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_apply_cmd_sn (IFaceLogIf * iface, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "applyCmdSn", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "applyCmdSn_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_apply_cmd_sn (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "applyCmdSn", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected applyCmdSn", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_apply_cmd_sn (IFaceLogIf * iface, gint32* _return, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_apply_cmd_sn (iface, token, error))
    return FALSE;
  if (!i_face_log_client_recv_apply_cmd_sn (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_apply_person_token (IFaceLogIf * iface, const gint32 personId, const gchar * password, const gboolean isMd5, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "applyPersonToken", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "applyPersonToken_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "password", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, password, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "isMd5", T_BOOL, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, isMd5, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_apply_person_token (IFaceLogIf * iface, Token ** _return, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "applyPersonToken", 16) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected applyPersonToken", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_SECURITY_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex2 != NULL)
            {
              g_object_unref (*ex2);
            }
            *ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex2), protocol, error)) < 0)
            {
              g_object_unref (*ex2);
              *ex2 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_SECURITY_EXCEPTION_ERROR, SERVICE_SECURITY_EXCEPTION_ERROR_CODE, "ServiceSecurityException");
      return FALSE;
  }
  if (*ex2 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_apply_person_token (IFaceLogIf * iface, Token ** _return, const gint32 personId, const gchar * password, const gboolean isMd5, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  if (!i_face_log_client_send_apply_person_token (iface, personId, password, isMd5, error))
    return FALSE;
  if (!i_face_log_client_recv_apply_person_token (iface, _return, ex1, ex2, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_apply_root_token (IFaceLogIf * iface, const gchar * password, const gboolean isMd5, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "applyRootToken", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "applyRootToken_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "password", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, password, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "isMd5", T_BOOL, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, isMd5, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_apply_root_token (IFaceLogIf * iface, Token ** _return, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "applyRootToken", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected applyRootToken", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_SECURITY_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex2 != NULL)
            {
              g_object_unref (*ex2);
            }
            *ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex2), protocol, error)) < 0)
            {
              g_object_unref (*ex2);
              *ex2 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_SECURITY_EXCEPTION_ERROR, SERVICE_SECURITY_EXCEPTION_ERROR_CODE, "ServiceSecurityException");
      return FALSE;
  }
  if (*ex2 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_apply_root_token (IFaceLogIf * iface, Token ** _return, const gchar * password, const gboolean isMd5, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  if (!i_face_log_client_send_apply_root_token (iface, password, isMd5, error))
    return FALSE;
  if (!i_face_log_client_recv_apply_root_token (iface, _return, ex1, ex2, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_apply_user_token (IFaceLogIf * iface, const gint32 userid, const gchar * password, const gboolean isMd5, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "applyUserToken", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "applyUserToken_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "userid", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, userid, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "password", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, password, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "isMd5", T_BOOL, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, isMd5, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_apply_user_token (IFaceLogIf * iface, Token ** _return, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "applyUserToken", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected applyUserToken", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_SECURITY_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex2 != NULL)
            {
              g_object_unref (*ex2);
            }
            *ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex2), protocol, error)) < 0)
            {
              g_object_unref (*ex2);
              *ex2 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_SECURITY_EXCEPTION_ERROR, SERVICE_SECURITY_EXCEPTION_ERROR_CODE, "ServiceSecurityException");
      return FALSE;
  }
  if (*ex2 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_apply_user_token (IFaceLogIf * iface, Token ** _return, const gint32 userid, const gchar * password, const gboolean isMd5, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  if (!i_face_log_client_send_apply_user_token (iface, userid, password, isMd5, error))
    return FALSE;
  if (!i_face_log_client_recv_apply_user_token (iface, _return, ex1, ex2, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_bind_border (IFaceLogIf * iface, const gint32 personGroupId, const gint32 deviceGroupId, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "bindBorder", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "bindBorder_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_bind_border (IFaceLogIf * iface, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "bindBorder", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected bindBorder", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_bind_border (IFaceLogIf * iface, const gint32 personGroupId, const gint32 deviceGroupId, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_bind_border (iface, personGroupId, deviceGroupId, token, error))
    return FALSE;
  if (!i_face_log_client_recv_bind_border (iface, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_child_list_for_device_group (IFaceLogIf * iface, const gint32 deviceGroupId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "childListForDeviceGroup", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "childListForDeviceGroup_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_child_list_for_device_group (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "childListForDeviceGroup", 23) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected childListForDeviceGroup", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem184 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem184, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem184, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_child_list_for_device_group (IFaceLogIf * iface, GArray ** _return, const gint32 deviceGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_child_list_for_device_group (iface, deviceGroupId, error))
    return FALSE;
  if (!i_face_log_client_recv_child_list_for_device_group (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_child_list_for_person_group (IFaceLogIf * iface, const gint32 personGroupId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "childListForPersonGroup", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "childListForPersonGroup_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_child_list_for_person_group (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "childListForPersonGroup", 23) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected childListForPersonGroup", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem185 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem185, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem185, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_child_list_for_person_group (IFaceLogIf * iface, GArray ** _return, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_child_list_for_person_group (iface, personGroupId, error))
    return FALSE;
  if (!i_face_log_client_recv_child_list_for_person_group (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_count_device_by_where (IFaceLogIf * iface, const gchar * where, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "countDeviceByWhere", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "countDeviceByWhere_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, where, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_count_device_by_where (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "countDeviceByWhere", 18) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected countDeviceByWhere", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_count_device_by_where (IFaceLogIf * iface, gint32* _return, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_count_device_by_where (iface, where, error))
    return FALSE;
  if (!i_face_log_client_recv_count_device_by_where (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_count_device_group_by_where (IFaceLogIf * iface, const gchar * where, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "countDeviceGroupByWhere", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "countDeviceGroupByWhere_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, where, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_count_device_group_by_where (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "countDeviceGroupByWhere", 23) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected countDeviceGroupByWhere", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_count_device_group_by_where (IFaceLogIf * iface, gint32* _return, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_count_device_group_by_where (iface, where, error))
    return FALSE;
  if (!i_face_log_client_recv_count_device_group_by_where (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_count_log_by_where (IFaceLogIf * iface, const gchar * where, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "countLogByWhere", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "countLogByWhere_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, where, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_count_log_by_where (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "countLogByWhere", 15) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected countLogByWhere", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_count_log_by_where (IFaceLogIf * iface, gint32* _return, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_count_log_by_where (iface, where, error))
    return FALSE;
  if (!i_face_log_client_recv_count_log_by_where (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_count_log_light_by_verify_time (IFaceLogIf * iface, const gint64 timestamp, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "countLogLightByVerifyTime", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "countLogLightByVerifyTime_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_count_log_light_by_verify_time (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "countLogLightByVerifyTime", 25) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected countLogLightByVerifyTime", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_count_log_light_by_verify_time (IFaceLogIf * iface, gint32* _return, const gint64 timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_count_log_light_by_verify_time (iface, timestamp, error))
    return FALSE;
  if (!i_face_log_client_recv_count_log_light_by_verify_time (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_count_log_light_by_verify_time_timestr (IFaceLogIf * iface, const gchar * timestamp, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "countLogLightByVerifyTimeTimestr", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "countLogLightByVerifyTimeTimestr_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_count_log_light_by_verify_time_timestr (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "countLogLightByVerifyTimeTimestr", 32) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected countLogLightByVerifyTimeTimestr", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_count_log_light_by_verify_time_timestr (IFaceLogIf * iface, gint32* _return, const gchar * timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_count_log_light_by_verify_time_timestr (iface, timestamp, error))
    return FALSE;
  if (!i_face_log_client_recv_count_log_light_by_verify_time_timestr (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_count_log_light_by_where (IFaceLogIf * iface, const gchar * where, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "countLogLightByWhere", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "countLogLightByWhere_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, where, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_count_log_light_by_where (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "countLogLightByWhere", 20) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected countLogLightByWhere", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_count_log_light_by_where (IFaceLogIf * iface, gint32* _return, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_count_log_light_by_where (iface, where, error))
    return FALSE;
  if (!i_face_log_client_recv_count_log_light_by_where (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_count_person_by_where (IFaceLogIf * iface, const gchar * where, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "countPersonByWhere", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "countPersonByWhere_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, where, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_count_person_by_where (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "countPersonByWhere", 18) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected countPersonByWhere", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_count_person_by_where (IFaceLogIf * iface, gint32* _return, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_count_person_by_where (iface, where, error))
    return FALSE;
  if (!i_face_log_client_recv_count_person_by_where (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_count_person_group_by_where (IFaceLogIf * iface, const gchar * where, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "countPersonGroupByWhere", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "countPersonGroupByWhere_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, where, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_count_person_group_by_where (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "countPersonGroupByWhere", 23) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected countPersonGroupByWhere", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_count_person_group_by_where (IFaceLogIf * iface, gint32* _return, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_count_person_group_by_where (iface, where, error))
    return FALSE;
  if (!i_face_log_client_recv_count_person_group_by_where (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_delete_all_features_by_person_id (IFaceLogIf * iface, const gint32 personId, const gboolean deleteImage, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "deleteAllFeaturesByPersonId", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "deleteAllFeaturesByPersonId_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deleteImage", T_BOOL, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, deleteImage, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_delete_all_features_by_person_id (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "deleteAllFeaturesByPersonId", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected deleteAllFeaturesByPersonId", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_delete_all_features_by_person_id (IFaceLogIf * iface, gint32* _return, const gint32 personId, const gboolean deleteImage, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_delete_all_features_by_person_id (iface, personId, deleteImage, token, error))
    return FALSE;
  if (!i_face_log_client_recv_delete_all_features_by_person_id (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_delete_device_group (IFaceLogIf * iface, const gint32 deviceGroupId, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "deleteDeviceGroup", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "deleteDeviceGroup_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_delete_device_group (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "deleteDeviceGroup", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected deleteDeviceGroup", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_delete_device_group (IFaceLogIf * iface, gint32* _return, const gint32 deviceGroupId, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_delete_device_group (iface, deviceGroupId, token, error))
    return FALSE;
  if (!i_face_log_client_recv_delete_device_group (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_delete_feature (IFaceLogIf * iface, const gchar * featureMd5, const gboolean deleteImage, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "deleteFeature", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "deleteFeature_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "featureMd5", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, featureMd5, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deleteImage", T_BOOL, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, deleteImage, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_delete_feature (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "deleteFeature", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected deleteFeature", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem186 = NULL;
                if (_elem186 != NULL)
                {
                  g_free(_elem186);
                  _elem186 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem186, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem186);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_delete_feature (IFaceLogIf * iface, GPtrArray ** _return, const gchar * featureMd5, const gboolean deleteImage, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_delete_feature (iface, featureMd5, deleteImage, token, error))
    return FALSE;
  if (!i_face_log_client_recv_delete_feature (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_delete_group_permit_on_device_group (IFaceLogIf * iface, const gint32 deviceGroupId, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "deleteGroupPermitOnDeviceGroup", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "deleteGroupPermitOnDeviceGroup_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_delete_group_permit_on_device_group (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "deleteGroupPermitOnDeviceGroup", 30) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected deleteGroupPermitOnDeviceGroup", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_delete_group_permit_on_device_group (IFaceLogIf * iface, gint32* _return, const gint32 deviceGroupId, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_delete_group_permit_on_device_group (iface, deviceGroupId, token, error))
    return FALSE;
  if (!i_face_log_client_recv_delete_group_permit_on_device_group (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_delete_image (IFaceLogIf * iface, const gchar * imageMd5, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "deleteImage", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "deleteImage_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "imageMd5", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, imageMd5, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_delete_image (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "deleteImage", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected deleteImage", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_delete_image (IFaceLogIf * iface, gint32* _return, const gchar * imageMd5, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_delete_image (iface, imageMd5, token, error))
    return FALSE;
  if (!i_face_log_client_recv_delete_image (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_delete_permit_by_id (IFaceLogIf * iface, const gint32 deviceGroupId, const gint32 personGroupId, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "deletePermitById", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "deletePermitById_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_delete_permit_by_id (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "deletePermitById", 16) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected deletePermitById", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_delete_permit_by_id (IFaceLogIf * iface, gint32* _return, const gint32 deviceGroupId, const gint32 personGroupId, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_delete_permit_by_id (iface, deviceGroupId, personGroupId, token, error))
    return FALSE;
  if (!i_face_log_client_recv_delete_permit_by_id (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_delete_person (IFaceLogIf * iface, const gint32 personId, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "deletePerson", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "deletePerson_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_delete_person (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "deletePerson", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected deletePerson", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_delete_person (IFaceLogIf * iface, gint32* _return, const gint32 personId, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_delete_person (iface, personId, token, error))
    return FALSE;
  if (!i_face_log_client_recv_delete_person (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_delete_person_by_papers_num (IFaceLogIf * iface, const gchar * papersNum, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "deletePersonByPapersNum", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "deletePersonByPapersNum_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "papersNum", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, papersNum, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_delete_person_by_papers_num (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "deletePersonByPapersNum", 23) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected deletePersonByPapersNum", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_delete_person_by_papers_num (IFaceLogIf * iface, gint32* _return, const gchar * papersNum, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_delete_person_by_papers_num (iface, papersNum, token, error))
    return FALSE;
  if (!i_face_log_client_recv_delete_person_by_papers_num (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_delete_person_group (IFaceLogIf * iface, const gint32 personGroupId, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "deletePersonGroup", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "deletePersonGroup_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_delete_person_group (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "deletePersonGroup", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected deletePersonGroup", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_delete_person_group (IFaceLogIf * iface, gint32* _return, const gint32 personGroupId, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_delete_person_group (iface, personGroupId, token, error))
    return FALSE;
  if (!i_face_log_client_recv_delete_person_group (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_delete_person_group_permit (IFaceLogIf * iface, const gint32 personGroupId, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "deletePersonGroupPermit", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "deletePersonGroupPermit_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_delete_person_group_permit (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "deletePersonGroupPermit", 23) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected deletePersonGroupPermit", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_delete_person_group_permit (IFaceLogIf * iface, gint32* _return, const gint32 personGroupId, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_delete_person_group_permit (iface, personGroupId, token, error))
    return FALSE;
  if (!i_face_log_client_recv_delete_person_group_permit (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_delete_persons (IFaceLogIf * iface, const GArray * personIdList, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "deletePersons", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "deletePersons_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personIdList", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i187;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (personIdList ? personIdList->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i187 = 0; i187 < (personIdList ? personIdList->len : 0); i187++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (personIdList, gint32, i187)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_delete_persons (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "deletePersons", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected deletePersons", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_delete_persons (IFaceLogIf * iface, gint32* _return, const GArray * personIdList, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_delete_persons (iface, personIdList, token, error))
    return FALSE;
  if (!i_face_log_client_recv_delete_persons (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_delete_persons_by_papers_num (IFaceLogIf * iface, const GPtrArray * papersNumlist, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "deletePersonsByPapersNum", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "deletePersonsByPapersNum_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "papersNumlist", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i188;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (papersNumlist ? papersNumlist->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i188 = 0; i188 < (papersNumlist ? papersNumlist->len : 0); i188++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) papersNumlist, i188)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_delete_persons_by_papers_num (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "deletePersonsByPapersNum", 24) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected deletePersonsByPapersNum", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_delete_persons_by_papers_num (IFaceLogIf * iface, gint32* _return, const GPtrArray * papersNumlist, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_delete_persons_by_papers_num (iface, papersNumlist, token, error))
    return FALSE;
  if (!i_face_log_client_recv_delete_persons_by_papers_num (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_disable_person (IFaceLogIf * iface, const gint32 personId, const gint32 moveToGroupId, const gboolean deletePhoto, const gboolean deleteFeature, const gboolean deleteLog, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "disablePerson", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "disablePerson_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "moveToGroupId", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, moveToGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deletePhoto", T_BOOL, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, deletePhoto, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deleteFeature", T_BOOL, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, deleteFeature, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deleteLog", T_BOOL, 5, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, deleteLog, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 6, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_disable_person (IFaceLogIf * iface, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "disablePerson", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected disablePerson", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_disable_person (IFaceLogIf * iface, const gint32 personId, const gint32 moveToGroupId, const gboolean deletePhoto, const gboolean deleteFeature, const gboolean deleteLog, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_disable_person (iface, personId, moveToGroupId, deletePhoto, deleteFeature, deleteLog, token, error))
    return FALSE;
  if (!i_face_log_client_recv_disable_person (iface, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_disable_person_list (IFaceLogIf * iface, const GArray * personIdList, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "disablePersonList", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "disablePersonList_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personIdList", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i189;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (personIdList ? personIdList->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i189 = 0; i189 < (personIdList ? personIdList->len : 0); i189++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (personIdList, gint32, i189)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_disable_person_list (IFaceLogIf * iface, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "disablePersonList", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected disablePersonList", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_disable_person_list (IFaceLogIf * iface, const GArray * personIdList, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_disable_person_list (iface, personIdList, token, error))
    return FALSE;
  if (!i_face_log_client_recv_disable_person_list (iface, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_exists_device (IFaceLogIf * iface, const gint32 id, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "existsDevice", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "existsDevice_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, id, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_exists_device (IFaceLogIf * iface, gboolean* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "existsDevice", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected existsDevice", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_exists_device (IFaceLogIf * iface, gboolean* _return, const gint32 id, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_exists_device (iface, id, error))
    return FALSE;
  if (!i_face_log_client_recv_exists_device (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_exists_feature (IFaceLogIf * iface, const gchar * md5, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "existsFeature", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "existsFeature_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "md5", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, md5, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_exists_feature (IFaceLogIf * iface, gboolean* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "existsFeature", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected existsFeature", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_exists_feature (IFaceLogIf * iface, gboolean* _return, const gchar * md5, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_exists_feature (iface, md5, error))
    return FALSE;
  if (!i_face_log_client_recv_exists_feature (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_exists_image (IFaceLogIf * iface, const gchar * md5, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "existsImage", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "existsImage_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "md5", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, md5, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_exists_image (IFaceLogIf * iface, gboolean* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "existsImage", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected existsImage", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_exists_image (IFaceLogIf * iface, gboolean* _return, const gchar * md5, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_exists_image (iface, md5, error))
    return FALSE;
  if (!i_face_log_client_recv_exists_image (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_exists_person (IFaceLogIf * iface, const gint32 persionId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "existsPerson", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "existsPerson_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "persionId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, persionId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_exists_person (IFaceLogIf * iface, gboolean* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "existsPerson", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected existsPerson", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_exists_person (IFaceLogIf * iface, gboolean* _return, const gint32 persionId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_exists_person (iface, persionId, error))
    return FALSE;
  if (!i_face_log_client_recv_exists_person (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_device (IFaceLogIf * iface, const gint32 deviceId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getDevice", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getDevice_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_device (IFaceLogIf * iface, DeviceBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getDevice", 9) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getDevice", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_device (IFaceLogIf * iface, DeviceBean ** _return, const gint32 deviceId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_device (iface, deviceId, error))
    return FALSE;
  if (!i_face_log_client_recv_get_device (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_device_by_mac (IFaceLogIf * iface, const gchar * mac, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getDeviceByMac", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getDeviceByMac_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "mac", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, mac, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_device_by_mac (IFaceLogIf * iface, DeviceBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getDeviceByMac", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getDeviceByMac", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_device_by_mac (IFaceLogIf * iface, DeviceBean ** _return, const gchar * mac, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_device_by_mac (iface, mac, error))
    return FALSE;
  if (!i_face_log_client_recv_get_device_by_mac (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_device_group (IFaceLogIf * iface, const gint32 deviceGroupId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getDeviceGroup", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getDeviceGroup_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_device_group (IFaceLogIf * iface, DeviceGroupBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getDeviceGroup", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getDeviceGroup", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_device_group (IFaceLogIf * iface, DeviceGroupBean ** _return, const gint32 deviceGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_device_group (iface, deviceGroupId, error))
    return FALSE;
  if (!i_face_log_client_recv_get_device_group (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_device_groups (IFaceLogIf * iface, const GArray * groupIdList, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getDeviceGroups", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getDeviceGroups_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "groupIdList", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i190;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (groupIdList ? groupIdList->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i190 = 0; i190 < (groupIdList ? groupIdList->len : 0); i190++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (groupIdList, gint32, i190)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_device_groups (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getDeviceGroups", 15) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getDeviceGroups", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                DeviceGroupBean * _elem191 = NULL;
                if ( _elem191 != NULL)
                {
                  g_object_unref (_elem191);
                }
                _elem191 = g_object_new (TYPE_DEVICE_GROUP_BEAN, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem191), protocol, error)) < 0)
                {
                  g_object_unref (_elem191);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem191);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_device_groups (IFaceLogIf * iface, GPtrArray ** _return, const GArray * groupIdList, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_device_groups (iface, groupIdList, error))
    return FALSE;
  if (!i_face_log_client_recv_get_device_groups (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_device_groups_belongs (IFaceLogIf * iface, const gint32 deviceId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getDeviceGroupsBelongs", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getDeviceGroupsBelongs_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_device_groups_belongs (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getDeviceGroupsBelongs", 22) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getDeviceGroupsBelongs", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem192 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem192, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem192, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_device_groups_belongs (IFaceLogIf * iface, GArray ** _return, const gint32 deviceId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_device_groups_belongs (iface, deviceId, error))
    return FALSE;
  if (!i_face_log_client_recv_get_device_groups_belongs (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_device_groups_permit (IFaceLogIf * iface, const gint32 personGroupId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getDeviceGroupsPermit", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getDeviceGroupsPermit_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_device_groups_permit (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getDeviceGroupsPermit", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getDeviceGroupsPermit", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem193 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem193, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem193, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_device_groups_permit (IFaceLogIf * iface, GArray ** _return, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_device_groups_permit (iface, personGroupId, error))
    return FALSE;
  if (!i_face_log_client_recv_get_device_groups_permit (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_device_groups_permitted_by (IFaceLogIf * iface, const gint32 personGroupId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getDeviceGroupsPermittedBy", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getDeviceGroupsPermittedBy_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_device_groups_permitted_by (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getDeviceGroupsPermittedBy", 26) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getDeviceGroupsPermittedBy", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem194 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem194, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem194, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_device_groups_permitted_by (IFaceLogIf * iface, GArray ** _return, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_device_groups_permitted_by (iface, personGroupId, error))
    return FALSE;
  if (!i_face_log_client_recv_get_device_groups_permitted_by (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_device_id_of_feature (IFaceLogIf * iface, const gchar * featureMd5, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getDeviceIdOfFeature", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getDeviceIdOfFeature_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "featureMd5", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, featureMd5, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_device_id_of_feature (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getDeviceIdOfFeature", 20) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getDeviceIdOfFeature", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_device_id_of_feature (IFaceLogIf * iface, gint32* _return, const gchar * featureMd5, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_device_id_of_feature (iface, featureMd5, error))
    return FALSE;
  if (!i_face_log_client_recv_get_device_id_of_feature (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_devices (IFaceLogIf * iface, const GArray * idList, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getDevices", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getDevices_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "idList", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i195;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (idList ? idList->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i195 = 0; i195 < (idList ? idList->len : 0); i195++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (idList, gint32, i195)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_devices (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getDevices", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getDevices", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                DeviceBean * _elem196 = NULL;
                if ( _elem196 != NULL)
                {
                  g_object_unref (_elem196);
                }
                _elem196 = g_object_new (TYPE_DEVICE_BEAN, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem196), protocol, error)) < 0)
                {
                  g_object_unref (_elem196);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem196);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_devices (IFaceLogIf * iface, GPtrArray ** _return, const GArray * idList, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_devices (iface, idList, error))
    return FALSE;
  if (!i_face_log_client_recv_get_devices (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_devices_of_group (IFaceLogIf * iface, const gint32 deviceGroupId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getDevicesOfGroup", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getDevicesOfGroup_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_devices_of_group (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getDevicesOfGroup", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getDevicesOfGroup", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem197 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem197, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem197, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_devices_of_group (IFaceLogIf * iface, GArray ** _return, const gint32 deviceGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_devices_of_group (iface, deviceGroupId, error))
    return FALSE;
  if (!i_face_log_client_recv_get_devices_of_group (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_face (IFaceLogIf * iface, const gint32 faceId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getFace", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getFace_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "faceId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, faceId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_face (IFaceLogIf * iface, FaceBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getFace", 7) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getFace", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_face (IFaceLogIf * iface, FaceBean ** _return, const gint32 faceId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_face (iface, faceId, error))
    return FALSE;
  if (!i_face_log_client_recv_get_face (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_feature (IFaceLogIf * iface, const gchar * md5, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getFeature", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getFeature_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "md5", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, md5, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_feature (IFaceLogIf * iface, FeatureBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getFeature", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getFeature", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_feature (IFaceLogIf * iface, FeatureBean ** _return, const gchar * md5, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_feature (iface, md5, error))
    return FALSE;
  if (!i_face_log_client_recv_get_feature (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_feature_bytes (IFaceLogIf * iface, const gchar * md5, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getFeatureBytes", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getFeatureBytes_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "md5", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, md5, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_feature_bytes (IFaceLogIf * iface, GByteArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getFeatureBytes", 15) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getFeatureBytes", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
              return 0;
            xfer += ret;
            *_return = g_byte_array_new();
            g_byte_array_append (*_return, (guint8 *) data, (guint) len);
            g_free (data);
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_feature_bytes (IFaceLogIf * iface, GByteArray ** _return, const gchar * md5, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_feature_bytes (iface, md5, error))
    return FALSE;
  if (!i_face_log_client_recv_get_feature_bytes (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_features (IFaceLogIf * iface, const GPtrArray * md5, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getFeatures", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getFeatures_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "md5", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i198;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (md5 ? md5->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i198 = 0; i198 < (md5 ? md5->len : 0); i198++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) md5, i198)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_features (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getFeatures", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getFeatures", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                FeatureBean * _elem199 = NULL;
                if ( _elem199 != NULL)
                {
                  g_object_unref (_elem199);
                }
                _elem199 = g_object_new (TYPE_FEATURE_BEAN, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem199), protocol, error)) < 0)
                {
                  g_object_unref (_elem199);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem199);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_features (IFaceLogIf * iface, GPtrArray ** _return, const GPtrArray * md5, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_features (iface, md5, error))
    return FALSE;
  if (!i_face_log_client_recv_get_features (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_features_by_person_id_and_sdk_version (IFaceLogIf * iface, const gint32 personId, const gchar * sdkVersion, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getFeaturesByPersonIdAndSdkVersion", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getFeaturesByPersonIdAndSdkVersion_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "sdkVersion", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, sdkVersion, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_features_by_person_id_and_sdk_version (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getFeaturesByPersonIdAndSdkVersion", 34) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getFeaturesByPersonIdAndSdkVersion", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem200 = NULL;
                if (_elem200 != NULL)
                {
                  g_free(_elem200);
                  _elem200 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem200, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem200);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_features_by_person_id_and_sdk_version (IFaceLogIf * iface, GPtrArray ** _return, const gint32 personId, const gchar * sdkVersion, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_features_by_person_id_and_sdk_version (iface, personId, sdkVersion, error))
    return FALSE;
  if (!i_face_log_client_recv_get_features_by_person_id_and_sdk_version (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_features_of_person (IFaceLogIf * iface, const gint32 personId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getFeaturesOfPerson", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getFeaturesOfPerson_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_features_of_person (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getFeaturesOfPerson", 19) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getFeaturesOfPerson", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem201 = NULL;
                if (_elem201 != NULL)
                {
                  g_free(_elem201);
                  _elem201 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem201, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem201);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_features_of_person (IFaceLogIf * iface, GPtrArray ** _return, const gint32 personId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_features_of_person (iface, personId, error))
    return FALSE;
  if (!i_face_log_client_recv_get_features_of_person (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_features_permitted_on_device (IFaceLogIf * iface, const gint32 deviceId, const gboolean ignoreSchedule, const gchar * sdkVersion, const GPtrArray * excludeFeatureIds, const gint64 timestamp, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getFeaturesPermittedOnDevice", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getFeaturesPermittedOnDevice_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "ignoreSchedule", T_BOOL, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, ignoreSchedule, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "sdkVersion", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, sdkVersion, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "excludeFeatureIds", T_LIST, 4, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i202;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (excludeFeatureIds ? excludeFeatureIds->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i202 = 0; i202 < (excludeFeatureIds ? excludeFeatureIds->len : 0); i202++)
      {
        if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) excludeFeatureIds, i202)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 5, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_features_permitted_on_device (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getFeaturesPermittedOnDevice", 28) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getFeaturesPermittedOnDevice", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem203 = NULL;
                if (_elem203 != NULL)
                {
                  g_free(_elem203);
                  _elem203 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem203, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem203);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_features_permitted_on_device (IFaceLogIf * iface, GPtrArray ** _return, const gint32 deviceId, const gboolean ignoreSchedule, const gchar * sdkVersion, const GPtrArray * excludeFeatureIds, const gint64 timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_features_permitted_on_device (iface, deviceId, ignoreSchedule, sdkVersion, excludeFeatureIds, timestamp, error))
    return FALSE;
  if (!i_face_log_client_recv_get_features_permitted_on_device (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_group_permit (IFaceLogIf * iface, const gint32 deviceId, const gint32 personGroupId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getGroupPermit", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getGroupPermit_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_group_permit (IFaceLogIf * iface, PermitBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getGroupPermit", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getGroupPermit", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_group_permit (IFaceLogIf * iface, PermitBean ** _return, const gint32 deviceId, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_group_permit (iface, deviceId, personGroupId, error))
    return FALSE;
  if (!i_face_log_client_recv_get_group_permit (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_group_permit_on_device_group (IFaceLogIf * iface, const gint32 deviceGroupId, const gint32 personGroupId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getGroupPermitOnDeviceGroup", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getGroupPermitOnDeviceGroup_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_group_permit_on_device_group (IFaceLogIf * iface, PermitBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getGroupPermitOnDeviceGroup", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getGroupPermitOnDeviceGroup", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_group_permit_on_device_group (IFaceLogIf * iface, PermitBean ** _return, const gint32 deviceGroupId, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_group_permit_on_device_group (iface, deviceGroupId, personGroupId, error))
    return FALSE;
  if (!i_face_log_client_recv_get_group_permit_on_device_group (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_group_permits (IFaceLogIf * iface, const gint32 deviceId, const GArray * personGroupIdList, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getGroupPermits", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getGroupPermits_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupIdList", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i204;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (personGroupIdList ? personGroupIdList->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i204 = 0; i204 < (personGroupIdList ? personGroupIdList->len : 0); i204++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (personGroupIdList, gint32, i204)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_group_permits (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getGroupPermits", 15) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getGroupPermits", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                PermitBean * _elem205 = NULL;
                if ( _elem205 != NULL)
                {
                  g_object_unref (_elem205);
                }
                _elem205 = g_object_new (TYPE_PERMIT_BEAN, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem205), protocol, error)) < 0)
                {
                  g_object_unref (_elem205);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem205);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_group_permits (IFaceLogIf * iface, GPtrArray ** _return, const gint32 deviceId, const GArray * personGroupIdList, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_group_permits (iface, deviceId, personGroupIdList, error))
    return FALSE;
  if (!i_face_log_client_recv_get_group_permits (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_image (IFaceLogIf * iface, const gchar * imageMD5, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getImage", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getImage_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "imageMD5", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, imageMD5, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_image (IFaceLogIf * iface, ImageBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getImage", 8) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getImage", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_image (IFaceLogIf * iface, ImageBean ** _return, const gchar * imageMD5, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_image (iface, imageMD5, error))
    return FALSE;
  if (!i_face_log_client_recv_get_image (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_image_bytes (IFaceLogIf * iface, const gchar * imageMD5, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getImageBytes", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getImageBytes_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "imageMD5", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, imageMD5, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_image_bytes (IFaceLogIf * iface, GByteArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getImageBytes", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getImageBytes", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
              return 0;
            xfer += ret;
            *_return = g_byte_array_new();
            g_byte_array_append (*_return, (guint8 *) data, (guint) len);
            g_free (data);
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_image_bytes (IFaceLogIf * iface, GByteArray ** _return, const gchar * imageMD5, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_image_bytes (iface, imageMD5, error))
    return FALSE;
  if (!i_face_log_client_recv_get_image_bytes (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_images_associated_by_feature (IFaceLogIf * iface, const gchar * featureMd5, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getImagesAssociatedByFeature", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getImagesAssociatedByFeature_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "featureMd5", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, featureMd5, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_images_associated_by_feature (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getImagesAssociatedByFeature", 28) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getImagesAssociatedByFeature", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem206 = NULL;
                if (_elem206 != NULL)
                {
                  g_free(_elem206);
                  _elem206 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem206, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem206);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_images_associated_by_feature (IFaceLogIf * iface, GPtrArray ** _return, const gchar * featureMd5, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_images_associated_by_feature (iface, featureMd5, error))
    return FALSE;
  if (!i_face_log_client_recv_get_images_associated_by_feature (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_log_beans_by_person_id (IFaceLogIf * iface, const gint32 personId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getLogBeansByPersonId", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getLogBeansByPersonId_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_log_beans_by_person_id (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getLogBeansByPersonId", 21) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getLogBeansByPersonId", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                LogBean * _elem207 = NULL;
                if ( _elem207 != NULL)
                {
                  g_object_unref (_elem207);
                }
                _elem207 = g_object_new (TYPE_LOG_BEAN, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem207), protocol, error)) < 0)
                {
                  g_object_unref (_elem207);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem207);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_log_beans_by_person_id (IFaceLogIf * iface, GPtrArray ** _return, const gint32 personId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_log_beans_by_person_id (iface, personId, error))
    return FALSE;
  if (!i_face_log_client_recv_get_log_beans_by_person_id (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_person (IFaceLogIf * iface, const gint32 personId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPerson", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPerson_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_person (IFaceLogIf * iface, PersonBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPerson", 9) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPerson", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_person (IFaceLogIf * iface, PersonBean ** _return, const gint32 personId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_person (iface, personId, error))
    return FALSE;
  if (!i_face_log_client_recv_get_person (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_person_by_mobile_phone (IFaceLogIf * iface, const gchar * mobilePhone, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPersonByMobilePhone", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPersonByMobilePhone_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "mobilePhone", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, mobilePhone, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_person_by_mobile_phone (IFaceLogIf * iface, PersonBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPersonByMobilePhone", 22) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPersonByMobilePhone", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_person_by_mobile_phone (IFaceLogIf * iface, PersonBean ** _return, const gchar * mobilePhone, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_person_by_mobile_phone (iface, mobilePhone, error))
    return FALSE;
  if (!i_face_log_client_recv_get_person_by_mobile_phone (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_person_by_papers_num (IFaceLogIf * iface, const gchar * papersNum, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPersonByPapersNum", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPersonByPapersNum_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "papersNum", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, papersNum, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_person_by_papers_num (IFaceLogIf * iface, PersonBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPersonByPapersNum", 20) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPersonByPapersNum", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_person_by_papers_num (IFaceLogIf * iface, PersonBean ** _return, const gchar * papersNum, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_person_by_papers_num (iface, papersNum, error))
    return FALSE;
  if (!i_face_log_client_recv_get_person_by_papers_num (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_person_group (IFaceLogIf * iface, const gint32 personGroupId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPersonGroup", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPersonGroup_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_person_group (IFaceLogIf * iface, PersonGroupBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPersonGroup", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPersonGroup", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_person_group (IFaceLogIf * iface, PersonGroupBean ** _return, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_person_group (iface, personGroupId, error))
    return FALSE;
  if (!i_face_log_client_recv_get_person_group (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_person_groups (IFaceLogIf * iface, const GArray * groupIdList, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPersonGroups", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPersonGroups_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "groupIdList", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i208;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (groupIdList ? groupIdList->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i208 = 0; i208 < (groupIdList ? groupIdList->len : 0); i208++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (groupIdList, gint32, i208)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_person_groups (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPersonGroups", 15) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPersonGroups", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                PersonGroupBean * _elem209 = NULL;
                if ( _elem209 != NULL)
                {
                  g_object_unref (_elem209);
                }
                _elem209 = g_object_new (TYPE_PERSON_GROUP_BEAN, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem209), protocol, error)) < 0)
                {
                  g_object_unref (_elem209);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem209);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_person_groups (IFaceLogIf * iface, GPtrArray ** _return, const GArray * groupIdList, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_person_groups (iface, groupIdList, error))
    return FALSE;
  if (!i_face_log_client_recv_get_person_groups (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_person_groups_belongs (IFaceLogIf * iface, const gint32 personId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPersonGroupsBelongs", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPersonGroupsBelongs_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_person_groups_belongs (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPersonGroupsBelongs", 22) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPersonGroupsBelongs", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem210 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem210, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem210, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_person_groups_belongs (IFaceLogIf * iface, GArray ** _return, const gint32 personId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_person_groups_belongs (iface, personId, error))
    return FALSE;
  if (!i_face_log_client_recv_get_person_groups_belongs (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_person_groups_permitted_by (IFaceLogIf * iface, const gint32 deviceGroupId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPersonGroupsPermittedBy", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPersonGroupsPermittedBy_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_person_groups_permitted_by (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPersonGroupsPermittedBy", 26) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPersonGroupsPermittedBy", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem211 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem211, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem211, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_person_groups_permitted_by (IFaceLogIf * iface, GArray ** _return, const gint32 deviceGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_person_groups_permitted_by (iface, deviceGroupId, error))
    return FALSE;
  if (!i_face_log_client_recv_get_person_groups_permitted_by (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_person_permit (IFaceLogIf * iface, const gint32 deviceId, const gint32 personId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPersonPermit", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPersonPermit_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_person_permit (IFaceLogIf * iface, PermitBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPersonPermit", 15) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPersonPermit", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_person_permit (IFaceLogIf * iface, PermitBean ** _return, const gint32 deviceId, const gint32 personId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_person_permit (iface, deviceId, personId, error))
    return FALSE;
  if (!i_face_log_client_recv_get_person_permit (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_person_permits (IFaceLogIf * iface, const gint32 deviceId, const GArray * personIdList, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPersonPermits", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPersonPermits_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personIdList", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i212;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (personIdList ? personIdList->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i212 = 0; i212 < (personIdList ? personIdList->len : 0); i212++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (personIdList, gint32, i212)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_person_permits (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPersonPermits", 16) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPersonPermits", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                PermitBean * _elem213 = NULL;
                if ( _elem213 != NULL)
                {
                  g_object_unref (_elem213);
                }
                _elem213 = g_object_new (TYPE_PERMIT_BEAN, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem213), protocol, error)) < 0)
                {
                  g_object_unref (_elem213);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem213);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_person_permits (IFaceLogIf * iface, GPtrArray ** _return, const gint32 deviceId, const GArray * personIdList, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_person_permits (iface, deviceId, personIdList, error))
    return FALSE;
  if (!i_face_log_client_recv_get_person_permits (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_persons (IFaceLogIf * iface, const GArray * idList, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPersons", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPersons_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "idList", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i214;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (idList ? idList->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i214 = 0; i214 < (idList ? idList->len : 0); i214++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (idList, gint32, i214)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_persons (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPersons", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPersons", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                PersonBean * _elem215 = NULL;
                if ( _elem215 != NULL)
                {
                  g_object_unref (_elem215);
                }
                _elem215 = g_object_new (TYPE_PERSON_BEAN, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem215), protocol, error)) < 0)
                {
                  g_object_unref (_elem215);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem215);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_persons (IFaceLogIf * iface, GPtrArray ** _return, const GArray * idList, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_persons (iface, idList, error))
    return FALSE;
  if (!i_face_log_client_recv_get_persons (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_persons_of_group (IFaceLogIf * iface, const gint32 personGroupId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPersonsOfGroup", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPersonsOfGroup_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_persons_of_group (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPersonsOfGroup", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPersonsOfGroup", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem216 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem216, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem216, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_persons_of_group (IFaceLogIf * iface, GArray ** _return, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_persons_of_group (iface, personGroupId, error))
    return FALSE;
  if (!i_face_log_client_recv_get_persons_of_group (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_persons_permitted_on_device (IFaceLogIf * iface, const gint32 deviceId, const gboolean ignoreSchedule, const GArray * excludePersonIds, const gint64 timestamp, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getPersonsPermittedOnDevice", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getPersonsPermittedOnDevice_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "ignoreSchedule", T_BOOL, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, ignoreSchedule, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "excludePersonIds", T_LIST, 3, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i217;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (excludePersonIds ? excludePersonIds->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i217 = 0; i217 < (excludePersonIds ? excludePersonIds->len : 0); i217++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (excludePersonIds, gint32, i217)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_persons_permitted_on_device (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getPersonsPermittedOnDevice", 27) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getPersonsPermittedOnDevice", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem218 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem218, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem218, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_persons_permitted_on_device (IFaceLogIf * iface, GArray ** _return, const gint32 deviceId, const gboolean ignoreSchedule, const GArray * excludePersonIds, const gint64 timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_persons_permitted_on_device (iface, deviceId, ignoreSchedule, excludePersonIds, timestamp, error))
    return FALSE;
  if (!i_face_log_client_recv_get_persons_permitted_on_device (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_properties (IFaceLogIf * iface, const gchar * prefix, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getProperties", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getProperties_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "prefix", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, prefix, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_properties (IFaceLogIf * iface, GHashTable ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getProperties", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getProperties", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_MAP)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType key_type;
              ThriftType value_type;

              /* read the map begin marker */
              if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through each of the map's fields */
              for (i = 0; i < size; i++)
              {
                gchar * key219 = NULL;
                gchar * val220 = NULL;
                if (key219 != NULL)
                {
                  g_free(key219);
                  key219 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &key219, error)) < 0)
                  return 0;
                xfer += ret;
                if (val220 != NULL)
                {
                  g_free(val220);
                  val220 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &val220, error)) < 0)
                  return 0;
                xfer += ret;
                if (*_return && key219)
                  g_hash_table_insert ((GHashTable *)*_return, (gpointer) key219, (gpointer) val220);
              }

              /* read the map end marker */
              if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_properties (IFaceLogIf * iface, GHashTable ** _return, const gchar * prefix, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_properties (iface, prefix, token, error))
    return FALSE;
  if (!i_face_log_client_recv_get_properties (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_property (IFaceLogIf * iface, const gchar * key, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getProperty", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getProperty_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, key, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_property (IFaceLogIf * iface, gchar ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getProperty", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getProperty", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_property (IFaceLogIf * iface, gchar ** _return, const gchar * key, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_property (iface, key, token, error))
    return FALSE;
  if (!i_face_log_client_recv_get_property (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_redis_parameters (IFaceLogIf * iface, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getRedisParameters", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getRedisParameters_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_redis_parameters (IFaceLogIf * iface, GHashTable ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getRedisParameters", 18) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getRedisParameters", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_MAP)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType key_type;
              ThriftType value_type;

              /* read the map begin marker */
              if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through each of the map's fields */
              for (i = 0; i < size; i++)
              {
                MQParam key221;
                gchar * val222 = NULL;
                gint32 ecast223;
                if ((ret = thrift_protocol_read_i32 (protocol, &ecast223, error)) < 0)
                  return 0;
                xfer += ret;
                key221 = (MQParam)ecast223;
                if (val222 != NULL)
                {
                  g_free(val222);
                  val222 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &val222, error)) < 0)
                  return 0;
                xfer += ret;
                if (*_return && key221)
                  g_hash_table_insert ((GHashTable *)*_return, (gpointer) key221, (gpointer) val222);
              }

              /* read the map end marker */
              if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_redis_parameters (IFaceLogIf * iface, GHashTable ** _return, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_redis_parameters (iface, token, error))
    return FALSE;
  if (!i_face_log_client_recv_get_redis_parameters (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_service_config (IFaceLogIf * iface, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getServiceConfig", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getServiceConfig_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_service_config (IFaceLogIf * iface, GHashTable ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getServiceConfig", 16) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getServiceConfig", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_MAP)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType key_type;
              ThriftType value_type;

              /* read the map begin marker */
              if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through each of the map's fields */
              for (i = 0; i < size; i++)
              {
                gchar * key224 = NULL;
                gchar * val225 = NULL;
                if (key224 != NULL)
                {
                  g_free(key224);
                  key224 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &key224, error)) < 0)
                  return 0;
                xfer += ret;
                if (val225 != NULL)
                {
                  g_free(val225);
                  val225 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &val225, error)) < 0)
                  return 0;
                xfer += ret;
                if (*_return && key224)
                  g_hash_table_insert ((GHashTable *)*_return, (gpointer) key224, (gpointer) val225);
              }

              /* read the map end marker */
              if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_service_config (IFaceLogIf * iface, GHashTable ** _return, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_service_config (iface, token, error))
    return FALSE;
  if (!i_face_log_client_recv_get_service_config (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_sub_device_group (IFaceLogIf * iface, const gint32 deviceGroupId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getSubDeviceGroup", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getSubDeviceGroup_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_sub_device_group (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getSubDeviceGroup", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getSubDeviceGroup", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem226 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem226, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem226, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_sub_device_group (IFaceLogIf * iface, GArray ** _return, const gint32 deviceGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_sub_device_group (iface, deviceGroupId, error))
    return FALSE;
  if (!i_face_log_client_recv_get_sub_device_group (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_get_sub_person_group (IFaceLogIf * iface, const gint32 personGroupId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "getSubPersonGroup", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "getSubPersonGroup_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_get_sub_person_group (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "getSubPersonGroup", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected getSubPersonGroup", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem227 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem227, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem227, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_get_sub_person_group (IFaceLogIf * iface, GArray ** _return, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_get_sub_person_group (iface, personGroupId, error))
    return FALSE;
  if (!i_face_log_client_recv_get_sub_person_group (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_is_disable (IFaceLogIf * iface, const gint32 personId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "isDisable", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "isDisable_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_is_disable (IFaceLogIf * iface, gboolean* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "isDisable", 9) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected isDisable", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_is_disable (IFaceLogIf * iface, gboolean* _return, const gint32 personId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_is_disable (iface, personId, error))
    return FALSE;
  if (!i_face_log_client_recv_is_disable (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_is_local (IFaceLogIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "isLocal", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "isLocal_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_is_local (IFaceLogIf * iface, gboolean* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "isLocal", 7) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected isLocal", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_is_local (IFaceLogIf * iface, gboolean* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_is_local (iface, error))
    return FALSE;
  if (!i_face_log_client_recv_is_local (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_is_valid_ack_channel (IFaceLogIf * iface, const gchar * ackChannel, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "isValidAckChannel", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "isValidAckChannel_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "ackChannel", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, ackChannel, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_is_valid_ack_channel (IFaceLogIf * iface, gboolean* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "isValidAckChannel", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected isValidAckChannel", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_is_valid_ack_channel (IFaceLogIf * iface, gboolean* _return, const gchar * ackChannel, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_is_valid_ack_channel (iface, ackChannel, error))
    return FALSE;
  if (!i_face_log_client_recv_is_valid_ack_channel (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_is_valid_cmd_sn (IFaceLogIf * iface, const gint32 cmdSn, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "isValidCmdSn", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "isValidCmdSn_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "cmdSn", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, cmdSn, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_is_valid_cmd_sn (IFaceLogIf * iface, gboolean* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "isValidCmdSn", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected isValidCmdSn", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_is_valid_cmd_sn (IFaceLogIf * iface, gboolean* _return, const gint32 cmdSn, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_is_valid_cmd_sn (iface, cmdSn, error))
    return FALSE;
  if (!i_face_log_client_recv_is_valid_cmd_sn (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_is_valid_device_token (IFaceLogIf * iface, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "isValidDeviceToken", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "isValidDeviceToken_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_is_valid_device_token (IFaceLogIf * iface, gboolean* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "isValidDeviceToken", 18) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected isValidDeviceToken", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_is_valid_device_token (IFaceLogIf * iface, gboolean* _return, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_is_valid_device_token (iface, token, error))
    return FALSE;
  if (!i_face_log_client_recv_is_valid_device_token (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_is_valid_password (IFaceLogIf * iface, const gchar * userId, const gchar * password, const gboolean isMd5, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "isValidPassword", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "isValidPassword_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "userId", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, userId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "password", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, password, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "isMd5", T_BOOL, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, isMd5, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_is_valid_password (IFaceLogIf * iface, gboolean* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "isValidPassword", 15) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected isValidPassword", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_is_valid_password (IFaceLogIf * iface, gboolean* _return, const gchar * userId, const gchar * password, const gboolean isMd5, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_is_valid_password (iface, userId, password, isMd5, error))
    return FALSE;
  if (!i_face_log_client_recv_is_valid_password (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_is_valid_person_token (IFaceLogIf * iface, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "isValidPersonToken", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "isValidPersonToken_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_is_valid_person_token (IFaceLogIf * iface, gboolean* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "isValidPersonToken", 18) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected isValidPersonToken", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_is_valid_person_token (IFaceLogIf * iface, gboolean* _return, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_is_valid_person_token (iface, token, error))
    return FALSE;
  if (!i_face_log_client_recv_is_valid_person_token (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_is_valid_root_token (IFaceLogIf * iface, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "isValidRootToken", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "isValidRootToken_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_is_valid_root_token (IFaceLogIf * iface, gboolean* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "isValidRootToken", 16) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected isValidRootToken", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_is_valid_root_token (IFaceLogIf * iface, gboolean* _return, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_is_valid_root_token (iface, token, error))
    return FALSE;
  if (!i_face_log_client_recv_is_valid_root_token (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_is_valid_token (IFaceLogIf * iface, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "isValidToken", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "isValidToken_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_is_valid_token (IFaceLogIf * iface, gboolean* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "isValidToken", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected isValidToken", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_is_valid_token (IFaceLogIf * iface, gboolean* _return, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_is_valid_token (iface, token, error))
    return FALSE;
  if (!i_face_log_client_recv_is_valid_token (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_is_valid_user_token (IFaceLogIf * iface, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "isValidUserToken", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "isValidUserToken_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_is_valid_user_token (IFaceLogIf * iface, gboolean* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "isValidUserToken", 16) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected isValidUserToken", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_BOOL)
          {
            if ((ret = thrift_protocol_read_bool (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_is_valid_user_token (IFaceLogIf * iface, gboolean* _return, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_is_valid_user_token (iface, token, error))
    return FALSE;
  if (!i_face_log_client_recv_is_valid_user_token (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_list_of_parent_for_device_group (IFaceLogIf * iface, const gint32 deviceGroupId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "listOfParentForDeviceGroup", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "listOfParentForDeviceGroup_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_list_of_parent_for_device_group (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "listOfParentForDeviceGroup", 26) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected listOfParentForDeviceGroup", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem228 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem228, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem228, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_list_of_parent_for_device_group (IFaceLogIf * iface, GArray ** _return, const gint32 deviceGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_list_of_parent_for_device_group (iface, deviceGroupId, error))
    return FALSE;
  if (!i_face_log_client_recv_list_of_parent_for_device_group (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_list_of_parent_for_person_group (IFaceLogIf * iface, const gint32 personGroupId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "listOfParentForPersonGroup", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "listOfParentForPersonGroup_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_list_of_parent_for_person_group (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "listOfParentForPersonGroup", 26) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected listOfParentForPersonGroup", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem229 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem229, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem229, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_list_of_parent_for_person_group (IFaceLogIf * iface, GArray ** _return, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_list_of_parent_for_person_group (iface, personGroupId, error))
    return FALSE;
  if (!i_face_log_client_recv_list_of_parent_for_person_group (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_all_person (IFaceLogIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadAllPerson", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadAllPerson_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_all_person (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadAllPerson", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadAllPerson", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem230 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem230, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem230, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_all_person (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_all_person (iface, error))
    return FALSE;
  if (!i_face_log_client_recv_load_all_person (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_device_by_where (IFaceLogIf * iface, const gchar * where, const gint32 startRow, const gint32 numRows, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadDeviceByWhere", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadDeviceByWhere_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, where, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, startRow, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "numRows", T_I32, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, numRows, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_device_by_where (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadDeviceByWhere", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadDeviceByWhere", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                DeviceBean * _elem231 = NULL;
                if ( _elem231 != NULL)
                {
                  g_object_unref (_elem231);
                }
                _elem231 = g_object_new (TYPE_DEVICE_BEAN, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem231), protocol, error)) < 0)
                {
                  g_object_unref (_elem231);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem231);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_device_by_where (IFaceLogIf * iface, GPtrArray ** _return, const gchar * where, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_device_by_where (iface, where, startRow, numRows, error))
    return FALSE;
  if (!i_face_log_client_recv_load_device_by_where (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_device_group_by_where (IFaceLogIf * iface, const gchar * where, const gint32 startRow, const gint32 numRows, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadDeviceGroupByWhere", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadDeviceGroupByWhere_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, where, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, startRow, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "numRows", T_I32, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, numRows, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_device_group_by_where (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadDeviceGroupByWhere", 22) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadDeviceGroupByWhere", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem232 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem232, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem232, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_device_group_by_where (IFaceLogIf * iface, GArray ** _return, const gchar * where, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_device_group_by_where (iface, where, startRow, numRows, error))
    return FALSE;
  if (!i_face_log_client_recv_load_device_group_by_where (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_device_group_id_by_where (IFaceLogIf * iface, const gchar * where, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadDeviceGroupIdByWhere", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadDeviceGroupIdByWhere_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, where, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_device_group_id_by_where (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadDeviceGroupIdByWhere", 24) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadDeviceGroupIdByWhere", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem233 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem233, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem233, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_device_group_id_by_where (IFaceLogIf * iface, GArray ** _return, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_device_group_id_by_where (iface, where, error))
    return FALSE;
  if (!i_face_log_client_recv_load_device_group_id_by_where (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_device_id_by_where (IFaceLogIf * iface, const gchar * where, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadDeviceIdByWhere", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadDeviceIdByWhere_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, where, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_device_id_by_where (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadDeviceIdByWhere", 19) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadDeviceIdByWhere", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem234 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem234, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem234, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_device_id_by_where (IFaceLogIf * iface, GArray ** _return, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_device_id_by_where (iface, where, error))
    return FALSE;
  if (!i_face_log_client_recv_load_device_id_by_where (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_distinct_integer_column (IFaceLogIf * iface, const gchar * table, const gchar * column, const gchar * where, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadDistinctIntegerColumn", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadDistinctIntegerColumn_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, table, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, column, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, where, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_distinct_integer_column (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadDistinctIntegerColumn", 25) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadDistinctIntegerColumn", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem235 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem235, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem235, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_distinct_integer_column (IFaceLogIf * iface, GArray ** _return, const gchar * table, const gchar * column, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_distinct_integer_column (iface, table, column, where, error))
    return FALSE;
  if (!i_face_log_client_recv_load_distinct_integer_column (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_distinct_string_column (IFaceLogIf * iface, const gchar * table, const gchar * column, const gchar * where, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadDistinctStringColumn", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadDistinctStringColumn_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "table", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, table, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "column", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, column, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, where, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_distinct_string_column (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadDistinctStringColumn", 24) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadDistinctStringColumn", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem236 = NULL;
                if (_elem236 != NULL)
                {
                  g_free(_elem236);
                  _elem236 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem236, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem236);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_distinct_string_column (IFaceLogIf * iface, GPtrArray ** _return, const gchar * table, const gchar * column, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_distinct_string_column (iface, table, column, where, error))
    return FALSE;
  if (!i_face_log_client_recv_load_distinct_string_column (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_feature_md5_by_update (IFaceLogIf * iface, const gint64 timestamp, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadFeatureMd5ByUpdate", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadFeatureMd5ByUpdate_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_feature_md5_by_update (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadFeatureMd5ByUpdate", 22) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadFeatureMd5ByUpdate", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem237 = NULL;
                if (_elem237 != NULL)
                {
                  g_free(_elem237);
                  _elem237 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem237, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem237);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_feature_md5_by_update (IFaceLogIf * iface, GPtrArray ** _return, const gint64 timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_feature_md5_by_update (iface, timestamp, error))
    return FALSE;
  if (!i_face_log_client_recv_load_feature_md5_by_update (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_feature_md5_by_update_time_str (IFaceLogIf * iface, const gchar * timestamp, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadFeatureMd5ByUpdateTimeStr", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadFeatureMd5ByUpdateTimeStr_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_feature_md5_by_update_time_str (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadFeatureMd5ByUpdateTimeStr", 29) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadFeatureMd5ByUpdateTimeStr", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gchar * _elem238 = NULL;
                if (_elem238 != NULL)
                {
                  g_free(_elem238);
                  _elem238 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &_elem238, error)) < 0)
                  return 0;
                xfer += ret;
                g_ptr_array_add (*_return, _elem238);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_feature_md5_by_update_time_str (IFaceLogIf * iface, GPtrArray ** _return, const gchar * timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_feature_md5_by_update_time_str (iface, timestamp, error))
    return FALSE;
  if (!i_face_log_client_recv_load_feature_md5_by_update_time_str (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_log_by_where (IFaceLogIf * iface, const gchar * where, const gint32 startRow, const gint32 numRows, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadLogByWhere", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadLogByWhere_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, where, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, startRow, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "numRows", T_I32, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, numRows, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_log_by_where (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadLogByWhere", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadLogByWhere", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                LogBean * _elem239 = NULL;
                if ( _elem239 != NULL)
                {
                  g_object_unref (_elem239);
                }
                _elem239 = g_object_new (TYPE_LOG_BEAN, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem239), protocol, error)) < 0)
                {
                  g_object_unref (_elem239);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem239);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_log_by_where (IFaceLogIf * iface, GPtrArray ** _return, const gchar * where, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_log_by_where (iface, where, startRow, numRows, error))
    return FALSE;
  if (!i_face_log_client_recv_load_log_by_where (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_log_light_by_verify_time (IFaceLogIf * iface, const gint64 timestamp, const gint32 startRow, const gint32 numRows, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadLogLightByVerifyTime", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadLogLightByVerifyTime_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, startRow, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "numRows", T_I32, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, numRows, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_log_light_by_verify_time (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadLogLightByVerifyTime", 24) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadLogLightByVerifyTime", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                LogLightBean * _elem240 = NULL;
                if ( _elem240 != NULL)
                {
                  g_object_unref (_elem240);
                }
                _elem240 = g_object_new (TYPE_LOG_LIGHT_BEAN, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem240), protocol, error)) < 0)
                {
                  g_object_unref (_elem240);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem240);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_log_light_by_verify_time (IFaceLogIf * iface, GPtrArray ** _return, const gint64 timestamp, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_log_light_by_verify_time (iface, timestamp, startRow, numRows, error))
    return FALSE;
  if (!i_face_log_client_recv_load_log_light_by_verify_time (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_log_light_by_verify_time_timestr (IFaceLogIf * iface, const gchar * timestamp, const gint32 startRow, const gint32 numRows, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadLogLightByVerifyTimeTimestr", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadLogLightByVerifyTimeTimestr_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, startRow, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "numRows", T_I32, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, numRows, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_log_light_by_verify_time_timestr (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadLogLightByVerifyTimeTimestr", 31) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadLogLightByVerifyTimeTimestr", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                LogLightBean * _elem241 = NULL;
                if ( _elem241 != NULL)
                {
                  g_object_unref (_elem241);
                }
                _elem241 = g_object_new (TYPE_LOG_LIGHT_BEAN, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem241), protocol, error)) < 0)
                {
                  g_object_unref (_elem241);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem241);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_log_light_by_verify_time_timestr (IFaceLogIf * iface, GPtrArray ** _return, const gchar * timestamp, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_log_light_by_verify_time_timestr (iface, timestamp, startRow, numRows, error))
    return FALSE;
  if (!i_face_log_client_recv_load_log_light_by_verify_time_timestr (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_log_light_by_where (IFaceLogIf * iface, const gchar * where, const gint32 startRow, const gint32 numRows, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadLogLightByWhere", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadLogLightByWhere_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, where, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, startRow, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "numRows", T_I32, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, numRows, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_log_light_by_where (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadLogLightByWhere", 19) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadLogLightByWhere", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                LogLightBean * _elem242 = NULL;
                if ( _elem242 != NULL)
                {
                  g_object_unref (_elem242);
                }
                _elem242 = g_object_new (TYPE_LOG_LIGHT_BEAN, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem242), protocol, error)) < 0)
                {
                  g_object_unref (_elem242);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem242);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_log_light_by_where (IFaceLogIf * iface, GPtrArray ** _return, const gchar * where, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_log_light_by_where (iface, where, startRow, numRows, error))
    return FALSE;
  if (!i_face_log_client_recv_load_log_light_by_where (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_permit_by_update (IFaceLogIf * iface, const gint64 timestamp, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadPermitByUpdate", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadPermitByUpdate_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_permit_by_update (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadPermitByUpdate", 18) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadPermitByUpdate", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                PermitBean * _elem243 = NULL;
                if ( _elem243 != NULL)
                {
                  g_object_unref (_elem243);
                }
                _elem243 = g_object_new (TYPE_PERMIT_BEAN, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem243), protocol, error)) < 0)
                {
                  g_object_unref (_elem243);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem243);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_permit_by_update (IFaceLogIf * iface, GPtrArray ** _return, const gint64 timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_permit_by_update (iface, timestamp, error))
    return FALSE;
  if (!i_face_log_client_recv_load_permit_by_update (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_permit_by_update_timestr (IFaceLogIf * iface, const gchar * timestamp, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadPermitByUpdateTimestr", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadPermitByUpdateTimestr_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_permit_by_update_timestr (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadPermitByUpdateTimestr", 25) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadPermitByUpdateTimestr", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                PermitBean * _elem244 = NULL;
                if ( _elem244 != NULL)
                {
                  g_object_unref (_elem244);
                }
                _elem244 = g_object_new (TYPE_PERMIT_BEAN, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem244), protocol, error)) < 0)
                {
                  g_object_unref (_elem244);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem244);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_permit_by_update_timestr (IFaceLogIf * iface, GPtrArray ** _return, const gchar * timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_permit_by_update_timestr (iface, timestamp, error))
    return FALSE;
  if (!i_face_log_client_recv_load_permit_by_update_timestr (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_person_by_where (IFaceLogIf * iface, const gchar * where, const gint32 startRow, const gint32 numRows, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadPersonByWhere", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadPersonByWhere_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, where, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, startRow, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "numRows", T_I32, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, numRows, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_person_by_where (IFaceLogIf * iface, GPtrArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadPersonByWhere", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadPersonByWhere", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                PersonBean * _elem245 = NULL;
                if ( _elem245 != NULL)
                {
                  g_object_unref (_elem245);
                }
                _elem245 = g_object_new (TYPE_PERSON_BEAN, NULL);
                if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem245), protocol, error)) < 0)
                {
                  g_object_unref (_elem245);
                  return 0;
                }
                xfer += ret;
                g_ptr_array_add (*_return, _elem245);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_person_by_where (IFaceLogIf * iface, GPtrArray ** _return, const gchar * where, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_person_by_where (iface, where, startRow, numRows, error))
    return FALSE;
  if (!i_face_log_client_recv_load_person_by_where (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_person_group_by_where (IFaceLogIf * iface, const gchar * where, const gint32 startRow, const gint32 numRows, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadPersonGroupByWhere", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadPersonGroupByWhere_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, where, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "startRow", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, startRow, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "numRows", T_I32, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, numRows, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_person_group_by_where (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadPersonGroupByWhere", 22) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadPersonGroupByWhere", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem246 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem246, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem246, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_person_group_by_where (IFaceLogIf * iface, GArray ** _return, const gchar * where, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_person_group_by_where (iface, where, startRow, numRows, error))
    return FALSE;
  if (!i_face_log_client_recv_load_person_group_by_where (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_person_group_id_by_where (IFaceLogIf * iface, const gchar * where, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadPersonGroupIdByWhere", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadPersonGroupIdByWhere_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, where, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_person_group_id_by_where (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadPersonGroupIdByWhere", 24) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadPersonGroupIdByWhere", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem247 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem247, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem247, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_person_group_id_by_where (IFaceLogIf * iface, GArray ** _return, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_person_group_id_by_where (iface, where, error))
    return FALSE;
  if (!i_face_log_client_recv_load_person_group_id_by_where (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_person_id_by_update_time (IFaceLogIf * iface, const gint64 timestamp, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadPersonIdByUpdateTime", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadPersonIdByUpdateTime_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_person_id_by_update_time (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadPersonIdByUpdateTime", 24) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadPersonIdByUpdateTime", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem248 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem248, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem248, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_person_id_by_update_time (IFaceLogIf * iface, GArray ** _return, const gint64 timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_person_id_by_update_time (iface, timestamp, error))
    return FALSE;
  if (!i_face_log_client_recv_load_person_id_by_update_time (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_person_id_by_update_time_time_str (IFaceLogIf * iface, const gchar * timestamp, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadPersonIdByUpdateTimeTimeStr", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadPersonIdByUpdateTimeTimeStr_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_person_id_by_update_time_time_str (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadPersonIdByUpdateTimeTimeStr", 31) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadPersonIdByUpdateTimeTimeStr", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem249 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem249, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem249, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_person_id_by_update_time_time_str (IFaceLogIf * iface, GArray ** _return, const gchar * timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_person_id_by_update_time_time_str (iface, timestamp, error))
    return FALSE;
  if (!i_face_log_client_recv_load_person_id_by_update_time_time_str (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_person_id_by_where (IFaceLogIf * iface, const gchar * where, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadPersonIdByWhere", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadPersonIdByWhere_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "where", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, where, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_person_id_by_where (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadPersonIdByWhere", 19) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadPersonIdByWhere", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem250 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem250, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem250, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_person_id_by_where (IFaceLogIf * iface, GArray ** _return, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_person_id_by_where (iface, where, error))
    return FALSE;
  if (!i_face_log_client_recv_load_person_id_by_where (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_updated_persons (IFaceLogIf * iface, const gint64 timestamp, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadUpdatedPersons", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadUpdatedPersons_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_I64, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_updated_persons (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadUpdatedPersons", 18) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadUpdatedPersons", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem251 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem251, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem251, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_updated_persons (IFaceLogIf * iface, GArray ** _return, const gint64 timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_updated_persons (iface, timestamp, error))
    return FALSE;
  if (!i_face_log_client_recv_load_updated_persons (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_load_updated_persons_timestr (IFaceLogIf * iface, const gchar * timestamp, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "loadUpdatedPersonsTimestr", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "loadUpdatedPersonsTimestr_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "timestamp", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, timestamp, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_load_updated_persons_timestr (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "loadUpdatedPersonsTimestr", 25) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected loadUpdatedPersonsTimestr", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_LIST)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType element_type;

              if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through list elements */
              for (i = 0; i < size; i++)
              {
                gint32* _elem252 = g_new (gint32, 1);
                if ((ret = thrift_protocol_read_i32 (protocol, &*_elem252, error)) < 0)
                  return 0;
                xfer += ret;
                g_array_append_vals (*_return, _elem252, 1);
              }
              if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_load_updated_persons_timestr (IFaceLogIf * iface, GArray ** _return, const gchar * timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_load_updated_persons_timestr (iface, timestamp, error))
    return FALSE;
  if (!i_face_log_client_recv_load_updated_persons_timestr (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_offline (IFaceLogIf * iface, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "offline", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "offline_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_offline (IFaceLogIf * iface, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "offline", 7) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected offline", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_SECURITY_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex2 != NULL)
            {
              g_object_unref (*ex2);
            }
            *ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex2), protocol, error)) < 0)
            {
              g_object_unref (*ex2);
              *ex2 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_SECURITY_EXCEPTION_ERROR, SERVICE_SECURITY_EXCEPTION_ERROR_CODE, "ServiceSecurityException");
      return FALSE;
  }
  if (*ex2 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_offline (IFaceLogIf * iface, const Token * token, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  if (!i_face_log_client_send_offline (iface, token, error))
    return FALSE;
  if (!i_face_log_client_recv_offline (iface, ex1, ex2, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_online (IFaceLogIf * iface, const DeviceBean * device, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "online", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "online_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "device", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (device), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_online (IFaceLogIf * iface, Token ** _return, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "online", 6) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected online", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_SECURITY_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex2 != NULL)
            {
              g_object_unref (*ex2);
            }
            *ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex2), protocol, error)) < 0)
            {
              g_object_unref (*ex2);
              *ex2 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_SECURITY_EXCEPTION_ERROR, SERVICE_SECURITY_EXCEPTION_ERROR_CODE, "ServiceSecurityException");
      return FALSE;
  }
  if (*ex2 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_online (IFaceLogIf * iface, Token ** _return, const DeviceBean * device, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  if (!i_face_log_client_send_online (iface, device, error))
    return FALSE;
  if (!i_face_log_client_recv_online (iface, _return, ex1, ex2, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_register_device (IFaceLogIf * iface, const DeviceBean * newDevice, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "registerDevice", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "registerDevice_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "newDevice", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (newDevice), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_register_device (IFaceLogIf * iface, DeviceBean ** _return, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "registerDevice", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected registerDevice", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_SECURITY_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex2 != NULL)
            {
              g_object_unref (*ex2);
            }
            *ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex2), protocol, error)) < 0)
            {
              g_object_unref (*ex2);
              *ex2 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_SECURITY_EXCEPTION_ERROR, SERVICE_SECURITY_EXCEPTION_ERROR_CODE, "ServiceSecurityException");
      return FALSE;
  }
  if (*ex2 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_register_device (IFaceLogIf * iface, DeviceBean ** _return, const DeviceBean * newDevice, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  if (!i_face_log_client_send_register_device (iface, newDevice, error))
    return FALSE;
  if (!i_face_log_client_recv_register_device (iface, _return, ex1, ex2, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_release_person_token (IFaceLogIf * iface, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "releasePersonToken", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "releasePersonToken_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_release_person_token (IFaceLogIf * iface, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "releasePersonToken", 18) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected releasePersonToken", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_SECURITY_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex2 != NULL)
            {
              g_object_unref (*ex2);
            }
            *ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex2), protocol, error)) < 0)
            {
              g_object_unref (*ex2);
              *ex2 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_SECURITY_EXCEPTION_ERROR, SERVICE_SECURITY_EXCEPTION_ERROR_CODE, "ServiceSecurityException");
      return FALSE;
  }
  if (*ex2 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_release_person_token (IFaceLogIf * iface, const Token * token, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  if (!i_face_log_client_send_release_person_token (iface, token, error))
    return FALSE;
  if (!i_face_log_client_recv_release_person_token (iface, ex1, ex2, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_release_root_token (IFaceLogIf * iface, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "releaseRootToken", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "releaseRootToken_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_release_root_token (IFaceLogIf * iface, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "releaseRootToken", 16) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected releaseRootToken", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_SECURITY_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex2 != NULL)
            {
              g_object_unref (*ex2);
            }
            *ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex2), protocol, error)) < 0)
            {
              g_object_unref (*ex2);
              *ex2 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_SECURITY_EXCEPTION_ERROR, SERVICE_SECURITY_EXCEPTION_ERROR_CODE, "ServiceSecurityException");
      return FALSE;
  }
  if (*ex2 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_release_root_token (IFaceLogIf * iface, const Token * token, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  if (!i_face_log_client_send_release_root_token (iface, token, error))
    return FALSE;
  if (!i_face_log_client_recv_release_root_token (iface, ex1, ex2, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_release_user_token (IFaceLogIf * iface, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "releaseUserToken", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "releaseUserToken_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_release_user_token (IFaceLogIf * iface, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "releaseUserToken", 16) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected releaseUserToken", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_SECURITY_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex2 != NULL)
            {
              g_object_unref (*ex2);
            }
            *ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex2), protocol, error)) < 0)
            {
              g_object_unref (*ex2);
              *ex2 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_SECURITY_EXCEPTION_ERROR, SERVICE_SECURITY_EXCEPTION_ERROR_CODE, "ServiceSecurityException");
      return FALSE;
  }
  if (*ex2 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_release_user_token (IFaceLogIf * iface, const Token * token, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  if (!i_face_log_client_send_release_user_token (iface, token, error))
    return FALSE;
  if (!i_face_log_client_recv_release_user_token (iface, ex1, ex2, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_replace_feature (IFaceLogIf * iface, const gint32 personId, const gchar * featureMd5, const gboolean deleteOldFeatureImage, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "replaceFeature", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "replaceFeature_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "featureMd5", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, featureMd5, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deleteOldFeatureImage", T_BOOL, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, deleteOldFeatureImage, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_replace_feature (IFaceLogIf * iface, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "replaceFeature", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected replaceFeature", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_replace_feature (IFaceLogIf * iface, const gint32 personId, const gchar * featureMd5, const gboolean deleteOldFeatureImage, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_replace_feature (iface, personId, featureMd5, deleteOldFeatureImage, token, error))
    return FALSE;
  if (!i_face_log_client_recv_replace_feature (iface, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_root_group_of_device (IFaceLogIf * iface, const gint32 deviceId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "rootGroupOfDevice", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "rootGroupOfDevice_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_root_group_of_device (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "rootGroupOfDevice", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected rootGroupOfDevice", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_root_group_of_device (IFaceLogIf * iface, gint32* _return, const gint32 deviceId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_root_group_of_device (iface, deviceId, error))
    return FALSE;
  if (!i_face_log_client_recv_root_group_of_device (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_root_group_of_person (IFaceLogIf * iface, const gint32 personId, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "rootGroupOfPerson", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "rootGroupOfPerson_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_root_group_of_person (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "rootGroupOfPerson", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected rootGroupOfPerson", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_root_group_of_person (IFaceLogIf * iface, gint32* _return, const gint32 personId, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_root_group_of_person (iface, personId, error))
    return FALSE;
  if (!i_face_log_client_recv_root_group_of_person (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_run_cmd (IFaceLogIf * iface, const GArray * target, const gboolean group, const gchar * cmdpath, const gchar * jsonArgs, const gchar * ackChannel, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "runCmd", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "runCmd_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "target", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i253;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (target ? target->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i253 = 0; i253 < (target ? target->len : 0); i253++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (target, gint32, i253)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "group", T_BOOL, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, group, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "cmdpath", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, cmdpath, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "jsonArgs", T_STRING, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, jsonArgs, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "ackChannel", T_STRING, 5, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, ackChannel, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 6, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_run_cmd (IFaceLogIf * iface, gchar ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "runCmd", 6) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected runCmd", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_run_cmd (IFaceLogIf * iface, gchar ** _return, const GArray * target, const gboolean group, const gchar * cmdpath, const gchar * jsonArgs, const gchar * ackChannel, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_run_cmd (iface, target, group, cmdpath, jsonArgs, ackChannel, token, error))
    return FALSE;
  if (!i_face_log_client_recv_run_cmd (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_run_task (IFaceLogIf * iface, const gchar * taskQueue, const gchar * cmdpath, const gchar * jsonArgs, const gchar * ackChannel, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "runTask", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "runTask_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "taskQueue", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, taskQueue, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "cmdpath", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, cmdpath, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "jsonArgs", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, jsonArgs, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "ackChannel", T_STRING, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, ackChannel, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 5, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_run_task (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "runTask", 7) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected runTask", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_run_task (IFaceLogIf * iface, gint32* _return, const gchar * taskQueue, const gchar * cmdpath, const gchar * jsonArgs, const gchar * ackChannel, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_run_task (iface, taskQueue, cmdpath, jsonArgs, ackChannel, token, error))
    return FALSE;
  if (!i_face_log_client_recv_run_task (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_save_device (IFaceLogIf * iface, const DeviceBean * deviceBean, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "saveDevice", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "saveDevice_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceBean", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (deviceBean), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_save_device (IFaceLogIf * iface, DeviceBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "saveDevice", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected saveDevice", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_save_device (IFaceLogIf * iface, DeviceBean ** _return, const DeviceBean * deviceBean, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_save_device (iface, deviceBean, token, error))
    return FALSE;
  if (!i_face_log_client_recv_save_device (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_save_device_group (IFaceLogIf * iface, const DeviceGroupBean * deviceGroupBean, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "saveDeviceGroup", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "saveDeviceGroup_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupBean", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (deviceGroupBean), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_save_device_group (IFaceLogIf * iface, DeviceGroupBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "saveDeviceGroup", 15) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected saveDeviceGroup", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_save_device_group (IFaceLogIf * iface, DeviceGroupBean ** _return, const DeviceGroupBean * deviceGroupBean, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_save_device_group (iface, deviceGroupBean, token, error))
    return FALSE;
  if (!i_face_log_client_recv_save_device_group (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_save_permit (IFaceLogIf * iface, const PermitBean * permitBean, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "savePermit", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "savePermit_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "permitBean", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (permitBean), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_save_permit (IFaceLogIf * iface, PermitBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "savePermit", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected savePermit", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_save_permit (IFaceLogIf * iface, PermitBean ** _return, const PermitBean * permitBean, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_save_permit (iface, permitBean, token, error))
    return FALSE;
  if (!i_face_log_client_recv_save_permit (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_save_permit_with_schedule (IFaceLogIf * iface, const gint32 deviceGroupId, const gint32 personGroupId, const gchar * schedule, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "savePermitWithSchedule", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "savePermitWithSchedule_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "schedule", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, schedule, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_save_permit_with_schedule (IFaceLogIf * iface, PermitBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "savePermitWithSchedule", 22) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected savePermitWithSchedule", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_save_permit_with_schedule (IFaceLogIf * iface, PermitBean ** _return, const gint32 deviceGroupId, const gint32 personGroupId, const gchar * schedule, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_save_permit_with_schedule (iface, deviceGroupId, personGroupId, schedule, token, error))
    return FALSE;
  if (!i_face_log_client_recv_save_permit_with_schedule (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_save_person (IFaceLogIf * iface, const PersonBean * personBean, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "savePerson", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "savePerson_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personBean", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (personBean), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_save_person (IFaceLogIf * iface, PersonBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "savePerson", 10) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected savePerson", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_save_person (IFaceLogIf * iface, PersonBean ** _return, const PersonBean * personBean, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_save_person (iface, personBean, token, error))
    return FALSE;
  if (!i_face_log_client_recv_save_person (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_save_person_full (IFaceLogIf * iface, const PersonBean * personBean, const GByteArray * idPhoto, const GByteArray * feature, const gchar * featureVersion, const GByteArray * featureImage, const FaceBean * featureFaceBean, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "savePersonFull", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "savePersonFull_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personBean", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (personBean), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "idPhoto", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, idPhoto ? ((GByteArray *) idPhoto)->data : NULL, idPhoto ? ((GByteArray *) idPhoto)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "feature", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, feature ? ((GByteArray *) feature)->data : NULL, feature ? ((GByteArray *) feature)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "featureVersion", T_STRING, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, featureVersion, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "featureImage", T_STRING, 5, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, featureImage ? ((GByteArray *) featureImage)->data : NULL, featureImage ? ((GByteArray *) featureImage)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "featureFaceBean", T_STRUCT, 6, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (featureFaceBean), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 7, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_save_person_full (IFaceLogIf * iface, PersonBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "savePersonFull", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected savePersonFull", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_save_person_full (IFaceLogIf * iface, PersonBean ** _return, const PersonBean * personBean, const GByteArray * idPhoto, const GByteArray * feature, const gchar * featureVersion, const GByteArray * featureImage, const FaceBean * featureFaceBean, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_save_person_full (iface, personBean, idPhoto, feature, featureVersion, featureImage, featureFaceBean, token, error))
    return FALSE;
  if (!i_face_log_client_recv_save_person_full (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_save_person_group (IFaceLogIf * iface, const PersonGroupBean * personGroupBean, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "savePersonGroup", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "savePersonGroup_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupBean", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (personGroupBean), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_save_person_group (IFaceLogIf * iface, PersonGroupBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "savePersonGroup", 15) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected savePersonGroup", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_save_person_group (IFaceLogIf * iface, PersonGroupBean ** _return, const PersonGroupBean * personGroupBean, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_save_person_group (iface, personGroupBean, token, error))
    return FALSE;
  if (!i_face_log_client_recv_save_person_group (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_save_person_with_photo (IFaceLogIf * iface, const PersonBean * personBean, const GByteArray * idPhoto, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "savePersonWithPhoto", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "savePersonWithPhoto_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personBean", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (personBean), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "idPhoto", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, idPhoto ? ((GByteArray *) idPhoto)->data : NULL, idPhoto ? ((GByteArray *) idPhoto)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_save_person_with_photo (IFaceLogIf * iface, PersonBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "savePersonWithPhoto", 19) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected savePersonWithPhoto", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_save_person_with_photo (IFaceLogIf * iface, PersonBean ** _return, const PersonBean * personBean, const GByteArray * idPhoto, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_save_person_with_photo (iface, personBean, idPhoto, token, error))
    return FALSE;
  if (!i_face_log_client_recv_save_person_with_photo (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_save_person_with_photo_and_feature (IFaceLogIf * iface, const PersonBean * personBean, const GByteArray * idPhoto, const FeatureBean * featureBean, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "savePersonWithPhotoAndFeature", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "savePersonWithPhotoAndFeature_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personBean", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (personBean), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "idPhoto", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, idPhoto ? ((GByteArray *) idPhoto)->data : NULL, idPhoto ? ((GByteArray *) idPhoto)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "featureBean", T_STRUCT, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (featureBean), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_save_person_with_photo_and_feature (IFaceLogIf * iface, PersonBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "savePersonWithPhotoAndFeature", 29) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected savePersonWithPhotoAndFeature", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_save_person_with_photo_and_feature (IFaceLogIf * iface, PersonBean ** _return, const PersonBean * personBean, const GByteArray * idPhoto, const FeatureBean * featureBean, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_save_person_with_photo_and_feature (iface, personBean, idPhoto, featureBean, token, error))
    return FALSE;
  if (!i_face_log_client_recv_save_person_with_photo_and_feature (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_save_person_with_photo_and_feature_multi_faces (IFaceLogIf * iface, const PersonBean * personBean, const GByteArray * idPhoto, const GByteArray * feature, const gchar * featureVersion, const GPtrArray * faceBeans, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "savePersonWithPhotoAndFeatureMultiFaces", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "savePersonWithPhotoAndFeatureMultiFaces_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personBean", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (personBean), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "idPhoto", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, idPhoto ? ((GByteArray *) idPhoto)->data : NULL, idPhoto ? ((GByteArray *) idPhoto)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "feature", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, feature ? ((GByteArray *) feature)->data : NULL, feature ? ((GByteArray *) feature)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "featureVersion", T_STRING, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, featureVersion, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "faceBeans", T_LIST, 5, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i254;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (faceBeans ? faceBeans->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i254 = 0; i254 < (faceBeans ? faceBeans->len : 0); i254++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) faceBeans, i254))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 6, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_save_person_with_photo_and_feature_multi_faces (IFaceLogIf * iface, PersonBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "savePersonWithPhotoAndFeatureMultiFaces", 39) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected savePersonWithPhotoAndFeatureMultiFaces", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_save_person_with_photo_and_feature_multi_faces (IFaceLogIf * iface, PersonBean ** _return, const PersonBean * personBean, const GByteArray * idPhoto, const GByteArray * feature, const gchar * featureVersion, const GPtrArray * faceBeans, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_save_person_with_photo_and_feature_multi_faces (iface, personBean, idPhoto, feature, featureVersion, faceBeans, token, error))
    return FALSE;
  if (!i_face_log_client_recv_save_person_with_photo_and_feature_multi_faces (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_save_person_with_photo_and_feature_multi_image (IFaceLogIf * iface, const PersonBean * personBean, const GByteArray * idPhoto, const GByteArray * feature, const gchar * featureVersion, const GPtrArray * photos, const GPtrArray * faces, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "savePersonWithPhotoAndFeatureMultiImage", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "savePersonWithPhotoAndFeatureMultiImage_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personBean", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (personBean), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "idPhoto", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, idPhoto ? ((GByteArray *) idPhoto)->data : NULL, idPhoto ? ((GByteArray *) idPhoto)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "feature", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, feature ? ((GByteArray *) feature)->data : NULL, feature ? ((GByteArray *) feature)->len : 0, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "featureVersion", T_STRING, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, featureVersion, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "photos", T_LIST, 5, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i255;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (photos ? photos->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i255 = 0; i255 < (photos ? photos->len : 0); i255++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) photos, i255)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) photos, i255)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) photos, i255)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) photos, i255)))->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "faces", T_LIST, 6, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i256;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (faces ? faces->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i256 = 0; i256 < (faces ? faces->len : 0); i256++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) faces, i256))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 7, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_save_person_with_photo_and_feature_multi_image (IFaceLogIf * iface, PersonBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "savePersonWithPhotoAndFeatureMultiImage", 39) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected savePersonWithPhotoAndFeatureMultiImage", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_save_person_with_photo_and_feature_multi_image (IFaceLogIf * iface, PersonBean ** _return, const PersonBean * personBean, const GByteArray * idPhoto, const GByteArray * feature, const gchar * featureVersion, const GPtrArray * photos, const GPtrArray * faces, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_save_person_with_photo_and_feature_multi_image (iface, personBean, idPhoto, feature, featureVersion, photos, faces, token, error))
    return FALSE;
  if (!i_face_log_client_recv_save_person_with_photo_and_feature_multi_image (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_save_person_with_photo_and_feature_saved (IFaceLogIf * iface, const PersonBean * personBean, const gchar * idPhotoMd5, const gchar * featureMd5, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "savePersonWithPhotoAndFeatureSaved", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "savePersonWithPhotoAndFeatureSaved_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personBean", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (personBean), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "idPhotoMd5", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, idPhotoMd5, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "featureMd5", T_STRING, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, featureMd5, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 4, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_save_person_with_photo_and_feature_saved (IFaceLogIf * iface, PersonBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "savePersonWithPhotoAndFeatureSaved", 34) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected savePersonWithPhotoAndFeatureSaved", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_save_person_with_photo_and_feature_saved (IFaceLogIf * iface, PersonBean ** _return, const PersonBean * personBean, const gchar * idPhotoMd5, const gchar * featureMd5, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_save_person_with_photo_and_feature_saved (iface, personBean, idPhotoMd5, featureMd5, token, error))
    return FALSE;
  if (!i_face_log_client_recv_save_person_with_photo_and_feature_saved (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_save_persons (IFaceLogIf * iface, const GPtrArray * persons, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "savePersons", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "savePersons_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "persons", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i257;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (persons ? persons->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i257 = 0; i257 < (persons ? persons->len : 0); i257++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) persons, i257))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_save_persons (IFaceLogIf * iface, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "savePersons", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected savePersons", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_save_persons (IFaceLogIf * iface, const GPtrArray * persons, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_save_persons (iface, persons, token, error))
    return FALSE;
  if (!i_face_log_client_recv_save_persons (iface, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_save_persons_with_photo (IFaceLogIf * iface, const GPtrArray * photos, const GPtrArray * persons, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "savePersonsWithPhoto", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "savePersonsWithPhoto_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "photos", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i258;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (photos ? photos->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i258 = 0; i258 < (photos ? photos->len : 0); i258++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) photos, i258)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) photos, i258)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) photos, i258)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) photos, i258)))->len : 0, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "persons", T_LIST, 2, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i259;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (persons ? persons->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i259 = 0; i259 < (persons ? persons->len : 0); i259++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) persons, i259))), protocol, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_save_persons_with_photo (IFaceLogIf * iface, gint32* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "savePersonsWithPhoto", 20) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected savePersonsWithPhoto", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_I32)
          {
            if ((ret = thrift_protocol_read_i32 (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_save_persons_with_photo (IFaceLogIf * iface, gint32* _return, const GPtrArray * photos, const GPtrArray * persons, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_save_persons_with_photo (iface, photos, persons, token, error))
    return FALSE;
  if (!i_face_log_client_recv_save_persons_with_photo (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_save_service_config (IFaceLogIf * iface, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "saveServiceConfig", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "saveServiceConfig_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_save_service_config (IFaceLogIf * iface, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "saveServiceConfig", 17) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected saveServiceConfig", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_save_service_config (IFaceLogIf * iface, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_save_service_config (iface, token, error))
    return FALSE;
  if (!i_face_log_client_recv_save_service_config (iface, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_sdk_task_queue_of (IFaceLogIf * iface, const gchar * task, const gchar * sdkVersion, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "sdkTaskQueueOf", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "sdkTaskQueueOf_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "task", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, task, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "sdkVersion", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, sdkVersion, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_sdk_task_queue_of (IFaceLogIf * iface, gchar ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "sdkTaskQueueOf", 14) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected sdkTaskQueueOf", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_sdk_task_queue_of (IFaceLogIf * iface, gchar ** _return, const gchar * task, const gchar * sdkVersion, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_sdk_task_queue_of (iface, task, sdkVersion, token, error))
    return FALSE;
  if (!i_face_log_client_recv_sdk_task_queue_of (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_set_person_expiry_date (IFaceLogIf * iface, const gint32 personId, const gint64 expiryDate, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "setPersonExpiryDate", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "setPersonExpiryDate_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "expiryDate", T_I64, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, expiryDate, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_set_person_expiry_date (IFaceLogIf * iface, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "setPersonExpiryDate", 19) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected setPersonExpiryDate", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_set_person_expiry_date (IFaceLogIf * iface, const gint32 personId, const gint64 expiryDate, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_set_person_expiry_date (iface, personId, expiryDate, token, error))
    return FALSE;
  if (!i_face_log_client_recv_set_person_expiry_date (iface, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_set_person_expiry_date_list (IFaceLogIf * iface, const GArray * personIdList, const gint64 expiryDate, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "setPersonExpiryDateList", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "setPersonExpiryDateList_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personIdList", T_LIST, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      guint i260;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I32, (gint32) (personIdList ? personIdList->len : 0), error)) < 0)
        return 0;
      xfer += ret;
      for (i260 = 0; i260 < (personIdList ? personIdList->len : 0); i260++)
      {
        if ((ret = thrift_protocol_write_i32 (protocol, (g_array_index (personIdList, gint32, i260)), error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "expiryDate", T_I64, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, expiryDate, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_set_person_expiry_date_list (IFaceLogIf * iface, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "setPersonExpiryDateList", 23) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected setPersonExpiryDateList", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_set_person_expiry_date_list (IFaceLogIf * iface, const GArray * personIdList, const gint64 expiryDate, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_set_person_expiry_date_list (iface, personIdList, expiryDate, token, error))
    return FALSE;
  if (!i_face_log_client_recv_set_person_expiry_date_list (iface, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_set_person_expiry_date_time_str (IFaceLogIf * iface, const gint32 personId, const gchar * expiryDate, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "setPersonExpiryDateTimeStr", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "setPersonExpiryDateTimeStr_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "expiryDate", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, expiryDate, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_set_person_expiry_date_time_str (IFaceLogIf * iface, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "setPersonExpiryDateTimeStr", 26) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected setPersonExpiryDateTimeStr", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_set_person_expiry_date_time_str (IFaceLogIf * iface, const gint32 personId, const gchar * expiryDate, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_set_person_expiry_date_time_str (iface, personId, expiryDate, token, error))
    return FALSE;
  if (!i_face_log_client_recv_set_person_expiry_date_time_str (iface, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_set_properties (IFaceLogIf * iface, const GHashTable * config, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "setProperties", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "setProperties_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "config", T_MAP, 1, error)) < 0)
      return 0;
    xfer += ret;
    {
      gchar * key261 = NULL;
      gchar * val262 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, config ? (gint32) g_hash_table_size ((GHashTable *) config) : 0, error)) < 0)
        return 0;
      xfer += ret;
      if (config)
        g_hash_table_foreach ((GHashTable *) config, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key261 = keys[i];
        val262 = (gchar *) g_hash_table_lookup (((GHashTable *) config), (gpointer) key261);

        if ((ret = thrift_protocol_write_string (protocol,  key261, error)) < 0)
          return 0;
        xfer += ret;

        if ((ret = thrift_protocol_write_string (protocol,  val262, error)) < 0)
          return 0;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_set_properties (IFaceLogIf * iface, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "setProperties", 13) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected setProperties", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_set_properties (IFaceLogIf * iface, const GHashTable * config, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_set_properties (iface, config, token, error))
    return FALSE;
  if (!i_face_log_client_recv_set_properties (iface, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_set_property (IFaceLogIf * iface, const gchar * key, const gchar * value, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "setProperty", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "setProperty_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "key", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, key, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, value, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_set_property (IFaceLogIf * iface, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "setProperty", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected setProperty", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_set_property (IFaceLogIf * iface, const gchar * key, const gchar * value, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_set_property (iface, key, value, token, error))
    return FALSE;
  if (!i_face_log_client_recv_set_property (iface, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_task_queue_of (IFaceLogIf * iface, const gchar * task, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "taskQueueOf", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "taskQueueOf_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "task", T_STRING, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, task, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_task_queue_of (IFaceLogIf * iface, gchar ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "taskQueueOf", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected taskQueueOf", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_task_queue_of (IFaceLogIf * iface, gchar ** _return, const gchar * task, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_task_queue_of (iface, task, token, error))
    return FALSE;
  if (!i_face_log_client_recv_task_queue_of (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_unbind_border (IFaceLogIf * iface, const gint32 personGroupId, const gint32 deviceGroupId, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "unbindBorder", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "unbindBorder_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "personGroupId", T_I32, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, personGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceGroupId", T_I32, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, deviceGroupId, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 3, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_unbind_border (IFaceLogIf * iface, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "unbindBorder", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected unbindBorder", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_unbind_border (IFaceLogIf * iface, const gint32 personGroupId, const gint32 deviceGroupId, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_unbind_border (iface, personGroupId, deviceGroupId, token, error))
    return FALSE;
  if (!i_face_log_client_recv_unbind_border (iface, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_unregister_device (IFaceLogIf * iface, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "unregisterDevice", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "unregisterDevice_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_unregister_device (IFaceLogIf * iface, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "unregisterDevice", 16) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected unregisterDevice", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_SECURITY_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 2:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex2 != NULL)
            {
              g_object_unref (*ex2);
            }
            *ex2 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex2), protocol, error)) < 0)
            {
              g_object_unref (*ex2);
              *ex2 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_SECURITY_EXCEPTION_ERROR, SERVICE_SECURITY_EXCEPTION_ERROR_CODE, "ServiceSecurityException");
      return FALSE;
  }
  if (*ex2 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_unregister_device (IFaceLogIf * iface, const Token * token, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  if (!i_face_log_client_send_unregister_device (iface, token, error))
    return FALSE;
  if (!i_face_log_client_recv_unregister_device (iface, ex1, ex2, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_update_device (IFaceLogIf * iface, const DeviceBean * deviceBean, const Token * token, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "updateDevice", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "updateDevice_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "deviceBean", T_STRUCT, 1, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (deviceBean), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_begin (protocol, "token", T_STRUCT, 2, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (token), protocol, error)) < 0)
      return 0;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_update_device (IFaceLogIf * iface, DeviceBean ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "updateDevice", 12) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected updateDevice", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRUCT)
          {
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*_return), protocol, error)) < 0)
            {
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_update_device (IFaceLogIf * iface, DeviceBean ** _return, const DeviceBean * deviceBean, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_update_device (iface, deviceBean, token, error))
    return FALSE;
  if (!i_face_log_client_recv_update_device (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_version (IFaceLogIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "version", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "version_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_version (IFaceLogIf * iface, gchar ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "version", 7) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected version", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_STRING)
          {
            if (*_return != NULL)
            {
              g_free(*_return);
              *_return = NULL;
            }

            if ((ret = thrift_protocol_read_string (protocol, &*_return, error)) < 0)
              return 0;
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_version (IFaceLogIf * iface, gchar ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_version (iface, error))
    return FALSE;
  if (!i_face_log_client_recv_version (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

gboolean i_face_log_client_send_version_info (IFaceLogIf * iface, GError ** error)
{
  gint32 cseqid = 0;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->output_protocol;

  if (thrift_protocol_write_message_begin (protocol, "versionInfo", T_CALL, cseqid, error) < 0)
    return FALSE;

  {
    gint32 ret;
    gint32 xfer = 0;

    
    if ((ret = thrift_protocol_write_struct_begin (protocol, "versionInfo_args", error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
      return 0;
    xfer += ret;
    if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_write_message_end (protocol, error) < 0)
    return FALSE;
  if (!thrift_transport_flush (protocol->transport, error))
    return FALSE;
  if (!thrift_transport_write_end (protocol->transport, error))
    return FALSE;

  return TRUE;
}

gboolean i_face_log_client_recv_version_info (IFaceLogIf * iface, GHashTable ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  gint32 rseqid;
  gchar * fname = NULL;
  ThriftMessageType mtype;
  ThriftProtocol * protocol = I_FACE_LOG_CLIENT (iface)->input_protocol;
  ThriftApplicationException *xception;

  if (thrift_protocol_read_message_begin (protocol, &fname, &mtype, &rseqid, error) < 0) {
    if (fname) g_free (fname);
    return FALSE;
  }

  if (mtype == T_EXCEPTION) {
    if (fname) g_free (fname);
    xception = g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION, NULL);
    thrift_struct_read (THRIFT_STRUCT (xception), protocol, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR,xception->type, "application error: %s", xception->message);
    g_object_unref (xception);
    return FALSE;
  } else if (mtype != T_REPLY) {
    if (fname) g_free (fname);
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol, NULL);
    thrift_transport_read_end (protocol->transport, NULL);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_INVALID_MESSAGE_TYPE, "invalid message type %d, expected T_REPLY", mtype);
    return FALSE;
  } else if (strncmp (fname, "versionInfo", 11) != 0) {
    thrift_protocol_skip (protocol, T_STRUCT, NULL);
    thrift_protocol_read_message_end (protocol,error);
    thrift_transport_read_end (protocol->transport, error);
    g_set_error (error, THRIFT_APPLICATION_EXCEPTION_ERROR, THRIFT_APPLICATION_EXCEPTION_ERROR_WRONG_METHOD_NAME, "wrong method name %s, expected versionInfo", fname);
    if (fname) g_free (fname);
    return FALSE;
  }
  if (fname) g_free (fname);

  {
    gint32 ret;
    gint32 xfer = 0;
    gchar *name = NULL;
    ThriftType ftype;
    gint16 fid;
    guint32 len = 0;
    gpointer data = NULL;
    

    /* satisfy -Wall in case these aren't used */
    THRIFT_UNUSED_VAR (len);
    THRIFT_UNUSED_VAR (data);

    /* read the struct begin marker */
    if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
    {
      if (name) g_free (name);
      return 0;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* read the struct fields */
    while (1)
    {
      /* read the beginning of a field */
      if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
      {
        if (name) g_free (name);
        return 0;
      }
      xfer += ret;
      if (name) g_free (name);
      name = NULL;

      /* break if we get a STOP field */
      if (ftype == T_STOP)
      {
        break;
      }

      switch (fid)
      {
        case 0:
          if (ftype == T_MAP)
          {
            {
              guint32 size;
              guint32 i;
              ThriftType key_type;
              ThriftType value_type;

              /* read the map begin marker */
              if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
                return 0;
              xfer += ret;

              /* iterate through each of the map's fields */
              for (i = 0; i < size; i++)
              {
                gchar * key263 = NULL;
                gchar * val264 = NULL;
                if (key263 != NULL)
                {
                  g_free(key263);
                  key263 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &key263, error)) < 0)
                  return 0;
                xfer += ret;
                if (val264 != NULL)
                {
                  g_free(val264);
                  val264 = NULL;
                }

                if ((ret = thrift_protocol_read_string (protocol, &val264, error)) < 0)
                  return 0;
                xfer += ret;
                if (*_return && key263)
                  g_hash_table_insert ((GHashTable *)*_return, (gpointer) key263, (gpointer) val264);
              }

              /* read the map end marker */
              if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
                return 0;
              xfer += ret;
            }
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        case 1:
          if (ftype == T_STRUCT)
          {
            /* This struct is an exception */
            if ( *ex1 != NULL)
            {
              g_object_unref (*ex1);
            }
            *ex1 = g_object_new (TYPE_SERVICE_RUNTIME_EXCEPTION, NULL);
            if ((ret = thrift_struct_read (THRIFT_STRUCT (*ex1), protocol, error)) < 0)
            {
              g_object_unref (*ex1);
              *ex1 = NULL;
              return 0;
            }
            xfer += ret;
          } else {
            if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
              return 0;
            xfer += ret;
          }
          break;
        default:
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return 0;
          xfer += ret;
          break;
      }
      if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
        return 0;
      xfer += ret;
    }

    if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
      return 0;
    xfer += ret;

  }

  if (thrift_protocol_read_message_end (protocol, error) < 0)
    return FALSE;

  if (!thrift_transport_read_end (protocol->transport, error))
    return FALSE;

  if (*ex1 != NULL)
  {
      g_set_error (error, SERVICE_RUNTIME_EXCEPTION_ERROR, SERVICE_RUNTIME_EXCEPTION_ERROR_CODE, "ServiceRuntimeException");
      return FALSE;
  }
  return TRUE;
}

gboolean i_face_log_client_version_info (IFaceLogIf * iface, GHashTable ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  if (!i_face_log_client_send_version_info (iface, error))
    return FALSE;
  if (!i_face_log_client_recv_version_info (iface, _return, ex1, error))
    return FALSE;
  return TRUE;
}

static void
i_face_log_if_interface_init (IFaceLogIfInterface *iface)
{
  iface->add_feature = i_face_log_client_add_feature;
  iface->add_feature_multi = i_face_log_client_add_feature_multi;
  iface->add_feature_with_image = i_face_log_client_add_feature_with_image;
  iface->add_image = i_face_log_client_add_image;
  iface->add_log = i_face_log_client_add_log;
  iface->add_log_full = i_face_log_client_add_log_full;
  iface->add_logs = i_face_log_client_add_logs;
  iface->add_logs_full = i_face_log_client_add_logs_full;
  iface->apply_ack_channel = i_face_log_client_apply_ack_channel;
  iface->apply_ack_channel_with_duration = i_face_log_client_apply_ack_channel_with_duration;
  iface->apply_cmd_sn = i_face_log_client_apply_cmd_sn;
  iface->apply_person_token = i_face_log_client_apply_person_token;
  iface->apply_root_token = i_face_log_client_apply_root_token;
  iface->apply_user_token = i_face_log_client_apply_user_token;
  iface->bind_border = i_face_log_client_bind_border;
  iface->child_list_for_device_group = i_face_log_client_child_list_for_device_group;
  iface->child_list_for_person_group = i_face_log_client_child_list_for_person_group;
  iface->count_device_by_where = i_face_log_client_count_device_by_where;
  iface->count_device_group_by_where = i_face_log_client_count_device_group_by_where;
  iface->count_log_by_where = i_face_log_client_count_log_by_where;
  iface->count_log_light_by_verify_time = i_face_log_client_count_log_light_by_verify_time;
  iface->count_log_light_by_verify_time_timestr = i_face_log_client_count_log_light_by_verify_time_timestr;
  iface->count_log_light_by_where = i_face_log_client_count_log_light_by_where;
  iface->count_person_by_where = i_face_log_client_count_person_by_where;
  iface->count_person_group_by_where = i_face_log_client_count_person_group_by_where;
  iface->delete_all_features_by_person_id = i_face_log_client_delete_all_features_by_person_id;
  iface->delete_device_group = i_face_log_client_delete_device_group;
  iface->delete_feature = i_face_log_client_delete_feature;
  iface->delete_group_permit_on_device_group = i_face_log_client_delete_group_permit_on_device_group;
  iface->delete_image = i_face_log_client_delete_image;
  iface->delete_permit_by_id = i_face_log_client_delete_permit_by_id;
  iface->delete_person = i_face_log_client_delete_person;
  iface->delete_person_by_papers_num = i_face_log_client_delete_person_by_papers_num;
  iface->delete_person_group = i_face_log_client_delete_person_group;
  iface->delete_person_group_permit = i_face_log_client_delete_person_group_permit;
  iface->delete_persons = i_face_log_client_delete_persons;
  iface->delete_persons_by_papers_num = i_face_log_client_delete_persons_by_papers_num;
  iface->disable_person = i_face_log_client_disable_person;
  iface->disable_person_list = i_face_log_client_disable_person_list;
  iface->exists_device = i_face_log_client_exists_device;
  iface->exists_feature = i_face_log_client_exists_feature;
  iface->exists_image = i_face_log_client_exists_image;
  iface->exists_person = i_face_log_client_exists_person;
  iface->get_device = i_face_log_client_get_device;
  iface->get_device_by_mac = i_face_log_client_get_device_by_mac;
  iface->get_device_group = i_face_log_client_get_device_group;
  iface->get_device_groups = i_face_log_client_get_device_groups;
  iface->get_device_groups_belongs = i_face_log_client_get_device_groups_belongs;
  iface->get_device_groups_permit = i_face_log_client_get_device_groups_permit;
  iface->get_device_groups_permitted_by = i_face_log_client_get_device_groups_permitted_by;
  iface->get_device_id_of_feature = i_face_log_client_get_device_id_of_feature;
  iface->get_devices = i_face_log_client_get_devices;
  iface->get_devices_of_group = i_face_log_client_get_devices_of_group;
  iface->get_face = i_face_log_client_get_face;
  iface->get_feature = i_face_log_client_get_feature;
  iface->get_feature_bytes = i_face_log_client_get_feature_bytes;
  iface->get_features = i_face_log_client_get_features;
  iface->get_features_by_person_id_and_sdk_version = i_face_log_client_get_features_by_person_id_and_sdk_version;
  iface->get_features_of_person = i_face_log_client_get_features_of_person;
  iface->get_features_permitted_on_device = i_face_log_client_get_features_permitted_on_device;
  iface->get_group_permit = i_face_log_client_get_group_permit;
  iface->get_group_permit_on_device_group = i_face_log_client_get_group_permit_on_device_group;
  iface->get_group_permits = i_face_log_client_get_group_permits;
  iface->get_image = i_face_log_client_get_image;
  iface->get_image_bytes = i_face_log_client_get_image_bytes;
  iface->get_images_associated_by_feature = i_face_log_client_get_images_associated_by_feature;
  iface->get_log_beans_by_person_id = i_face_log_client_get_log_beans_by_person_id;
  iface->get_person = i_face_log_client_get_person;
  iface->get_person_by_mobile_phone = i_face_log_client_get_person_by_mobile_phone;
  iface->get_person_by_papers_num = i_face_log_client_get_person_by_papers_num;
  iface->get_person_group = i_face_log_client_get_person_group;
  iface->get_person_groups = i_face_log_client_get_person_groups;
  iface->get_person_groups_belongs = i_face_log_client_get_person_groups_belongs;
  iface->get_person_groups_permitted_by = i_face_log_client_get_person_groups_permitted_by;
  iface->get_person_permit = i_face_log_client_get_person_permit;
  iface->get_person_permits = i_face_log_client_get_person_permits;
  iface->get_persons = i_face_log_client_get_persons;
  iface->get_persons_of_group = i_face_log_client_get_persons_of_group;
  iface->get_persons_permitted_on_device = i_face_log_client_get_persons_permitted_on_device;
  iface->get_properties = i_face_log_client_get_properties;
  iface->get_property = i_face_log_client_get_property;
  iface->get_redis_parameters = i_face_log_client_get_redis_parameters;
  iface->get_service_config = i_face_log_client_get_service_config;
  iface->get_sub_device_group = i_face_log_client_get_sub_device_group;
  iface->get_sub_person_group = i_face_log_client_get_sub_person_group;
  iface->is_disable = i_face_log_client_is_disable;
  iface->is_local = i_face_log_client_is_local;
  iface->is_valid_ack_channel = i_face_log_client_is_valid_ack_channel;
  iface->is_valid_cmd_sn = i_face_log_client_is_valid_cmd_sn;
  iface->is_valid_device_token = i_face_log_client_is_valid_device_token;
  iface->is_valid_password = i_face_log_client_is_valid_password;
  iface->is_valid_person_token = i_face_log_client_is_valid_person_token;
  iface->is_valid_root_token = i_face_log_client_is_valid_root_token;
  iface->is_valid_token = i_face_log_client_is_valid_token;
  iface->is_valid_user_token = i_face_log_client_is_valid_user_token;
  iface->list_of_parent_for_device_group = i_face_log_client_list_of_parent_for_device_group;
  iface->list_of_parent_for_person_group = i_face_log_client_list_of_parent_for_person_group;
  iface->load_all_person = i_face_log_client_load_all_person;
  iface->load_device_by_where = i_face_log_client_load_device_by_where;
  iface->load_device_group_by_where = i_face_log_client_load_device_group_by_where;
  iface->load_device_group_id_by_where = i_face_log_client_load_device_group_id_by_where;
  iface->load_device_id_by_where = i_face_log_client_load_device_id_by_where;
  iface->load_distinct_integer_column = i_face_log_client_load_distinct_integer_column;
  iface->load_distinct_string_column = i_face_log_client_load_distinct_string_column;
  iface->load_feature_md5_by_update = i_face_log_client_load_feature_md5_by_update;
  iface->load_feature_md5_by_update_time_str = i_face_log_client_load_feature_md5_by_update_time_str;
  iface->load_log_by_where = i_face_log_client_load_log_by_where;
  iface->load_log_light_by_verify_time = i_face_log_client_load_log_light_by_verify_time;
  iface->load_log_light_by_verify_time_timestr = i_face_log_client_load_log_light_by_verify_time_timestr;
  iface->load_log_light_by_where = i_face_log_client_load_log_light_by_where;
  iface->load_permit_by_update = i_face_log_client_load_permit_by_update;
  iface->load_permit_by_update_timestr = i_face_log_client_load_permit_by_update_timestr;
  iface->load_person_by_where = i_face_log_client_load_person_by_where;
  iface->load_person_group_by_where = i_face_log_client_load_person_group_by_where;
  iface->load_person_group_id_by_where = i_face_log_client_load_person_group_id_by_where;
  iface->load_person_id_by_update_time = i_face_log_client_load_person_id_by_update_time;
  iface->load_person_id_by_update_time_time_str = i_face_log_client_load_person_id_by_update_time_time_str;
  iface->load_person_id_by_where = i_face_log_client_load_person_id_by_where;
  iface->load_updated_persons = i_face_log_client_load_updated_persons;
  iface->load_updated_persons_timestr = i_face_log_client_load_updated_persons_timestr;
  iface->offline = i_face_log_client_offline;
  iface->online = i_face_log_client_online;
  iface->register_device = i_face_log_client_register_device;
  iface->release_person_token = i_face_log_client_release_person_token;
  iface->release_root_token = i_face_log_client_release_root_token;
  iface->release_user_token = i_face_log_client_release_user_token;
  iface->replace_feature = i_face_log_client_replace_feature;
  iface->root_group_of_device = i_face_log_client_root_group_of_device;
  iface->root_group_of_person = i_face_log_client_root_group_of_person;
  iface->run_cmd = i_face_log_client_run_cmd;
  iface->run_task = i_face_log_client_run_task;
  iface->save_device = i_face_log_client_save_device;
  iface->save_device_group = i_face_log_client_save_device_group;
  iface->save_permit = i_face_log_client_save_permit;
  iface->save_permit_with_schedule = i_face_log_client_save_permit_with_schedule;
  iface->save_person = i_face_log_client_save_person;
  iface->save_person_full = i_face_log_client_save_person_full;
  iface->save_person_group = i_face_log_client_save_person_group;
  iface->save_person_with_photo = i_face_log_client_save_person_with_photo;
  iface->save_person_with_photo_and_feature = i_face_log_client_save_person_with_photo_and_feature;
  iface->save_person_with_photo_and_feature_multi_faces = i_face_log_client_save_person_with_photo_and_feature_multi_faces;
  iface->save_person_with_photo_and_feature_multi_image = i_face_log_client_save_person_with_photo_and_feature_multi_image;
  iface->save_person_with_photo_and_feature_saved = i_face_log_client_save_person_with_photo_and_feature_saved;
  iface->save_persons = i_face_log_client_save_persons;
  iface->save_persons_with_photo = i_face_log_client_save_persons_with_photo;
  iface->save_service_config = i_face_log_client_save_service_config;
  iface->sdk_task_queue_of = i_face_log_client_sdk_task_queue_of;
  iface->set_person_expiry_date = i_face_log_client_set_person_expiry_date;
  iface->set_person_expiry_date_list = i_face_log_client_set_person_expiry_date_list;
  iface->set_person_expiry_date_time_str = i_face_log_client_set_person_expiry_date_time_str;
  iface->set_properties = i_face_log_client_set_properties;
  iface->set_property = i_face_log_client_set_property;
  iface->task_queue_of = i_face_log_client_task_queue_of;
  iface->unbind_border = i_face_log_client_unbind_border;
  iface->unregister_device = i_face_log_client_unregister_device;
  iface->update_device = i_face_log_client_update_device;
  iface->version = i_face_log_client_version;
  iface->version_info = i_face_log_client_version_info;
}

static void
i_face_log_client_init (IFaceLogClient *client)
{
  client->input_protocol = NULL;
  client->output_protocol = NULL;
}

static void
i_face_log_client_class_init (IFaceLogClientClass *cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  GParamSpec *param_spec;

  gobject_class->set_property = i_face_log_client_set_property;
  gobject_class->get_property = i_face_log_client_get_property;

  param_spec = g_param_spec_object ("input_protocol",
                                    "input protocol (construct)",
                                    "Set the client input protocol",
                                    THRIFT_TYPE_PROTOCOL,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_I_FACE_LOG_CLIENT_INPUT_PROTOCOL, param_spec);

  param_spec = g_param_spec_object ("output_protocol",
                                    "output protocol (construct)",
                                    "Set the client output protocol",
                                    THRIFT_TYPE_PROTOCOL,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_I_FACE_LOG_CLIENT_OUTPUT_PROTOCOL, param_spec);
}

static void
i_face_log_handler_i_face_log_if_interface_init (IFaceLogIfInterface *iface);

G_DEFINE_TYPE_WITH_CODE (IFaceLogHandler, 
                         i_face_log_handler,
                         G_TYPE_OBJECT,
                         G_IMPLEMENT_INTERFACE (TYPE_I_FACE_LOG_IF,
                                                i_face_log_handler_i_face_log_if_interface_init))

gboolean i_face_log_handler_add_feature (IFaceLogIf * iface, FeatureBean ** _return, const GByteArray * feature, const gchar * featureVersion, const gint32 personId, const GPtrArray * faecBeans, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->add_feature (iface, _return, feature, featureVersion, personId, faecBeans, token, ex1, ex2, error);
}

gboolean i_face_log_handler_add_feature_multi (IFaceLogIf * iface, FeatureBean ** _return, const GByteArray * feature, const gchar * featureVersion, const gint32 personId, const GPtrArray * photos, const GPtrArray * faces, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->add_feature_multi (iface, _return, feature, featureVersion, personId, photos, faces, token, ex1, ex2, error);
}

gboolean i_face_log_handler_add_feature_with_image (IFaceLogIf * iface, FeatureBean ** _return, const GByteArray * feature, const gchar * featureVersion, const gint32 personId, const gboolean asIdPhotoIfAbsent, const GByteArray * featurePhoto, const FaceBean * faceBean, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->add_feature_with_image (iface, _return, feature, featureVersion, personId, asIdPhotoIfAbsent, featurePhoto, faceBean, token, ex1, ex2, error);
}

gboolean i_face_log_handler_add_image (IFaceLogIf * iface, ImageBean ** _return, const GByteArray * imageData, const gint32 deviceId, const FaceBean * faceBean, const gint32 personId, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->add_image (iface, _return, imageData, deviceId, faceBean, personId, token, ex1, ex2, error);
}

gboolean i_face_log_handler_add_log (IFaceLogIf * iface, const LogBean * logBean, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->add_log (iface, logBean, token, ex1, ex2, error);
}

gboolean i_face_log_handler_add_log_full (IFaceLogIf * iface, const LogBean * logBean, const FaceBean * faceBean, const GByteArray * featureImage, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->add_log_full (iface, logBean, faceBean, featureImage, token, ex1, ex2, error);
}

gboolean i_face_log_handler_add_logs (IFaceLogIf * iface, const GPtrArray * beans, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->add_logs (iface, beans, token, ex1, ex2, error);
}

gboolean i_face_log_handler_add_logs_full (IFaceLogIf * iface, const GPtrArray * logBeans, const GPtrArray * faceBeans, const GPtrArray * featureImages, const Token * token, DuplicateRecordException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->add_logs_full (iface, logBeans, faceBeans, featureImages, token, ex1, ex2, error);
}

gboolean i_face_log_handler_apply_ack_channel (IFaceLogIf * iface, gchar ** _return, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->apply_ack_channel (iface, _return, token, ex1, error);
}

gboolean i_face_log_handler_apply_ack_channel_with_duration (IFaceLogIf * iface, gchar ** _return, const gint32 duration, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->apply_ack_channel_with_duration (iface, _return, duration, token, ex1, error);
}

gboolean i_face_log_handler_apply_cmd_sn (IFaceLogIf * iface, gint32* _return, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->apply_cmd_sn (iface, _return, token, ex1, error);
}

gboolean i_face_log_handler_apply_person_token (IFaceLogIf * iface, Token ** _return, const gint32 personId, const gchar * password, const gboolean isMd5, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->apply_person_token (iface, _return, personId, password, isMd5, ex1, ex2, error);
}

gboolean i_face_log_handler_apply_root_token (IFaceLogIf * iface, Token ** _return, const gchar * password, const gboolean isMd5, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->apply_root_token (iface, _return, password, isMd5, ex1, ex2, error);
}

gboolean i_face_log_handler_apply_user_token (IFaceLogIf * iface, Token ** _return, const gint32 userid, const gchar * password, const gboolean isMd5, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->apply_user_token (iface, _return, userid, password, isMd5, ex1, ex2, error);
}

gboolean i_face_log_handler_bind_border (IFaceLogIf * iface, const gint32 personGroupId, const gint32 deviceGroupId, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->bind_border (iface, personGroupId, deviceGroupId, token, ex1, error);
}

gboolean i_face_log_handler_child_list_for_device_group (IFaceLogIf * iface, GArray ** _return, const gint32 deviceGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->child_list_for_device_group (iface, _return, deviceGroupId, ex1, error);
}

gboolean i_face_log_handler_child_list_for_person_group (IFaceLogIf * iface, GArray ** _return, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->child_list_for_person_group (iface, _return, personGroupId, ex1, error);
}

gboolean i_face_log_handler_count_device_by_where (IFaceLogIf * iface, gint32* _return, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->count_device_by_where (iface, _return, where, ex1, error);
}

gboolean i_face_log_handler_count_device_group_by_where (IFaceLogIf * iface, gint32* _return, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->count_device_group_by_where (iface, _return, where, ex1, error);
}

gboolean i_face_log_handler_count_log_by_where (IFaceLogIf * iface, gint32* _return, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->count_log_by_where (iface, _return, where, ex1, error);
}

gboolean i_face_log_handler_count_log_light_by_verify_time (IFaceLogIf * iface, gint32* _return, const gint64 timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->count_log_light_by_verify_time (iface, _return, timestamp, ex1, error);
}

gboolean i_face_log_handler_count_log_light_by_verify_time_timestr (IFaceLogIf * iface, gint32* _return, const gchar * timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->count_log_light_by_verify_time_timestr (iface, _return, timestamp, ex1, error);
}

gboolean i_face_log_handler_count_log_light_by_where (IFaceLogIf * iface, gint32* _return, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->count_log_light_by_where (iface, _return, where, ex1, error);
}

gboolean i_face_log_handler_count_person_by_where (IFaceLogIf * iface, gint32* _return, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->count_person_by_where (iface, _return, where, ex1, error);
}

gboolean i_face_log_handler_count_person_group_by_where (IFaceLogIf * iface, gint32* _return, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->count_person_group_by_where (iface, _return, where, ex1, error);
}

gboolean i_face_log_handler_delete_all_features_by_person_id (IFaceLogIf * iface, gint32* _return, const gint32 personId, const gboolean deleteImage, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->delete_all_features_by_person_id (iface, _return, personId, deleteImage, token, ex1, error);
}

gboolean i_face_log_handler_delete_device_group (IFaceLogIf * iface, gint32* _return, const gint32 deviceGroupId, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->delete_device_group (iface, _return, deviceGroupId, token, ex1, error);
}

gboolean i_face_log_handler_delete_feature (IFaceLogIf * iface, GPtrArray ** _return, const gchar * featureMd5, const gboolean deleteImage, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->delete_feature (iface, _return, featureMd5, deleteImage, token, ex1, error);
}

gboolean i_face_log_handler_delete_group_permit_on_device_group (IFaceLogIf * iface, gint32* _return, const gint32 deviceGroupId, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->delete_group_permit_on_device_group (iface, _return, deviceGroupId, token, ex1, error);
}

gboolean i_face_log_handler_delete_image (IFaceLogIf * iface, gint32* _return, const gchar * imageMd5, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->delete_image (iface, _return, imageMd5, token, ex1, error);
}

gboolean i_face_log_handler_delete_permit_by_id (IFaceLogIf * iface, gint32* _return, const gint32 deviceGroupId, const gint32 personGroupId, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->delete_permit_by_id (iface, _return, deviceGroupId, personGroupId, token, ex1, error);
}

gboolean i_face_log_handler_delete_person (IFaceLogIf * iface, gint32* _return, const gint32 personId, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->delete_person (iface, _return, personId, token, ex1, error);
}

gboolean i_face_log_handler_delete_person_by_papers_num (IFaceLogIf * iface, gint32* _return, const gchar * papersNum, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->delete_person_by_papers_num (iface, _return, papersNum, token, ex1, error);
}

gboolean i_face_log_handler_delete_person_group (IFaceLogIf * iface, gint32* _return, const gint32 personGroupId, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->delete_person_group (iface, _return, personGroupId, token, ex1, error);
}

gboolean i_face_log_handler_delete_person_group_permit (IFaceLogIf * iface, gint32* _return, const gint32 personGroupId, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->delete_person_group_permit (iface, _return, personGroupId, token, ex1, error);
}

gboolean i_face_log_handler_delete_persons (IFaceLogIf * iface, gint32* _return, const GArray * personIdList, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->delete_persons (iface, _return, personIdList, token, ex1, error);
}

gboolean i_face_log_handler_delete_persons_by_papers_num (IFaceLogIf * iface, gint32* _return, const GPtrArray * papersNumlist, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->delete_persons_by_papers_num (iface, _return, papersNumlist, token, ex1, error);
}

gboolean i_face_log_handler_disable_person (IFaceLogIf * iface, const gint32 personId, const gint32 moveToGroupId, const gboolean deletePhoto, const gboolean deleteFeature, const gboolean deleteLog, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->disable_person (iface, personId, moveToGroupId, deletePhoto, deleteFeature, deleteLog, token, ex1, error);
}

gboolean i_face_log_handler_disable_person_list (IFaceLogIf * iface, const GArray * personIdList, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->disable_person_list (iface, personIdList, token, ex1, error);
}

gboolean i_face_log_handler_exists_device (IFaceLogIf * iface, gboolean* _return, const gint32 id, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->exists_device (iface, _return, id, ex1, error);
}

gboolean i_face_log_handler_exists_feature (IFaceLogIf * iface, gboolean* _return, const gchar * md5, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->exists_feature (iface, _return, md5, ex1, error);
}

gboolean i_face_log_handler_exists_image (IFaceLogIf * iface, gboolean* _return, const gchar * md5, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->exists_image (iface, _return, md5, ex1, error);
}

gboolean i_face_log_handler_exists_person (IFaceLogIf * iface, gboolean* _return, const gint32 persionId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->exists_person (iface, _return, persionId, ex1, error);
}

gboolean i_face_log_handler_get_device (IFaceLogIf * iface, DeviceBean ** _return, const gint32 deviceId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_device (iface, _return, deviceId, ex1, error);
}

gboolean i_face_log_handler_get_device_by_mac (IFaceLogIf * iface, DeviceBean ** _return, const gchar * mac, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_device_by_mac (iface, _return, mac, ex1, error);
}

gboolean i_face_log_handler_get_device_group (IFaceLogIf * iface, DeviceGroupBean ** _return, const gint32 deviceGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_device_group (iface, _return, deviceGroupId, ex1, error);
}

gboolean i_face_log_handler_get_device_groups (IFaceLogIf * iface, GPtrArray ** _return, const GArray * groupIdList, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_device_groups (iface, _return, groupIdList, ex1, error);
}

gboolean i_face_log_handler_get_device_groups_belongs (IFaceLogIf * iface, GArray ** _return, const gint32 deviceId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_device_groups_belongs (iface, _return, deviceId, ex1, error);
}

gboolean i_face_log_handler_get_device_groups_permit (IFaceLogIf * iface, GArray ** _return, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_device_groups_permit (iface, _return, personGroupId, ex1, error);
}

gboolean i_face_log_handler_get_device_groups_permitted_by (IFaceLogIf * iface, GArray ** _return, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_device_groups_permitted_by (iface, _return, personGroupId, ex1, error);
}

gboolean i_face_log_handler_get_device_id_of_feature (IFaceLogIf * iface, gint32* _return, const gchar * featureMd5, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_device_id_of_feature (iface, _return, featureMd5, ex1, error);
}

gboolean i_face_log_handler_get_devices (IFaceLogIf * iface, GPtrArray ** _return, const GArray * idList, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_devices (iface, _return, idList, ex1, error);
}

gboolean i_face_log_handler_get_devices_of_group (IFaceLogIf * iface, GArray ** _return, const gint32 deviceGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_devices_of_group (iface, _return, deviceGroupId, ex1, error);
}

gboolean i_face_log_handler_get_face (IFaceLogIf * iface, FaceBean ** _return, const gint32 faceId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_face (iface, _return, faceId, ex1, error);
}

gboolean i_face_log_handler_get_feature (IFaceLogIf * iface, FeatureBean ** _return, const gchar * md5, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_feature (iface, _return, md5, ex1, error);
}

gboolean i_face_log_handler_get_feature_bytes (IFaceLogIf * iface, GByteArray ** _return, const gchar * md5, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_feature_bytes (iface, _return, md5, ex1, error);
}

gboolean i_face_log_handler_get_features (IFaceLogIf * iface, GPtrArray ** _return, const GPtrArray * md5, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_features (iface, _return, md5, ex1, error);
}

gboolean i_face_log_handler_get_features_by_person_id_and_sdk_version (IFaceLogIf * iface, GPtrArray ** _return, const gint32 personId, const gchar * sdkVersion, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_features_by_person_id_and_sdk_version (iface, _return, personId, sdkVersion, ex1, error);
}

gboolean i_face_log_handler_get_features_of_person (IFaceLogIf * iface, GPtrArray ** _return, const gint32 personId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_features_of_person (iface, _return, personId, ex1, error);
}

gboolean i_face_log_handler_get_features_permitted_on_device (IFaceLogIf * iface, GPtrArray ** _return, const gint32 deviceId, const gboolean ignoreSchedule, const gchar * sdkVersion, const GPtrArray * excludeFeatureIds, const gint64 timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_features_permitted_on_device (iface, _return, deviceId, ignoreSchedule, sdkVersion, excludeFeatureIds, timestamp, ex1, error);
}

gboolean i_face_log_handler_get_group_permit (IFaceLogIf * iface, PermitBean ** _return, const gint32 deviceId, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_group_permit (iface, _return, deviceId, personGroupId, ex1, error);
}

gboolean i_face_log_handler_get_group_permit_on_device_group (IFaceLogIf * iface, PermitBean ** _return, const gint32 deviceGroupId, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_group_permit_on_device_group (iface, _return, deviceGroupId, personGroupId, ex1, error);
}

gboolean i_face_log_handler_get_group_permits (IFaceLogIf * iface, GPtrArray ** _return, const gint32 deviceId, const GArray * personGroupIdList, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_group_permits (iface, _return, deviceId, personGroupIdList, ex1, error);
}

gboolean i_face_log_handler_get_image (IFaceLogIf * iface, ImageBean ** _return, const gchar * imageMD5, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_image (iface, _return, imageMD5, ex1, error);
}

gboolean i_face_log_handler_get_image_bytes (IFaceLogIf * iface, GByteArray ** _return, const gchar * imageMD5, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_image_bytes (iface, _return, imageMD5, ex1, error);
}

gboolean i_face_log_handler_get_images_associated_by_feature (IFaceLogIf * iface, GPtrArray ** _return, const gchar * featureMd5, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_images_associated_by_feature (iface, _return, featureMd5, ex1, error);
}

gboolean i_face_log_handler_get_log_beans_by_person_id (IFaceLogIf * iface, GPtrArray ** _return, const gint32 personId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_log_beans_by_person_id (iface, _return, personId, ex1, error);
}

gboolean i_face_log_handler_get_person (IFaceLogIf * iface, PersonBean ** _return, const gint32 personId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_person (iface, _return, personId, ex1, error);
}

gboolean i_face_log_handler_get_person_by_mobile_phone (IFaceLogIf * iface, PersonBean ** _return, const gchar * mobilePhone, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_person_by_mobile_phone (iface, _return, mobilePhone, ex1, error);
}

gboolean i_face_log_handler_get_person_by_papers_num (IFaceLogIf * iface, PersonBean ** _return, const gchar * papersNum, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_person_by_papers_num (iface, _return, papersNum, ex1, error);
}

gboolean i_face_log_handler_get_person_group (IFaceLogIf * iface, PersonGroupBean ** _return, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_person_group (iface, _return, personGroupId, ex1, error);
}

gboolean i_face_log_handler_get_person_groups (IFaceLogIf * iface, GPtrArray ** _return, const GArray * groupIdList, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_person_groups (iface, _return, groupIdList, ex1, error);
}

gboolean i_face_log_handler_get_person_groups_belongs (IFaceLogIf * iface, GArray ** _return, const gint32 personId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_person_groups_belongs (iface, _return, personId, ex1, error);
}

gboolean i_face_log_handler_get_person_groups_permitted_by (IFaceLogIf * iface, GArray ** _return, const gint32 deviceGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_person_groups_permitted_by (iface, _return, deviceGroupId, ex1, error);
}

gboolean i_face_log_handler_get_person_permit (IFaceLogIf * iface, PermitBean ** _return, const gint32 deviceId, const gint32 personId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_person_permit (iface, _return, deviceId, personId, ex1, error);
}

gboolean i_face_log_handler_get_person_permits (IFaceLogIf * iface, GPtrArray ** _return, const gint32 deviceId, const GArray * personIdList, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_person_permits (iface, _return, deviceId, personIdList, ex1, error);
}

gboolean i_face_log_handler_get_persons (IFaceLogIf * iface, GPtrArray ** _return, const GArray * idList, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_persons (iface, _return, idList, ex1, error);
}

gboolean i_face_log_handler_get_persons_of_group (IFaceLogIf * iface, GArray ** _return, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_persons_of_group (iface, _return, personGroupId, ex1, error);
}

gboolean i_face_log_handler_get_persons_permitted_on_device (IFaceLogIf * iface, GArray ** _return, const gint32 deviceId, const gboolean ignoreSchedule, const GArray * excludePersonIds, const gint64 timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_persons_permitted_on_device (iface, _return, deviceId, ignoreSchedule, excludePersonIds, timestamp, ex1, error);
}

gboolean i_face_log_handler_get_properties (IFaceLogIf * iface, GHashTable ** _return, const gchar * prefix, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_properties (iface, _return, prefix, token, ex1, error);
}

gboolean i_face_log_handler_get_property (IFaceLogIf * iface, gchar ** _return, const gchar * key, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_property (iface, _return, key, token, ex1, error);
}

gboolean i_face_log_handler_get_redis_parameters (IFaceLogIf * iface, GHashTable ** _return, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_redis_parameters (iface, _return, token, ex1, error);
}

gboolean i_face_log_handler_get_service_config (IFaceLogIf * iface, GHashTable ** _return, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_service_config (iface, _return, token, ex1, error);
}

gboolean i_face_log_handler_get_sub_device_group (IFaceLogIf * iface, GArray ** _return, const gint32 deviceGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_sub_device_group (iface, _return, deviceGroupId, ex1, error);
}

gboolean i_face_log_handler_get_sub_person_group (IFaceLogIf * iface, GArray ** _return, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->get_sub_person_group (iface, _return, personGroupId, ex1, error);
}

gboolean i_face_log_handler_is_disable (IFaceLogIf * iface, gboolean* _return, const gint32 personId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->is_disable (iface, _return, personId, ex1, error);
}

gboolean i_face_log_handler_is_local (IFaceLogIf * iface, gboolean* _return, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->is_local (iface, _return, ex1, error);
}

gboolean i_face_log_handler_is_valid_ack_channel (IFaceLogIf * iface, gboolean* _return, const gchar * ackChannel, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->is_valid_ack_channel (iface, _return, ackChannel, ex1, error);
}

gboolean i_face_log_handler_is_valid_cmd_sn (IFaceLogIf * iface, gboolean* _return, const gint32 cmdSn, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->is_valid_cmd_sn (iface, _return, cmdSn, ex1, error);
}

gboolean i_face_log_handler_is_valid_device_token (IFaceLogIf * iface, gboolean* _return, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->is_valid_device_token (iface, _return, token, ex1, error);
}

gboolean i_face_log_handler_is_valid_password (IFaceLogIf * iface, gboolean* _return, const gchar * userId, const gchar * password, const gboolean isMd5, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->is_valid_password (iface, _return, userId, password, isMd5, ex1, error);
}

gboolean i_face_log_handler_is_valid_person_token (IFaceLogIf * iface, gboolean* _return, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->is_valid_person_token (iface, _return, token, ex1, error);
}

gboolean i_face_log_handler_is_valid_root_token (IFaceLogIf * iface, gboolean* _return, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->is_valid_root_token (iface, _return, token, ex1, error);
}

gboolean i_face_log_handler_is_valid_token (IFaceLogIf * iface, gboolean* _return, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->is_valid_token (iface, _return, token, ex1, error);
}

gboolean i_face_log_handler_is_valid_user_token (IFaceLogIf * iface, gboolean* _return, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->is_valid_user_token (iface, _return, token, ex1, error);
}

gboolean i_face_log_handler_list_of_parent_for_device_group (IFaceLogIf * iface, GArray ** _return, const gint32 deviceGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->list_of_parent_for_device_group (iface, _return, deviceGroupId, ex1, error);
}

gboolean i_face_log_handler_list_of_parent_for_person_group (IFaceLogIf * iface, GArray ** _return, const gint32 personGroupId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->list_of_parent_for_person_group (iface, _return, personGroupId, ex1, error);
}

gboolean i_face_log_handler_load_all_person (IFaceLogIf * iface, GArray ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_all_person (iface, _return, ex1, error);
}

gboolean i_face_log_handler_load_device_by_where (IFaceLogIf * iface, GPtrArray ** _return, const gchar * where, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_device_by_where (iface, _return, where, startRow, numRows, ex1, error);
}

gboolean i_face_log_handler_load_device_group_by_where (IFaceLogIf * iface, GArray ** _return, const gchar * where, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_device_group_by_where (iface, _return, where, startRow, numRows, ex1, error);
}

gboolean i_face_log_handler_load_device_group_id_by_where (IFaceLogIf * iface, GArray ** _return, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_device_group_id_by_where (iface, _return, where, ex1, error);
}

gboolean i_face_log_handler_load_device_id_by_where (IFaceLogIf * iface, GArray ** _return, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_device_id_by_where (iface, _return, where, ex1, error);
}

gboolean i_face_log_handler_load_distinct_integer_column (IFaceLogIf * iface, GArray ** _return, const gchar * table, const gchar * column, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_distinct_integer_column (iface, _return, table, column, where, ex1, error);
}

gboolean i_face_log_handler_load_distinct_string_column (IFaceLogIf * iface, GPtrArray ** _return, const gchar * table, const gchar * column, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_distinct_string_column (iface, _return, table, column, where, ex1, error);
}

gboolean i_face_log_handler_load_feature_md5_by_update (IFaceLogIf * iface, GPtrArray ** _return, const gint64 timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_feature_md5_by_update (iface, _return, timestamp, ex1, error);
}

gboolean i_face_log_handler_load_feature_md5_by_update_time_str (IFaceLogIf * iface, GPtrArray ** _return, const gchar * timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_feature_md5_by_update_time_str (iface, _return, timestamp, ex1, error);
}

gboolean i_face_log_handler_load_log_by_where (IFaceLogIf * iface, GPtrArray ** _return, const gchar * where, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_log_by_where (iface, _return, where, startRow, numRows, ex1, error);
}

gboolean i_face_log_handler_load_log_light_by_verify_time (IFaceLogIf * iface, GPtrArray ** _return, const gint64 timestamp, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_log_light_by_verify_time (iface, _return, timestamp, startRow, numRows, ex1, error);
}

gboolean i_face_log_handler_load_log_light_by_verify_time_timestr (IFaceLogIf * iface, GPtrArray ** _return, const gchar * timestamp, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_log_light_by_verify_time_timestr (iface, _return, timestamp, startRow, numRows, ex1, error);
}

gboolean i_face_log_handler_load_log_light_by_where (IFaceLogIf * iface, GPtrArray ** _return, const gchar * where, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_log_light_by_where (iface, _return, where, startRow, numRows, ex1, error);
}

gboolean i_face_log_handler_load_permit_by_update (IFaceLogIf * iface, GPtrArray ** _return, const gint64 timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_permit_by_update (iface, _return, timestamp, ex1, error);
}

gboolean i_face_log_handler_load_permit_by_update_timestr (IFaceLogIf * iface, GPtrArray ** _return, const gchar * timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_permit_by_update_timestr (iface, _return, timestamp, ex1, error);
}

gboolean i_face_log_handler_load_person_by_where (IFaceLogIf * iface, GPtrArray ** _return, const gchar * where, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_person_by_where (iface, _return, where, startRow, numRows, ex1, error);
}

gboolean i_face_log_handler_load_person_group_by_where (IFaceLogIf * iface, GArray ** _return, const gchar * where, const gint32 startRow, const gint32 numRows, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_person_group_by_where (iface, _return, where, startRow, numRows, ex1, error);
}

gboolean i_face_log_handler_load_person_group_id_by_where (IFaceLogIf * iface, GArray ** _return, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_person_group_id_by_where (iface, _return, where, ex1, error);
}

gboolean i_face_log_handler_load_person_id_by_update_time (IFaceLogIf * iface, GArray ** _return, const gint64 timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_person_id_by_update_time (iface, _return, timestamp, ex1, error);
}

gboolean i_face_log_handler_load_person_id_by_update_time_time_str (IFaceLogIf * iface, GArray ** _return, const gchar * timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_person_id_by_update_time_time_str (iface, _return, timestamp, ex1, error);
}

gboolean i_face_log_handler_load_person_id_by_where (IFaceLogIf * iface, GArray ** _return, const gchar * where, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_person_id_by_where (iface, _return, where, ex1, error);
}

gboolean i_face_log_handler_load_updated_persons (IFaceLogIf * iface, GArray ** _return, const gint64 timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_updated_persons (iface, _return, timestamp, ex1, error);
}

gboolean i_face_log_handler_load_updated_persons_timestr (IFaceLogIf * iface, GArray ** _return, const gchar * timestamp, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->load_updated_persons_timestr (iface, _return, timestamp, ex1, error);
}

gboolean i_face_log_handler_offline (IFaceLogIf * iface, const Token * token, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->offline (iface, token, ex1, ex2, error);
}

gboolean i_face_log_handler_online (IFaceLogIf * iface, Token ** _return, const DeviceBean * device, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->online (iface, _return, device, ex1, ex2, error);
}

gboolean i_face_log_handler_register_device (IFaceLogIf * iface, DeviceBean ** _return, const DeviceBean * newDevice, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->register_device (iface, _return, newDevice, ex1, ex2, error);
}

gboolean i_face_log_handler_release_person_token (IFaceLogIf * iface, const Token * token, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->release_person_token (iface, token, ex1, ex2, error);
}

gboolean i_face_log_handler_release_root_token (IFaceLogIf * iface, const Token * token, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->release_root_token (iface, token, ex1, ex2, error);
}

gboolean i_face_log_handler_release_user_token (IFaceLogIf * iface, const Token * token, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->release_user_token (iface, token, ex1, ex2, error);
}

gboolean i_face_log_handler_replace_feature (IFaceLogIf * iface, const gint32 personId, const gchar * featureMd5, const gboolean deleteOldFeatureImage, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->replace_feature (iface, personId, featureMd5, deleteOldFeatureImage, token, ex1, error);
}

gboolean i_face_log_handler_root_group_of_device (IFaceLogIf * iface, gint32* _return, const gint32 deviceId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->root_group_of_device (iface, _return, deviceId, ex1, error);
}

gboolean i_face_log_handler_root_group_of_person (IFaceLogIf * iface, gint32* _return, const gint32 personId, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->root_group_of_person (iface, _return, personId, ex1, error);
}

gboolean i_face_log_handler_run_cmd (IFaceLogIf * iface, gchar ** _return, const GArray * target, const gboolean group, const gchar * cmdpath, const gchar * jsonArgs, const gchar * ackChannel, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->run_cmd (iface, _return, target, group, cmdpath, jsonArgs, ackChannel, token, ex1, error);
}

gboolean i_face_log_handler_run_task (IFaceLogIf * iface, gint32* _return, const gchar * taskQueue, const gchar * cmdpath, const gchar * jsonArgs, const gchar * ackChannel, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->run_task (iface, _return, taskQueue, cmdpath, jsonArgs, ackChannel, token, ex1, error);
}

gboolean i_face_log_handler_save_device (IFaceLogIf * iface, DeviceBean ** _return, const DeviceBean * deviceBean, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->save_device (iface, _return, deviceBean, token, ex1, error);
}

gboolean i_face_log_handler_save_device_group (IFaceLogIf * iface, DeviceGroupBean ** _return, const DeviceGroupBean * deviceGroupBean, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->save_device_group (iface, _return, deviceGroupBean, token, ex1, error);
}

gboolean i_face_log_handler_save_permit (IFaceLogIf * iface, PermitBean ** _return, const PermitBean * permitBean, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->save_permit (iface, _return, permitBean, token, ex1, error);
}

gboolean i_face_log_handler_save_permit_with_schedule (IFaceLogIf * iface, PermitBean ** _return, const gint32 deviceGroupId, const gint32 personGroupId, const gchar * schedule, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->save_permit_with_schedule (iface, _return, deviceGroupId, personGroupId, schedule, token, ex1, error);
}

gboolean i_face_log_handler_save_person (IFaceLogIf * iface, PersonBean ** _return, const PersonBean * personBean, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->save_person (iface, _return, personBean, token, ex1, error);
}

gboolean i_face_log_handler_save_person_full (IFaceLogIf * iface, PersonBean ** _return, const PersonBean * personBean, const GByteArray * idPhoto, const GByteArray * feature, const gchar * featureVersion, const GByteArray * featureImage, const FaceBean * featureFaceBean, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->save_person_full (iface, _return, personBean, idPhoto, feature, featureVersion, featureImage, featureFaceBean, token, ex1, error);
}

gboolean i_face_log_handler_save_person_group (IFaceLogIf * iface, PersonGroupBean ** _return, const PersonGroupBean * personGroupBean, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->save_person_group (iface, _return, personGroupBean, token, ex1, error);
}

gboolean i_face_log_handler_save_person_with_photo (IFaceLogIf * iface, PersonBean ** _return, const PersonBean * personBean, const GByteArray * idPhoto, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->save_person_with_photo (iface, _return, personBean, idPhoto, token, ex1, error);
}

gboolean i_face_log_handler_save_person_with_photo_and_feature (IFaceLogIf * iface, PersonBean ** _return, const PersonBean * personBean, const GByteArray * idPhoto, const FeatureBean * featureBean, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->save_person_with_photo_and_feature (iface, _return, personBean, idPhoto, featureBean, token, ex1, error);
}

gboolean i_face_log_handler_save_person_with_photo_and_feature_multi_faces (IFaceLogIf * iface, PersonBean ** _return, const PersonBean * personBean, const GByteArray * idPhoto, const GByteArray * feature, const gchar * featureVersion, const GPtrArray * faceBeans, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->save_person_with_photo_and_feature_multi_faces (iface, _return, personBean, idPhoto, feature, featureVersion, faceBeans, token, ex1, error);
}

gboolean i_face_log_handler_save_person_with_photo_and_feature_multi_image (IFaceLogIf * iface, PersonBean ** _return, const PersonBean * personBean, const GByteArray * idPhoto, const GByteArray * feature, const gchar * featureVersion, const GPtrArray * photos, const GPtrArray * faces, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->save_person_with_photo_and_feature_multi_image (iface, _return, personBean, idPhoto, feature, featureVersion, photos, faces, token, ex1, error);
}

gboolean i_face_log_handler_save_person_with_photo_and_feature_saved (IFaceLogIf * iface, PersonBean ** _return, const PersonBean * personBean, const gchar * idPhotoMd5, const gchar * featureMd5, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->save_person_with_photo_and_feature_saved (iface, _return, personBean, idPhotoMd5, featureMd5, token, ex1, error);
}

gboolean i_face_log_handler_save_persons (IFaceLogIf * iface, const GPtrArray * persons, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->save_persons (iface, persons, token, ex1, error);
}

gboolean i_face_log_handler_save_persons_with_photo (IFaceLogIf * iface, gint32* _return, const GPtrArray * photos, const GPtrArray * persons, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->save_persons_with_photo (iface, _return, photos, persons, token, ex1, error);
}

gboolean i_face_log_handler_save_service_config (IFaceLogIf * iface, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->save_service_config (iface, token, ex1, error);
}

gboolean i_face_log_handler_sdk_task_queue_of (IFaceLogIf * iface, gchar ** _return, const gchar * task, const gchar * sdkVersion, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->sdk_task_queue_of (iface, _return, task, sdkVersion, token, ex1, error);
}

gboolean i_face_log_handler_set_person_expiry_date (IFaceLogIf * iface, const gint32 personId, const gint64 expiryDate, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->set_person_expiry_date (iface, personId, expiryDate, token, ex1, error);
}

gboolean i_face_log_handler_set_person_expiry_date_list (IFaceLogIf * iface, const GArray * personIdList, const gint64 expiryDate, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->set_person_expiry_date_list (iface, personIdList, expiryDate, token, ex1, error);
}

gboolean i_face_log_handler_set_person_expiry_date_time_str (IFaceLogIf * iface, const gint32 personId, const gchar * expiryDate, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->set_person_expiry_date_time_str (iface, personId, expiryDate, token, ex1, error);
}

gboolean i_face_log_handler_set_properties (IFaceLogIf * iface, const GHashTable * config, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->set_properties (iface, config, token, ex1, error);
}

gboolean i_face_log_handler_set_property (IFaceLogIf * iface, const gchar * key, const gchar * value, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->set_property (iface, key, value, token, ex1, error);
}

gboolean i_face_log_handler_task_queue_of (IFaceLogIf * iface, gchar ** _return, const gchar * task, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->task_queue_of (iface, _return, task, token, ex1, error);
}

gboolean i_face_log_handler_unbind_border (IFaceLogIf * iface, const gint32 personGroupId, const gint32 deviceGroupId, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->unbind_border (iface, personGroupId, deviceGroupId, token, ex1, error);
}

gboolean i_face_log_handler_unregister_device (IFaceLogIf * iface, const Token * token, ServiceSecurityException ** ex1, ServiceRuntimeException ** ex2, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->unregister_device (iface, token, ex1, ex2, error);
}

gboolean i_face_log_handler_update_device (IFaceLogIf * iface, DeviceBean ** _return, const DeviceBean * deviceBean, const Token * token, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->update_device (iface, _return, deviceBean, token, ex1, error);
}

gboolean i_face_log_handler_version (IFaceLogIf * iface, gchar ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->version (iface, _return, ex1, error);
}

gboolean i_face_log_handler_version_info (IFaceLogIf * iface, GHashTable ** _return, ServiceRuntimeException ** ex1, GError ** error)
{
  g_return_val_if_fail (IS_I_FACE_LOG_HANDLER (iface), FALSE);

  return I_FACE_LOG_HANDLER_GET_CLASS (iface)->version_info (iface, _return, ex1, error);
}

static void
i_face_log_handler_i_face_log_if_interface_init (IFaceLogIfInterface *iface)
{
  iface->add_feature = i_face_log_handler_add_feature;
  iface->add_feature_multi = i_face_log_handler_add_feature_multi;
  iface->add_feature_with_image = i_face_log_handler_add_feature_with_image;
  iface->add_image = i_face_log_handler_add_image;
  iface->add_log = i_face_log_handler_add_log;
  iface->add_log_full = i_face_log_handler_add_log_full;
  iface->add_logs = i_face_log_handler_add_logs;
  iface->add_logs_full = i_face_log_handler_add_logs_full;
  iface->apply_ack_channel = i_face_log_handler_apply_ack_channel;
  iface->apply_ack_channel_with_duration = i_face_log_handler_apply_ack_channel_with_duration;
  iface->apply_cmd_sn = i_face_log_handler_apply_cmd_sn;
  iface->apply_person_token = i_face_log_handler_apply_person_token;
  iface->apply_root_token = i_face_log_handler_apply_root_token;
  iface->apply_user_token = i_face_log_handler_apply_user_token;
  iface->bind_border = i_face_log_handler_bind_border;
  iface->child_list_for_device_group = i_face_log_handler_child_list_for_device_group;
  iface->child_list_for_person_group = i_face_log_handler_child_list_for_person_group;
  iface->count_device_by_where = i_face_log_handler_count_device_by_where;
  iface->count_device_group_by_where = i_face_log_handler_count_device_group_by_where;
  iface->count_log_by_where = i_face_log_handler_count_log_by_where;
  iface->count_log_light_by_verify_time = i_face_log_handler_count_log_light_by_verify_time;
  iface->count_log_light_by_verify_time_timestr = i_face_log_handler_count_log_light_by_verify_time_timestr;
  iface->count_log_light_by_where = i_face_log_handler_count_log_light_by_where;
  iface->count_person_by_where = i_face_log_handler_count_person_by_where;
  iface->count_person_group_by_where = i_face_log_handler_count_person_group_by_where;
  iface->delete_all_features_by_person_id = i_face_log_handler_delete_all_features_by_person_id;
  iface->delete_device_group = i_face_log_handler_delete_device_group;
  iface->delete_feature = i_face_log_handler_delete_feature;
  iface->delete_group_permit_on_device_group = i_face_log_handler_delete_group_permit_on_device_group;
  iface->delete_image = i_face_log_handler_delete_image;
  iface->delete_permit_by_id = i_face_log_handler_delete_permit_by_id;
  iface->delete_person = i_face_log_handler_delete_person;
  iface->delete_person_by_papers_num = i_face_log_handler_delete_person_by_papers_num;
  iface->delete_person_group = i_face_log_handler_delete_person_group;
  iface->delete_person_group_permit = i_face_log_handler_delete_person_group_permit;
  iface->delete_persons = i_face_log_handler_delete_persons;
  iface->delete_persons_by_papers_num = i_face_log_handler_delete_persons_by_papers_num;
  iface->disable_person = i_face_log_handler_disable_person;
  iface->disable_person_list = i_face_log_handler_disable_person_list;
  iface->exists_device = i_face_log_handler_exists_device;
  iface->exists_feature = i_face_log_handler_exists_feature;
  iface->exists_image = i_face_log_handler_exists_image;
  iface->exists_person = i_face_log_handler_exists_person;
  iface->get_device = i_face_log_handler_get_device;
  iface->get_device_by_mac = i_face_log_handler_get_device_by_mac;
  iface->get_device_group = i_face_log_handler_get_device_group;
  iface->get_device_groups = i_face_log_handler_get_device_groups;
  iface->get_device_groups_belongs = i_face_log_handler_get_device_groups_belongs;
  iface->get_device_groups_permit = i_face_log_handler_get_device_groups_permit;
  iface->get_device_groups_permitted_by = i_face_log_handler_get_device_groups_permitted_by;
  iface->get_device_id_of_feature = i_face_log_handler_get_device_id_of_feature;
  iface->get_devices = i_face_log_handler_get_devices;
  iface->get_devices_of_group = i_face_log_handler_get_devices_of_group;
  iface->get_face = i_face_log_handler_get_face;
  iface->get_feature = i_face_log_handler_get_feature;
  iface->get_feature_bytes = i_face_log_handler_get_feature_bytes;
  iface->get_features = i_face_log_handler_get_features;
  iface->get_features_by_person_id_and_sdk_version = i_face_log_handler_get_features_by_person_id_and_sdk_version;
  iface->get_features_of_person = i_face_log_handler_get_features_of_person;
  iface->get_features_permitted_on_device = i_face_log_handler_get_features_permitted_on_device;
  iface->get_group_permit = i_face_log_handler_get_group_permit;
  iface->get_group_permit_on_device_group = i_face_log_handler_get_group_permit_on_device_group;
  iface->get_group_permits = i_face_log_handler_get_group_permits;
  iface->get_image = i_face_log_handler_get_image;
  iface->get_image_bytes = i_face_log_handler_get_image_bytes;
  iface->get_images_associated_by_feature = i_face_log_handler_get_images_associated_by_feature;
  iface->get_log_beans_by_person_id = i_face_log_handler_get_log_beans_by_person_id;
  iface->get_person = i_face_log_handler_get_person;
  iface->get_person_by_mobile_phone = i_face_log_handler_get_person_by_mobile_phone;
  iface->get_person_by_papers_num = i_face_log_handler_get_person_by_papers_num;
  iface->get_person_group = i_face_log_handler_get_person_group;
  iface->get_person_groups = i_face_log_handler_get_person_groups;
  iface->get_person_groups_belongs = i_face_log_handler_get_person_groups_belongs;
  iface->get_person_groups_permitted_by = i_face_log_handler_get_person_groups_permitted_by;
  iface->get_person_permit = i_face_log_handler_get_person_permit;
  iface->get_person_permits = i_face_log_handler_get_person_permits;
  iface->get_persons = i_face_log_handler_get_persons;
  iface->get_persons_of_group = i_face_log_handler_get_persons_of_group;
  iface->get_persons_permitted_on_device = i_face_log_handler_get_persons_permitted_on_device;
  iface->get_properties = i_face_log_handler_get_properties;
  iface->get_property = i_face_log_handler_get_property;
  iface->get_redis_parameters = i_face_log_handler_get_redis_parameters;
  iface->get_service_config = i_face_log_handler_get_service_config;
  iface->get_sub_device_group = i_face_log_handler_get_sub_device_group;
  iface->get_sub_person_group = i_face_log_handler_get_sub_person_group;
  iface->is_disable = i_face_log_handler_is_disable;
  iface->is_local = i_face_log_handler_is_local;
  iface->is_valid_ack_channel = i_face_log_handler_is_valid_ack_channel;
  iface->is_valid_cmd_sn = i_face_log_handler_is_valid_cmd_sn;
  iface->is_valid_device_token = i_face_log_handler_is_valid_device_token;
  iface->is_valid_password = i_face_log_handler_is_valid_password;
  iface->is_valid_person_token = i_face_log_handler_is_valid_person_token;
  iface->is_valid_root_token = i_face_log_handler_is_valid_root_token;
  iface->is_valid_token = i_face_log_handler_is_valid_token;
  iface->is_valid_user_token = i_face_log_handler_is_valid_user_token;
  iface->list_of_parent_for_device_group = i_face_log_handler_list_of_parent_for_device_group;
  iface->list_of_parent_for_person_group = i_face_log_handler_list_of_parent_for_person_group;
  iface->load_all_person = i_face_log_handler_load_all_person;
  iface->load_device_by_where = i_face_log_handler_load_device_by_where;
  iface->load_device_group_by_where = i_face_log_handler_load_device_group_by_where;
  iface->load_device_group_id_by_where = i_face_log_handler_load_device_group_id_by_where;
  iface->load_device_id_by_where = i_face_log_handler_load_device_id_by_where;
  iface->load_distinct_integer_column = i_face_log_handler_load_distinct_integer_column;
  iface->load_distinct_string_column = i_face_log_handler_load_distinct_string_column;
  iface->load_feature_md5_by_update = i_face_log_handler_load_feature_md5_by_update;
  iface->load_feature_md5_by_update_time_str = i_face_log_handler_load_feature_md5_by_update_time_str;
  iface->load_log_by_where = i_face_log_handler_load_log_by_where;
  iface->load_log_light_by_verify_time = i_face_log_handler_load_log_light_by_verify_time;
  iface->load_log_light_by_verify_time_timestr = i_face_log_handler_load_log_light_by_verify_time_timestr;
  iface->load_log_light_by_where = i_face_log_handler_load_log_light_by_where;
  iface->load_permit_by_update = i_face_log_handler_load_permit_by_update;
  iface->load_permit_by_update_timestr = i_face_log_handler_load_permit_by_update_timestr;
  iface->load_person_by_where = i_face_log_handler_load_person_by_where;
  iface->load_person_group_by_where = i_face_log_handler_load_person_group_by_where;
  iface->load_person_group_id_by_where = i_face_log_handler_load_person_group_id_by_where;
  iface->load_person_id_by_update_time = i_face_log_handler_load_person_id_by_update_time;
  iface->load_person_id_by_update_time_time_str = i_face_log_handler_load_person_id_by_update_time_time_str;
  iface->load_person_id_by_where = i_face_log_handler_load_person_id_by_where;
  iface->load_updated_persons = i_face_log_handler_load_updated_persons;
  iface->load_updated_persons_timestr = i_face_log_handler_load_updated_persons_timestr;
  iface->offline = i_face_log_handler_offline;
  iface->online = i_face_log_handler_online;
  iface->register_device = i_face_log_handler_register_device;
  iface->release_person_token = i_face_log_handler_release_person_token;
  iface->release_root_token = i_face_log_handler_release_root_token;
  iface->release_user_token = i_face_log_handler_release_user_token;
  iface->replace_feature = i_face_log_handler_replace_feature;
  iface->root_group_of_device = i_face_log_handler_root_group_of_device;
  iface->root_group_of_person = i_face_log_handler_root_group_of_person;
  iface->run_cmd = i_face_log_handler_run_cmd;
  iface->run_task = i_face_log_handler_run_task;
  iface->save_device = i_face_log_handler_save_device;
  iface->save_device_group = i_face_log_handler_save_device_group;
  iface->save_permit = i_face_log_handler_save_permit;
  iface->save_permit_with_schedule = i_face_log_handler_save_permit_with_schedule;
  iface->save_person = i_face_log_handler_save_person;
  iface->save_person_full = i_face_log_handler_save_person_full;
  iface->save_person_group = i_face_log_handler_save_person_group;
  iface->save_person_with_photo = i_face_log_handler_save_person_with_photo;
  iface->save_person_with_photo_and_feature = i_face_log_handler_save_person_with_photo_and_feature;
  iface->save_person_with_photo_and_feature_multi_faces = i_face_log_handler_save_person_with_photo_and_feature_multi_faces;
  iface->save_person_with_photo_and_feature_multi_image = i_face_log_handler_save_person_with_photo_and_feature_multi_image;
  iface->save_person_with_photo_and_feature_saved = i_face_log_handler_save_person_with_photo_and_feature_saved;
  iface->save_persons = i_face_log_handler_save_persons;
  iface->save_persons_with_photo = i_face_log_handler_save_persons_with_photo;
  iface->save_service_config = i_face_log_handler_save_service_config;
  iface->sdk_task_queue_of = i_face_log_handler_sdk_task_queue_of;
  iface->set_person_expiry_date = i_face_log_handler_set_person_expiry_date;
  iface->set_person_expiry_date_list = i_face_log_handler_set_person_expiry_date_list;
  iface->set_person_expiry_date_time_str = i_face_log_handler_set_person_expiry_date_time_str;
  iface->set_properties = i_face_log_handler_set_properties;
  iface->set_property = i_face_log_handler_set_property;
  iface->task_queue_of = i_face_log_handler_task_queue_of;
  iface->unbind_border = i_face_log_handler_unbind_border;
  iface->unregister_device = i_face_log_handler_unregister_device;
  iface->update_device = i_face_log_handler_update_device;
  iface->version = i_face_log_handler_version;
  iface->version_info = i_face_log_handler_version_info;
}

static void
i_face_log_handler_init (IFaceLogHandler *self)
{
  THRIFT_UNUSED_VAR (self);
}

static void
i_face_log_handler_class_init (IFaceLogHandlerClass *cls)
{
  cls->add_feature = NULL;
  cls->add_feature_multi = NULL;
  cls->add_feature_with_image = NULL;
  cls->add_image = NULL;
  cls->add_log = NULL;
  cls->add_log_full = NULL;
  cls->add_logs = NULL;
  cls->add_logs_full = NULL;
  cls->apply_ack_channel = NULL;
  cls->apply_ack_channel_with_duration = NULL;
  cls->apply_cmd_sn = NULL;
  cls->apply_person_token = NULL;
  cls->apply_root_token = NULL;
  cls->apply_user_token = NULL;
  cls->bind_border = NULL;
  cls->child_list_for_device_group = NULL;
  cls->child_list_for_person_group = NULL;
  cls->count_device_by_where = NULL;
  cls->count_device_group_by_where = NULL;
  cls->count_log_by_where = NULL;
  cls->count_log_light_by_verify_time = NULL;
  cls->count_log_light_by_verify_time_timestr = NULL;
  cls->count_log_light_by_where = NULL;
  cls->count_person_by_where = NULL;
  cls->count_person_group_by_where = NULL;
  cls->delete_all_features_by_person_id = NULL;
  cls->delete_device_group = NULL;
  cls->delete_feature = NULL;
  cls->delete_group_permit_on_device_group = NULL;
  cls->delete_image = NULL;
  cls->delete_permit_by_id = NULL;
  cls->delete_person = NULL;
  cls->delete_person_by_papers_num = NULL;
  cls->delete_person_group = NULL;
  cls->delete_person_group_permit = NULL;
  cls->delete_persons = NULL;
  cls->delete_persons_by_papers_num = NULL;
  cls->disable_person = NULL;
  cls->disable_person_list = NULL;
  cls->exists_device = NULL;
  cls->exists_feature = NULL;
  cls->exists_image = NULL;
  cls->exists_person = NULL;
  cls->get_device = NULL;
  cls->get_device_by_mac = NULL;
  cls->get_device_group = NULL;
  cls->get_device_groups = NULL;
  cls->get_device_groups_belongs = NULL;
  cls->get_device_groups_permit = NULL;
  cls->get_device_groups_permitted_by = NULL;
  cls->get_device_id_of_feature = NULL;
  cls->get_devices = NULL;
  cls->get_devices_of_group = NULL;
  cls->get_face = NULL;
  cls->get_feature = NULL;
  cls->get_feature_bytes = NULL;
  cls->get_features = NULL;
  cls->get_features_by_person_id_and_sdk_version = NULL;
  cls->get_features_of_person = NULL;
  cls->get_features_permitted_on_device = NULL;
  cls->get_group_permit = NULL;
  cls->get_group_permit_on_device_group = NULL;
  cls->get_group_permits = NULL;
  cls->get_image = NULL;
  cls->get_image_bytes = NULL;
  cls->get_images_associated_by_feature = NULL;
  cls->get_log_beans_by_person_id = NULL;
  cls->get_person = NULL;
  cls->get_person_by_mobile_phone = NULL;
  cls->get_person_by_papers_num = NULL;
  cls->get_person_group = NULL;
  cls->get_person_groups = NULL;
  cls->get_person_groups_belongs = NULL;
  cls->get_person_groups_permitted_by = NULL;
  cls->get_person_permit = NULL;
  cls->get_person_permits = NULL;
  cls->get_persons = NULL;
  cls->get_persons_of_group = NULL;
  cls->get_persons_permitted_on_device = NULL;
  cls->get_properties = NULL;
  cls->get_property = NULL;
  cls->get_redis_parameters = NULL;
  cls->get_service_config = NULL;
  cls->get_sub_device_group = NULL;
  cls->get_sub_person_group = NULL;
  cls->is_disable = NULL;
  cls->is_local = NULL;
  cls->is_valid_ack_channel = NULL;
  cls->is_valid_cmd_sn = NULL;
  cls->is_valid_device_token = NULL;
  cls->is_valid_password = NULL;
  cls->is_valid_person_token = NULL;
  cls->is_valid_root_token = NULL;
  cls->is_valid_token = NULL;
  cls->is_valid_user_token = NULL;
  cls->list_of_parent_for_device_group = NULL;
  cls->list_of_parent_for_person_group = NULL;
  cls->load_all_person = NULL;
  cls->load_device_by_where = NULL;
  cls->load_device_group_by_where = NULL;
  cls->load_device_group_id_by_where = NULL;
  cls->load_device_id_by_where = NULL;
  cls->load_distinct_integer_column = NULL;
  cls->load_distinct_string_column = NULL;
  cls->load_feature_md5_by_update = NULL;
  cls->load_feature_md5_by_update_time_str = NULL;
  cls->load_log_by_where = NULL;
  cls->load_log_light_by_verify_time = NULL;
  cls->load_log_light_by_verify_time_timestr = NULL;
  cls->load_log_light_by_where = NULL;
  cls->load_permit_by_update = NULL;
  cls->load_permit_by_update_timestr = NULL;
  cls->load_person_by_where = NULL;
  cls->load_person_group_by_where = NULL;
  cls->load_person_group_id_by_where = NULL;
  cls->load_person_id_by_update_time = NULL;
  cls->load_person_id_by_update_time_time_str = NULL;
  cls->load_person_id_by_where = NULL;
  cls->load_updated_persons = NULL;
  cls->load_updated_persons_timestr = NULL;
  cls->offline = NULL;
  cls->online = NULL;
  cls->register_device = NULL;
  cls->release_person_token = NULL;
  cls->release_root_token = NULL;
  cls->release_user_token = NULL;
  cls->replace_feature = NULL;
  cls->root_group_of_device = NULL;
  cls->root_group_of_person = NULL;
  cls->run_cmd = NULL;
  cls->run_task = NULL;
  cls->save_device = NULL;
  cls->save_device_group = NULL;
  cls->save_permit = NULL;
  cls->save_permit_with_schedule = NULL;
  cls->save_person = NULL;
  cls->save_person_full = NULL;
  cls->save_person_group = NULL;
  cls->save_person_with_photo = NULL;
  cls->save_person_with_photo_and_feature = NULL;
  cls->save_person_with_photo_and_feature_multi_faces = NULL;
  cls->save_person_with_photo_and_feature_multi_image = NULL;
  cls->save_person_with_photo_and_feature_saved = NULL;
  cls->save_persons = NULL;
  cls->save_persons_with_photo = NULL;
  cls->save_service_config = NULL;
  cls->sdk_task_queue_of = NULL;
  cls->set_person_expiry_date = NULL;
  cls->set_person_expiry_date_list = NULL;
  cls->set_person_expiry_date_time_str = NULL;
  cls->set_properties = NULL;
  cls->set_property = NULL;
  cls->task_queue_of = NULL;
  cls->unbind_border = NULL;
  cls->unregister_device = NULL;
  cls->update_device = NULL;
  cls->version = NULL;
  cls->version_info = NULL;
}

enum _IFaceLogProcessorProperties
{
  PROP_I_FACE_LOG_PROCESSOR_0,
  PROP_I_FACE_LOG_PROCESSOR_HANDLER
};

G_DEFINE_TYPE (IFaceLogProcessor,
               i_face_log_processor,
               THRIFT_TYPE_DISPATCH_PROCESSOR)

typedef gboolean (* IFaceLogProcessorProcessFunction) (IFaceLogProcessor *, 
                                                       gint32,
                                                       ThriftProtocol *,
                                                       ThriftProtocol *,
                                                       GError **);

typedef struct
{
  gchar *name;
  IFaceLogProcessorProcessFunction function;
} i_face_log_processor_process_function_def;

static gboolean
i_face_log_processor_process_add_feature (IFaceLogProcessor *,
                                          gint32,
                                          ThriftProtocol *,
                                          ThriftProtocol *,
                                          GError **);
static gboolean
i_face_log_processor_process_add_feature_multi (IFaceLogProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
i_face_log_processor_process_add_feature_with_image (IFaceLogProcessor *,
                                                     gint32,
                                                     ThriftProtocol *,
                                                     ThriftProtocol *,
                                                     GError **);
static gboolean
i_face_log_processor_process_add_image (IFaceLogProcessor *,
                                        gint32,
                                        ThriftProtocol *,
                                        ThriftProtocol *,
                                        GError **);
static gboolean
i_face_log_processor_process_add_log (IFaceLogProcessor *,
                                      gint32,
                                      ThriftProtocol *,
                                      ThriftProtocol *,
                                      GError **);
static gboolean
i_face_log_processor_process_add_log_full (IFaceLogProcessor *,
                                           gint32,
                                           ThriftProtocol *,
                                           ThriftProtocol *,
                                           GError **);
static gboolean
i_face_log_processor_process_add_logs (IFaceLogProcessor *,
                                       gint32,
                                       ThriftProtocol *,
                                       ThriftProtocol *,
                                       GError **);
static gboolean
i_face_log_processor_process_add_logs_full (IFaceLogProcessor *,
                                            gint32,
                                            ThriftProtocol *,
                                            ThriftProtocol *,
                                            GError **);
static gboolean
i_face_log_processor_process_apply_ack_channel (IFaceLogProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
i_face_log_processor_process_apply_ack_channel_with_duration (IFaceLogProcessor *,
                                                              gint32,
                                                              ThriftProtocol *,
                                                              ThriftProtocol *,
                                                              GError **);
static gboolean
i_face_log_processor_process_apply_cmd_sn (IFaceLogProcessor *,
                                           gint32,
                                           ThriftProtocol *,
                                           ThriftProtocol *,
                                           GError **);
static gboolean
i_face_log_processor_process_apply_person_token (IFaceLogProcessor *,
                                                 gint32,
                                                 ThriftProtocol *,
                                                 ThriftProtocol *,
                                                 GError **);
static gboolean
i_face_log_processor_process_apply_root_token (IFaceLogProcessor *,
                                               gint32,
                                               ThriftProtocol *,
                                               ThriftProtocol *,
                                               GError **);
static gboolean
i_face_log_processor_process_apply_user_token (IFaceLogProcessor *,
                                               gint32,
                                               ThriftProtocol *,
                                               ThriftProtocol *,
                                               GError **);
static gboolean
i_face_log_processor_process_bind_border (IFaceLogProcessor *,
                                          gint32,
                                          ThriftProtocol *,
                                          ThriftProtocol *,
                                          GError **);
static gboolean
i_face_log_processor_process_child_list_for_device_group (IFaceLogProcessor *,
                                                          gint32,
                                                          ThriftProtocol *,
                                                          ThriftProtocol *,
                                                          GError **);
static gboolean
i_face_log_processor_process_child_list_for_person_group (IFaceLogProcessor *,
                                                          gint32,
                                                          ThriftProtocol *,
                                                          ThriftProtocol *,
                                                          GError **);
static gboolean
i_face_log_processor_process_count_device_by_where (IFaceLogProcessor *,
                                                    gint32,
                                                    ThriftProtocol *,
                                                    ThriftProtocol *,
                                                    GError **);
static gboolean
i_face_log_processor_process_count_device_group_by_where (IFaceLogProcessor *,
                                                          gint32,
                                                          ThriftProtocol *,
                                                          ThriftProtocol *,
                                                          GError **);
static gboolean
i_face_log_processor_process_count_log_by_where (IFaceLogProcessor *,
                                                 gint32,
                                                 ThriftProtocol *,
                                                 ThriftProtocol *,
                                                 GError **);
static gboolean
i_face_log_processor_process_count_log_light_by_verify_time (IFaceLogProcessor *,
                                                             gint32,
                                                             ThriftProtocol *,
                                                             ThriftProtocol *,
                                                             GError **);
static gboolean
i_face_log_processor_process_count_log_light_by_verify_time_timestr (IFaceLogProcessor *,
                                                                     gint32,
                                                                     ThriftProtocol *,
                                                                     ThriftProtocol *,
                                                                     GError **);
static gboolean
i_face_log_processor_process_count_log_light_by_where (IFaceLogProcessor *,
                                                       gint32,
                                                       ThriftProtocol *,
                                                       ThriftProtocol *,
                                                       GError **);
static gboolean
i_face_log_processor_process_count_person_by_where (IFaceLogProcessor *,
                                                    gint32,
                                                    ThriftProtocol *,
                                                    ThriftProtocol *,
                                                    GError **);
static gboolean
i_face_log_processor_process_count_person_group_by_where (IFaceLogProcessor *,
                                                          gint32,
                                                          ThriftProtocol *,
                                                          ThriftProtocol *,
                                                          GError **);
static gboolean
i_face_log_processor_process_delete_all_features_by_person_id (IFaceLogProcessor *,
                                                               gint32,
                                                               ThriftProtocol *,
                                                               ThriftProtocol *,
                                                               GError **);
static gboolean
i_face_log_processor_process_delete_device_group (IFaceLogProcessor *,
                                                  gint32,
                                                  ThriftProtocol *,
                                                  ThriftProtocol *,
                                                  GError **);
static gboolean
i_face_log_processor_process_delete_feature (IFaceLogProcessor *,
                                             gint32,
                                             ThriftProtocol *,
                                             ThriftProtocol *,
                                             GError **);
static gboolean
i_face_log_processor_process_delete_group_permit_on_device_group (IFaceLogProcessor *,
                                                                  gint32,
                                                                  ThriftProtocol *,
                                                                  ThriftProtocol *,
                                                                  GError **);
static gboolean
i_face_log_processor_process_delete_image (IFaceLogProcessor *,
                                           gint32,
                                           ThriftProtocol *,
                                           ThriftProtocol *,
                                           GError **);
static gboolean
i_face_log_processor_process_delete_permit_by_id (IFaceLogProcessor *,
                                                  gint32,
                                                  ThriftProtocol *,
                                                  ThriftProtocol *,
                                                  GError **);
static gboolean
i_face_log_processor_process_delete_person (IFaceLogProcessor *,
                                            gint32,
                                            ThriftProtocol *,
                                            ThriftProtocol *,
                                            GError **);
static gboolean
i_face_log_processor_process_delete_person_by_papers_num (IFaceLogProcessor *,
                                                          gint32,
                                                          ThriftProtocol *,
                                                          ThriftProtocol *,
                                                          GError **);
static gboolean
i_face_log_processor_process_delete_person_group (IFaceLogProcessor *,
                                                  gint32,
                                                  ThriftProtocol *,
                                                  ThriftProtocol *,
                                                  GError **);
static gboolean
i_face_log_processor_process_delete_person_group_permit (IFaceLogProcessor *,
                                                         gint32,
                                                         ThriftProtocol *,
                                                         ThriftProtocol *,
                                                         GError **);
static gboolean
i_face_log_processor_process_delete_persons (IFaceLogProcessor *,
                                             gint32,
                                             ThriftProtocol *,
                                             ThriftProtocol *,
                                             GError **);
static gboolean
i_face_log_processor_process_delete_persons_by_papers_num (IFaceLogProcessor *,
                                                           gint32,
                                                           ThriftProtocol *,
                                                           ThriftProtocol *,
                                                           GError **);
static gboolean
i_face_log_processor_process_disable_person (IFaceLogProcessor *,
                                             gint32,
                                             ThriftProtocol *,
                                             ThriftProtocol *,
                                             GError **);
static gboolean
i_face_log_processor_process_disable_person_list (IFaceLogProcessor *,
                                                  gint32,
                                                  ThriftProtocol *,
                                                  ThriftProtocol *,
                                                  GError **);
static gboolean
i_face_log_processor_process_exists_device (IFaceLogProcessor *,
                                            gint32,
                                            ThriftProtocol *,
                                            ThriftProtocol *,
                                            GError **);
static gboolean
i_face_log_processor_process_exists_feature (IFaceLogProcessor *,
                                             gint32,
                                             ThriftProtocol *,
                                             ThriftProtocol *,
                                             GError **);
static gboolean
i_face_log_processor_process_exists_image (IFaceLogProcessor *,
                                           gint32,
                                           ThriftProtocol *,
                                           ThriftProtocol *,
                                           GError **);
static gboolean
i_face_log_processor_process_exists_person (IFaceLogProcessor *,
                                            gint32,
                                            ThriftProtocol *,
                                            ThriftProtocol *,
                                            GError **);
static gboolean
i_face_log_processor_process_get_device (IFaceLogProcessor *,
                                         gint32,
                                         ThriftProtocol *,
                                         ThriftProtocol *,
                                         GError **);
static gboolean
i_face_log_processor_process_get_device_by_mac (IFaceLogProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
i_face_log_processor_process_get_device_group (IFaceLogProcessor *,
                                               gint32,
                                               ThriftProtocol *,
                                               ThriftProtocol *,
                                               GError **);
static gboolean
i_face_log_processor_process_get_device_groups (IFaceLogProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
i_face_log_processor_process_get_device_groups_belongs (IFaceLogProcessor *,
                                                        gint32,
                                                        ThriftProtocol *,
                                                        ThriftProtocol *,
                                                        GError **);
static gboolean
i_face_log_processor_process_get_device_groups_permit (IFaceLogProcessor *,
                                                       gint32,
                                                       ThriftProtocol *,
                                                       ThriftProtocol *,
                                                       GError **);
static gboolean
i_face_log_processor_process_get_device_groups_permitted_by (IFaceLogProcessor *,
                                                             gint32,
                                                             ThriftProtocol *,
                                                             ThriftProtocol *,
                                                             GError **);
static gboolean
i_face_log_processor_process_get_device_id_of_feature (IFaceLogProcessor *,
                                                       gint32,
                                                       ThriftProtocol *,
                                                       ThriftProtocol *,
                                                       GError **);
static gboolean
i_face_log_processor_process_get_devices (IFaceLogProcessor *,
                                          gint32,
                                          ThriftProtocol *,
                                          ThriftProtocol *,
                                          GError **);
static gboolean
i_face_log_processor_process_get_devices_of_group (IFaceLogProcessor *,
                                                   gint32,
                                                   ThriftProtocol *,
                                                   ThriftProtocol *,
                                                   GError **);
static gboolean
i_face_log_processor_process_get_face (IFaceLogProcessor *,
                                       gint32,
                                       ThriftProtocol *,
                                       ThriftProtocol *,
                                       GError **);
static gboolean
i_face_log_processor_process_get_feature (IFaceLogProcessor *,
                                          gint32,
                                          ThriftProtocol *,
                                          ThriftProtocol *,
                                          GError **);
static gboolean
i_face_log_processor_process_get_feature_bytes (IFaceLogProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
i_face_log_processor_process_get_features (IFaceLogProcessor *,
                                           gint32,
                                           ThriftProtocol *,
                                           ThriftProtocol *,
                                           GError **);
static gboolean
i_face_log_processor_process_get_features_by_person_id_and_sdk_version (IFaceLogProcessor *,
                                                                        gint32,
                                                                        ThriftProtocol *,
                                                                        ThriftProtocol *,
                                                                        GError **);
static gboolean
i_face_log_processor_process_get_features_of_person (IFaceLogProcessor *,
                                                     gint32,
                                                     ThriftProtocol *,
                                                     ThriftProtocol *,
                                                     GError **);
static gboolean
i_face_log_processor_process_get_features_permitted_on_device (IFaceLogProcessor *,
                                                               gint32,
                                                               ThriftProtocol *,
                                                               ThriftProtocol *,
                                                               GError **);
static gboolean
i_face_log_processor_process_get_group_permit (IFaceLogProcessor *,
                                               gint32,
                                               ThriftProtocol *,
                                               ThriftProtocol *,
                                               GError **);
static gboolean
i_face_log_processor_process_get_group_permit_on_device_group (IFaceLogProcessor *,
                                                               gint32,
                                                               ThriftProtocol *,
                                                               ThriftProtocol *,
                                                               GError **);
static gboolean
i_face_log_processor_process_get_group_permits (IFaceLogProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
i_face_log_processor_process_get_image (IFaceLogProcessor *,
                                        gint32,
                                        ThriftProtocol *,
                                        ThriftProtocol *,
                                        GError **);
static gboolean
i_face_log_processor_process_get_image_bytes (IFaceLogProcessor *,
                                              gint32,
                                              ThriftProtocol *,
                                              ThriftProtocol *,
                                              GError **);
static gboolean
i_face_log_processor_process_get_images_associated_by_feature (IFaceLogProcessor *,
                                                               gint32,
                                                               ThriftProtocol *,
                                                               ThriftProtocol *,
                                                               GError **);
static gboolean
i_face_log_processor_process_get_log_beans_by_person_id (IFaceLogProcessor *,
                                                         gint32,
                                                         ThriftProtocol *,
                                                         ThriftProtocol *,
                                                         GError **);
static gboolean
i_face_log_processor_process_get_person (IFaceLogProcessor *,
                                         gint32,
                                         ThriftProtocol *,
                                         ThriftProtocol *,
                                         GError **);
static gboolean
i_face_log_processor_process_get_person_by_mobile_phone (IFaceLogProcessor *,
                                                         gint32,
                                                         ThriftProtocol *,
                                                         ThriftProtocol *,
                                                         GError **);
static gboolean
i_face_log_processor_process_get_person_by_papers_num (IFaceLogProcessor *,
                                                       gint32,
                                                       ThriftProtocol *,
                                                       ThriftProtocol *,
                                                       GError **);
static gboolean
i_face_log_processor_process_get_person_group (IFaceLogProcessor *,
                                               gint32,
                                               ThriftProtocol *,
                                               ThriftProtocol *,
                                               GError **);
static gboolean
i_face_log_processor_process_get_person_groups (IFaceLogProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
i_face_log_processor_process_get_person_groups_belongs (IFaceLogProcessor *,
                                                        gint32,
                                                        ThriftProtocol *,
                                                        ThriftProtocol *,
                                                        GError **);
static gboolean
i_face_log_processor_process_get_person_groups_permitted_by (IFaceLogProcessor *,
                                                             gint32,
                                                             ThriftProtocol *,
                                                             ThriftProtocol *,
                                                             GError **);
static gboolean
i_face_log_processor_process_get_person_permit (IFaceLogProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
i_face_log_processor_process_get_person_permits (IFaceLogProcessor *,
                                                 gint32,
                                                 ThriftProtocol *,
                                                 ThriftProtocol *,
                                                 GError **);
static gboolean
i_face_log_processor_process_get_persons (IFaceLogProcessor *,
                                          gint32,
                                          ThriftProtocol *,
                                          ThriftProtocol *,
                                          GError **);
static gboolean
i_face_log_processor_process_get_persons_of_group (IFaceLogProcessor *,
                                                   gint32,
                                                   ThriftProtocol *,
                                                   ThriftProtocol *,
                                                   GError **);
static gboolean
i_face_log_processor_process_get_persons_permitted_on_device (IFaceLogProcessor *,
                                                              gint32,
                                                              ThriftProtocol *,
                                                              ThriftProtocol *,
                                                              GError **);
static gboolean
i_face_log_processor_process_get_properties (IFaceLogProcessor *,
                                             gint32,
                                             ThriftProtocol *,
                                             ThriftProtocol *,
                                             GError **);
static gboolean
i_face_log_processor_process_get_property (IFaceLogProcessor *,
                                           gint32,
                                           ThriftProtocol *,
                                           ThriftProtocol *,
                                           GError **);
static gboolean
i_face_log_processor_process_get_redis_parameters (IFaceLogProcessor *,
                                                   gint32,
                                                   ThriftProtocol *,
                                                   ThriftProtocol *,
                                                   GError **);
static gboolean
i_face_log_processor_process_get_service_config (IFaceLogProcessor *,
                                                 gint32,
                                                 ThriftProtocol *,
                                                 ThriftProtocol *,
                                                 GError **);
static gboolean
i_face_log_processor_process_get_sub_device_group (IFaceLogProcessor *,
                                                   gint32,
                                                   ThriftProtocol *,
                                                   ThriftProtocol *,
                                                   GError **);
static gboolean
i_face_log_processor_process_get_sub_person_group (IFaceLogProcessor *,
                                                   gint32,
                                                   ThriftProtocol *,
                                                   ThriftProtocol *,
                                                   GError **);
static gboolean
i_face_log_processor_process_is_disable (IFaceLogProcessor *,
                                         gint32,
                                         ThriftProtocol *,
                                         ThriftProtocol *,
                                         GError **);
static gboolean
i_face_log_processor_process_is_local (IFaceLogProcessor *,
                                       gint32,
                                       ThriftProtocol *,
                                       ThriftProtocol *,
                                       GError **);
static gboolean
i_face_log_processor_process_is_valid_ack_channel (IFaceLogProcessor *,
                                                   gint32,
                                                   ThriftProtocol *,
                                                   ThriftProtocol *,
                                                   GError **);
static gboolean
i_face_log_processor_process_is_valid_cmd_sn (IFaceLogProcessor *,
                                              gint32,
                                              ThriftProtocol *,
                                              ThriftProtocol *,
                                              GError **);
static gboolean
i_face_log_processor_process_is_valid_device_token (IFaceLogProcessor *,
                                                    gint32,
                                                    ThriftProtocol *,
                                                    ThriftProtocol *,
                                                    GError **);
static gboolean
i_face_log_processor_process_is_valid_password (IFaceLogProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
i_face_log_processor_process_is_valid_person_token (IFaceLogProcessor *,
                                                    gint32,
                                                    ThriftProtocol *,
                                                    ThriftProtocol *,
                                                    GError **);
static gboolean
i_face_log_processor_process_is_valid_root_token (IFaceLogProcessor *,
                                                  gint32,
                                                  ThriftProtocol *,
                                                  ThriftProtocol *,
                                                  GError **);
static gboolean
i_face_log_processor_process_is_valid_token (IFaceLogProcessor *,
                                             gint32,
                                             ThriftProtocol *,
                                             ThriftProtocol *,
                                             GError **);
static gboolean
i_face_log_processor_process_is_valid_user_token (IFaceLogProcessor *,
                                                  gint32,
                                                  ThriftProtocol *,
                                                  ThriftProtocol *,
                                                  GError **);
static gboolean
i_face_log_processor_process_list_of_parent_for_device_group (IFaceLogProcessor *,
                                                              gint32,
                                                              ThriftProtocol *,
                                                              ThriftProtocol *,
                                                              GError **);
static gboolean
i_face_log_processor_process_list_of_parent_for_person_group (IFaceLogProcessor *,
                                                              gint32,
                                                              ThriftProtocol *,
                                                              ThriftProtocol *,
                                                              GError **);
static gboolean
i_face_log_processor_process_load_all_person (IFaceLogProcessor *,
                                              gint32,
                                              ThriftProtocol *,
                                              ThriftProtocol *,
                                              GError **);
static gboolean
i_face_log_processor_process_load_device_by_where (IFaceLogProcessor *,
                                                   gint32,
                                                   ThriftProtocol *,
                                                   ThriftProtocol *,
                                                   GError **);
static gboolean
i_face_log_processor_process_load_device_group_by_where (IFaceLogProcessor *,
                                                         gint32,
                                                         ThriftProtocol *,
                                                         ThriftProtocol *,
                                                         GError **);
static gboolean
i_face_log_processor_process_load_device_group_id_by_where (IFaceLogProcessor *,
                                                            gint32,
                                                            ThriftProtocol *,
                                                            ThriftProtocol *,
                                                            GError **);
static gboolean
i_face_log_processor_process_load_device_id_by_where (IFaceLogProcessor *,
                                                      gint32,
                                                      ThriftProtocol *,
                                                      ThriftProtocol *,
                                                      GError **);
static gboolean
i_face_log_processor_process_load_distinct_integer_column (IFaceLogProcessor *,
                                                           gint32,
                                                           ThriftProtocol *,
                                                           ThriftProtocol *,
                                                           GError **);
static gboolean
i_face_log_processor_process_load_distinct_string_column (IFaceLogProcessor *,
                                                          gint32,
                                                          ThriftProtocol *,
                                                          ThriftProtocol *,
                                                          GError **);
static gboolean
i_face_log_processor_process_load_feature_md5_by_update (IFaceLogProcessor *,
                                                         gint32,
                                                         ThriftProtocol *,
                                                         ThriftProtocol *,
                                                         GError **);
static gboolean
i_face_log_processor_process_load_feature_md5_by_update_time_str (IFaceLogProcessor *,
                                                                  gint32,
                                                                  ThriftProtocol *,
                                                                  ThriftProtocol *,
                                                                  GError **);
static gboolean
i_face_log_processor_process_load_log_by_where (IFaceLogProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
i_face_log_processor_process_load_log_light_by_verify_time (IFaceLogProcessor *,
                                                            gint32,
                                                            ThriftProtocol *,
                                                            ThriftProtocol *,
                                                            GError **);
static gboolean
i_face_log_processor_process_load_log_light_by_verify_time_timestr (IFaceLogProcessor *,
                                                                    gint32,
                                                                    ThriftProtocol *,
                                                                    ThriftProtocol *,
                                                                    GError **);
static gboolean
i_face_log_processor_process_load_log_light_by_where (IFaceLogProcessor *,
                                                      gint32,
                                                      ThriftProtocol *,
                                                      ThriftProtocol *,
                                                      GError **);
static gboolean
i_face_log_processor_process_load_permit_by_update (IFaceLogProcessor *,
                                                    gint32,
                                                    ThriftProtocol *,
                                                    ThriftProtocol *,
                                                    GError **);
static gboolean
i_face_log_processor_process_load_permit_by_update_timestr (IFaceLogProcessor *,
                                                            gint32,
                                                            ThriftProtocol *,
                                                            ThriftProtocol *,
                                                            GError **);
static gboolean
i_face_log_processor_process_load_person_by_where (IFaceLogProcessor *,
                                                   gint32,
                                                   ThriftProtocol *,
                                                   ThriftProtocol *,
                                                   GError **);
static gboolean
i_face_log_processor_process_load_person_group_by_where (IFaceLogProcessor *,
                                                         gint32,
                                                         ThriftProtocol *,
                                                         ThriftProtocol *,
                                                         GError **);
static gboolean
i_face_log_processor_process_load_person_group_id_by_where (IFaceLogProcessor *,
                                                            gint32,
                                                            ThriftProtocol *,
                                                            ThriftProtocol *,
                                                            GError **);
static gboolean
i_face_log_processor_process_load_person_id_by_update_time (IFaceLogProcessor *,
                                                            gint32,
                                                            ThriftProtocol *,
                                                            ThriftProtocol *,
                                                            GError **);
static gboolean
i_face_log_processor_process_load_person_id_by_update_time_time_str (IFaceLogProcessor *,
                                                                     gint32,
                                                                     ThriftProtocol *,
                                                                     ThriftProtocol *,
                                                                     GError **);
static gboolean
i_face_log_processor_process_load_person_id_by_where (IFaceLogProcessor *,
                                                      gint32,
                                                      ThriftProtocol *,
                                                      ThriftProtocol *,
                                                      GError **);
static gboolean
i_face_log_processor_process_load_updated_persons (IFaceLogProcessor *,
                                                   gint32,
                                                   ThriftProtocol *,
                                                   ThriftProtocol *,
                                                   GError **);
static gboolean
i_face_log_processor_process_load_updated_persons_timestr (IFaceLogProcessor *,
                                                           gint32,
                                                           ThriftProtocol *,
                                                           ThriftProtocol *,
                                                           GError **);
static gboolean
i_face_log_processor_process_offline (IFaceLogProcessor *,
                                      gint32,
                                      ThriftProtocol *,
                                      ThriftProtocol *,
                                      GError **);
static gboolean
i_face_log_processor_process_online (IFaceLogProcessor *,
                                     gint32,
                                     ThriftProtocol *,
                                     ThriftProtocol *,
                                     GError **);
static gboolean
i_face_log_processor_process_register_device (IFaceLogProcessor *,
                                              gint32,
                                              ThriftProtocol *,
                                              ThriftProtocol *,
                                              GError **);
static gboolean
i_face_log_processor_process_release_person_token (IFaceLogProcessor *,
                                                   gint32,
                                                   ThriftProtocol *,
                                                   ThriftProtocol *,
                                                   GError **);
static gboolean
i_face_log_processor_process_release_root_token (IFaceLogProcessor *,
                                                 gint32,
                                                 ThriftProtocol *,
                                                 ThriftProtocol *,
                                                 GError **);
static gboolean
i_face_log_processor_process_release_user_token (IFaceLogProcessor *,
                                                 gint32,
                                                 ThriftProtocol *,
                                                 ThriftProtocol *,
                                                 GError **);
static gboolean
i_face_log_processor_process_replace_feature (IFaceLogProcessor *,
                                              gint32,
                                              ThriftProtocol *,
                                              ThriftProtocol *,
                                              GError **);
static gboolean
i_face_log_processor_process_root_group_of_device (IFaceLogProcessor *,
                                                   gint32,
                                                   ThriftProtocol *,
                                                   ThriftProtocol *,
                                                   GError **);
static gboolean
i_face_log_processor_process_root_group_of_person (IFaceLogProcessor *,
                                                   gint32,
                                                   ThriftProtocol *,
                                                   ThriftProtocol *,
                                                   GError **);
static gboolean
i_face_log_processor_process_run_cmd (IFaceLogProcessor *,
                                      gint32,
                                      ThriftProtocol *,
                                      ThriftProtocol *,
                                      GError **);
static gboolean
i_face_log_processor_process_run_task (IFaceLogProcessor *,
                                       gint32,
                                       ThriftProtocol *,
                                       ThriftProtocol *,
                                       GError **);
static gboolean
i_face_log_processor_process_save_device (IFaceLogProcessor *,
                                          gint32,
                                          ThriftProtocol *,
                                          ThriftProtocol *,
                                          GError **);
static gboolean
i_face_log_processor_process_save_device_group (IFaceLogProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
i_face_log_processor_process_save_permit (IFaceLogProcessor *,
                                          gint32,
                                          ThriftProtocol *,
                                          ThriftProtocol *,
                                          GError **);
static gboolean
i_face_log_processor_process_save_permit_with_schedule (IFaceLogProcessor *,
                                                        gint32,
                                                        ThriftProtocol *,
                                                        ThriftProtocol *,
                                                        GError **);
static gboolean
i_face_log_processor_process_save_person (IFaceLogProcessor *,
                                          gint32,
                                          ThriftProtocol *,
                                          ThriftProtocol *,
                                          GError **);
static gboolean
i_face_log_processor_process_save_person_full (IFaceLogProcessor *,
                                               gint32,
                                               ThriftProtocol *,
                                               ThriftProtocol *,
                                               GError **);
static gboolean
i_face_log_processor_process_save_person_group (IFaceLogProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
i_face_log_processor_process_save_person_with_photo (IFaceLogProcessor *,
                                                     gint32,
                                                     ThriftProtocol *,
                                                     ThriftProtocol *,
                                                     GError **);
static gboolean
i_face_log_processor_process_save_person_with_photo_and_feature (IFaceLogProcessor *,
                                                                 gint32,
                                                                 ThriftProtocol *,
                                                                 ThriftProtocol *,
                                                                 GError **);
static gboolean
i_face_log_processor_process_save_person_with_photo_and_feature_multi_faces (IFaceLogProcessor *,
                                                                             gint32,
                                                                             ThriftProtocol *,
                                                                             ThriftProtocol *,
                                                                             GError **);
static gboolean
i_face_log_processor_process_save_person_with_photo_and_feature_multi_image (IFaceLogProcessor *,
                                                                             gint32,
                                                                             ThriftProtocol *,
                                                                             ThriftProtocol *,
                                                                             GError **);
static gboolean
i_face_log_processor_process_save_person_with_photo_and_feature_saved (IFaceLogProcessor *,
                                                                       gint32,
                                                                       ThriftProtocol *,
                                                                       ThriftProtocol *,
                                                                       GError **);
static gboolean
i_face_log_processor_process_save_persons (IFaceLogProcessor *,
                                           gint32,
                                           ThriftProtocol *,
                                           ThriftProtocol *,
                                           GError **);
static gboolean
i_face_log_processor_process_save_persons_with_photo (IFaceLogProcessor *,
                                                      gint32,
                                                      ThriftProtocol *,
                                                      ThriftProtocol *,
                                                      GError **);
static gboolean
i_face_log_processor_process_save_service_config (IFaceLogProcessor *,
                                                  gint32,
                                                  ThriftProtocol *,
                                                  ThriftProtocol *,
                                                  GError **);
static gboolean
i_face_log_processor_process_sdk_task_queue_of (IFaceLogProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
i_face_log_processor_process_set_person_expiry_date (IFaceLogProcessor *,
                                                     gint32,
                                                     ThriftProtocol *,
                                                     ThriftProtocol *,
                                                     GError **);
static gboolean
i_face_log_processor_process_set_person_expiry_date_list (IFaceLogProcessor *,
                                                          gint32,
                                                          ThriftProtocol *,
                                                          ThriftProtocol *,
                                                          GError **);
static gboolean
i_face_log_processor_process_set_person_expiry_date_time_str (IFaceLogProcessor *,
                                                              gint32,
                                                              ThriftProtocol *,
                                                              ThriftProtocol *,
                                                              GError **);
static gboolean
i_face_log_processor_process_set_properties (IFaceLogProcessor *,
                                             gint32,
                                             ThriftProtocol *,
                                             ThriftProtocol *,
                                             GError **);
static gboolean
i_face_log_processor_process_set_property (IFaceLogProcessor *,
                                           gint32,
                                           ThriftProtocol *,
                                           ThriftProtocol *,
                                           GError **);
static gboolean
i_face_log_processor_process_task_queue_of (IFaceLogProcessor *,
                                            gint32,
                                            ThriftProtocol *,
                                            ThriftProtocol *,
                                            GError **);
static gboolean
i_face_log_processor_process_unbind_border (IFaceLogProcessor *,
                                            gint32,
                                            ThriftProtocol *,
                                            ThriftProtocol *,
                                            GError **);
static gboolean
i_face_log_processor_process_unregister_device (IFaceLogProcessor *,
                                                gint32,
                                                ThriftProtocol *,
                                                ThriftProtocol *,
                                                GError **);
static gboolean
i_face_log_processor_process_update_device (IFaceLogProcessor *,
                                            gint32,
                                            ThriftProtocol *,
                                            ThriftProtocol *,
                                            GError **);
static gboolean
i_face_log_processor_process_version (IFaceLogProcessor *,
                                      gint32,
                                      ThriftProtocol *,
                                      ThriftProtocol *,
                                      GError **);
static gboolean
i_face_log_processor_process_version_info (IFaceLogProcessor *,
                                           gint32,
                                           ThriftProtocol *,
                                           ThriftProtocol *,
                                           GError **);

static i_face_log_processor_process_function_def
i_face_log_processor_process_function_defs[158] = {
  {
    "addFeature",
    i_face_log_processor_process_add_feature
  },
  {
    "addFeatureMulti",
    i_face_log_processor_process_add_feature_multi
  },
  {
    "addFeatureWithImage",
    i_face_log_processor_process_add_feature_with_image
  },
  {
    "addImage",
    i_face_log_processor_process_add_image
  },
  {
    "addLog",
    i_face_log_processor_process_add_log
  },
  {
    "addLogFull",
    i_face_log_processor_process_add_log_full
  },
  {
    "addLogs",
    i_face_log_processor_process_add_logs
  },
  {
    "addLogsFull",
    i_face_log_processor_process_add_logs_full
  },
  {
    "applyAckChannel",
    i_face_log_processor_process_apply_ack_channel
  },
  {
    "applyAckChannelWithDuration",
    i_face_log_processor_process_apply_ack_channel_with_duration
  },
  {
    "applyCmdSn",
    i_face_log_processor_process_apply_cmd_sn
  },
  {
    "applyPersonToken",
    i_face_log_processor_process_apply_person_token
  },
  {
    "applyRootToken",
    i_face_log_processor_process_apply_root_token
  },
  {
    "applyUserToken",
    i_face_log_processor_process_apply_user_token
  },
  {
    "bindBorder",
    i_face_log_processor_process_bind_border
  },
  {
    "childListForDeviceGroup",
    i_face_log_processor_process_child_list_for_device_group
  },
  {
    "childListForPersonGroup",
    i_face_log_processor_process_child_list_for_person_group
  },
  {
    "countDeviceByWhere",
    i_face_log_processor_process_count_device_by_where
  },
  {
    "countDeviceGroupByWhere",
    i_face_log_processor_process_count_device_group_by_where
  },
  {
    "countLogByWhere",
    i_face_log_processor_process_count_log_by_where
  },
  {
    "countLogLightByVerifyTime",
    i_face_log_processor_process_count_log_light_by_verify_time
  },
  {
    "countLogLightByVerifyTimeTimestr",
    i_face_log_processor_process_count_log_light_by_verify_time_timestr
  },
  {
    "countLogLightByWhere",
    i_face_log_processor_process_count_log_light_by_where
  },
  {
    "countPersonByWhere",
    i_face_log_processor_process_count_person_by_where
  },
  {
    "countPersonGroupByWhere",
    i_face_log_processor_process_count_person_group_by_where
  },
  {
    "deleteAllFeaturesByPersonId",
    i_face_log_processor_process_delete_all_features_by_person_id
  },
  {
    "deleteDeviceGroup",
    i_face_log_processor_process_delete_device_group
  },
  {
    "deleteFeature",
    i_face_log_processor_process_delete_feature
  },
  {
    "deleteGroupPermitOnDeviceGroup",
    i_face_log_processor_process_delete_group_permit_on_device_group
  },
  {
    "deleteImage",
    i_face_log_processor_process_delete_image
  },
  {
    "deletePermitById",
    i_face_log_processor_process_delete_permit_by_id
  },
  {
    "deletePerson",
    i_face_log_processor_process_delete_person
  },
  {
    "deletePersonByPapersNum",
    i_face_log_processor_process_delete_person_by_papers_num
  },
  {
    "deletePersonGroup",
    i_face_log_processor_process_delete_person_group
  },
  {
    "deletePersonGroupPermit",
    i_face_log_processor_process_delete_person_group_permit
  },
  {
    "deletePersons",
    i_face_log_processor_process_delete_persons
  },
  {
    "deletePersonsByPapersNum",
    i_face_log_processor_process_delete_persons_by_papers_num
  },
  {
    "disablePerson",
    i_face_log_processor_process_disable_person
  },
  {
    "disablePersonList",
    i_face_log_processor_process_disable_person_list
  },
  {
    "existsDevice",
    i_face_log_processor_process_exists_device
  },
  {
    "existsFeature",
    i_face_log_processor_process_exists_feature
  },
  {
    "existsImage",
    i_face_log_processor_process_exists_image
  },
  {
    "existsPerson",
    i_face_log_processor_process_exists_person
  },
  {
    "getDevice",
    i_face_log_processor_process_get_device
  },
  {
    "getDeviceByMac",
    i_face_log_processor_process_get_device_by_mac
  },
  {
    "getDeviceGroup",
    i_face_log_processor_process_get_device_group
  },
  {
    "getDeviceGroups",
    i_face_log_processor_process_get_device_groups
  },
  {
    "getDeviceGroupsBelongs",
    i_face_log_processor_process_get_device_groups_belongs
  },
  {
    "getDeviceGroupsPermit",
    i_face_log_processor_process_get_device_groups_permit
  },
  {
    "getDeviceGroupsPermittedBy",
    i_face_log_processor_process_get_device_groups_permitted_by
  },
  {
    "getDeviceIdOfFeature",
    i_face_log_processor_process_get_device_id_of_feature
  },
  {
    "getDevices",
    i_face_log_processor_process_get_devices
  },
  {
    "getDevicesOfGroup",
    i_face_log_processor_process_get_devices_of_group
  },
  {
    "getFace",
    i_face_log_processor_process_get_face
  },
  {
    "getFeature",
    i_face_log_processor_process_get_feature
  },
  {
    "getFeatureBytes",
    i_face_log_processor_process_get_feature_bytes
  },
  {
    "getFeatures",
    i_face_log_processor_process_get_features
  },
  {
    "getFeaturesByPersonIdAndSdkVersion",
    i_face_log_processor_process_get_features_by_person_id_and_sdk_version
  },
  {
    "getFeaturesOfPerson",
    i_face_log_processor_process_get_features_of_person
  },
  {
    "getFeaturesPermittedOnDevice",
    i_face_log_processor_process_get_features_permitted_on_device
  },
  {
    "getGroupPermit",
    i_face_log_processor_process_get_group_permit
  },
  {
    "getGroupPermitOnDeviceGroup",
    i_face_log_processor_process_get_group_permit_on_device_group
  },
  {
    "getGroupPermits",
    i_face_log_processor_process_get_group_permits
  },
  {
    "getImage",
    i_face_log_processor_process_get_image
  },
  {
    "getImageBytes",
    i_face_log_processor_process_get_image_bytes
  },
  {
    "getImagesAssociatedByFeature",
    i_face_log_processor_process_get_images_associated_by_feature
  },
  {
    "getLogBeansByPersonId",
    i_face_log_processor_process_get_log_beans_by_person_id
  },
  {
    "getPerson",
    i_face_log_processor_process_get_person
  },
  {
    "getPersonByMobilePhone",
    i_face_log_processor_process_get_person_by_mobile_phone
  },
  {
    "getPersonByPapersNum",
    i_face_log_processor_process_get_person_by_papers_num
  },
  {
    "getPersonGroup",
    i_face_log_processor_process_get_person_group
  },
  {
    "getPersonGroups",
    i_face_log_processor_process_get_person_groups
  },
  {
    "getPersonGroupsBelongs",
    i_face_log_processor_process_get_person_groups_belongs
  },
  {
    "getPersonGroupsPermittedBy",
    i_face_log_processor_process_get_person_groups_permitted_by
  },
  {
    "getPersonPermit",
    i_face_log_processor_process_get_person_permit
  },
  {
    "getPersonPermits",
    i_face_log_processor_process_get_person_permits
  },
  {
    "getPersons",
    i_face_log_processor_process_get_persons
  },
  {
    "getPersonsOfGroup",
    i_face_log_processor_process_get_persons_of_group
  },
  {
    "getPersonsPermittedOnDevice",
    i_face_log_processor_process_get_persons_permitted_on_device
  },
  {
    "getProperties",
    i_face_log_processor_process_get_properties
  },
  {
    "getProperty",
    i_face_log_processor_process_get_property
  },
  {
    "getRedisParameters",
    i_face_log_processor_process_get_redis_parameters
  },
  {
    "getServiceConfig",
    i_face_log_processor_process_get_service_config
  },
  {
    "getSubDeviceGroup",
    i_face_log_processor_process_get_sub_device_group
  },
  {
    "getSubPersonGroup",
    i_face_log_processor_process_get_sub_person_group
  },
  {
    "isDisable",
    i_face_log_processor_process_is_disable
  },
  {
    "isLocal",
    i_face_log_processor_process_is_local
  },
  {
    "isValidAckChannel",
    i_face_log_processor_process_is_valid_ack_channel
  },
  {
    "isValidCmdSn",
    i_face_log_processor_process_is_valid_cmd_sn
  },
  {
    "isValidDeviceToken",
    i_face_log_processor_process_is_valid_device_token
  },
  {
    "isValidPassword",
    i_face_log_processor_process_is_valid_password
  },
  {
    "isValidPersonToken",
    i_face_log_processor_process_is_valid_person_token
  },
  {
    "isValidRootToken",
    i_face_log_processor_process_is_valid_root_token
  },
  {
    "isValidToken",
    i_face_log_processor_process_is_valid_token
  },
  {
    "isValidUserToken",
    i_face_log_processor_process_is_valid_user_token
  },
  {
    "listOfParentForDeviceGroup",
    i_face_log_processor_process_list_of_parent_for_device_group
  },
  {
    "listOfParentForPersonGroup",
    i_face_log_processor_process_list_of_parent_for_person_group
  },
  {
    "loadAllPerson",
    i_face_log_processor_process_load_all_person
  },
  {
    "loadDeviceByWhere",
    i_face_log_processor_process_load_device_by_where
  },
  {
    "loadDeviceGroupByWhere",
    i_face_log_processor_process_load_device_group_by_where
  },
  {
    "loadDeviceGroupIdByWhere",
    i_face_log_processor_process_load_device_group_id_by_where
  },
  {
    "loadDeviceIdByWhere",
    i_face_log_processor_process_load_device_id_by_where
  },
  {
    "loadDistinctIntegerColumn",
    i_face_log_processor_process_load_distinct_integer_column
  },
  {
    "loadDistinctStringColumn",
    i_face_log_processor_process_load_distinct_string_column
  },
  {
    "loadFeatureMd5ByUpdate",
    i_face_log_processor_process_load_feature_md5_by_update
  },
  {
    "loadFeatureMd5ByUpdateTimeStr",
    i_face_log_processor_process_load_feature_md5_by_update_time_str
  },
  {
    "loadLogByWhere",
    i_face_log_processor_process_load_log_by_where
  },
  {
    "loadLogLightByVerifyTime",
    i_face_log_processor_process_load_log_light_by_verify_time
  },
  {
    "loadLogLightByVerifyTimeTimestr",
    i_face_log_processor_process_load_log_light_by_verify_time_timestr
  },
  {
    "loadLogLightByWhere",
    i_face_log_processor_process_load_log_light_by_where
  },
  {
    "loadPermitByUpdate",
    i_face_log_processor_process_load_permit_by_update
  },
  {
    "loadPermitByUpdateTimestr",
    i_face_log_processor_process_load_permit_by_update_timestr
  },
  {
    "loadPersonByWhere",
    i_face_log_processor_process_load_person_by_where
  },
  {
    "loadPersonGroupByWhere",
    i_face_log_processor_process_load_person_group_by_where
  },
  {
    "loadPersonGroupIdByWhere",
    i_face_log_processor_process_load_person_group_id_by_where
  },
  {
    "loadPersonIdByUpdateTime",
    i_face_log_processor_process_load_person_id_by_update_time
  },
  {
    "loadPersonIdByUpdateTimeTimeStr",
    i_face_log_processor_process_load_person_id_by_update_time_time_str
  },
  {
    "loadPersonIdByWhere",
    i_face_log_processor_process_load_person_id_by_where
  },
  {
    "loadUpdatedPersons",
    i_face_log_processor_process_load_updated_persons
  },
  {
    "loadUpdatedPersonsTimestr",
    i_face_log_processor_process_load_updated_persons_timestr
  },
  {
    "offline",
    i_face_log_processor_process_offline
  },
  {
    "online",
    i_face_log_processor_process_online
  },
  {
    "registerDevice",
    i_face_log_processor_process_register_device
  },
  {
    "releasePersonToken",
    i_face_log_processor_process_release_person_token
  },
  {
    "releaseRootToken",
    i_face_log_processor_process_release_root_token
  },
  {
    "releaseUserToken",
    i_face_log_processor_process_release_user_token
  },
  {
    "replaceFeature",
    i_face_log_processor_process_replace_feature
  },
  {
    "rootGroupOfDevice",
    i_face_log_processor_process_root_group_of_device
  },
  {
    "rootGroupOfPerson",
    i_face_log_processor_process_root_group_of_person
  },
  {
    "runCmd",
    i_face_log_processor_process_run_cmd
  },
  {
    "runTask",
    i_face_log_processor_process_run_task
  },
  {
    "saveDevice",
    i_face_log_processor_process_save_device
  },
  {
    "saveDeviceGroup",
    i_face_log_processor_process_save_device_group
  },
  {
    "savePermit",
    i_face_log_processor_process_save_permit
  },
  {
    "savePermitWithSchedule",
    i_face_log_processor_process_save_permit_with_schedule
  },
  {
    "savePerson",
    i_face_log_processor_process_save_person
  },
  {
    "savePersonFull",
    i_face_log_processor_process_save_person_full
  },
  {
    "savePersonGroup",
    i_face_log_processor_process_save_person_group
  },
  {
    "savePersonWithPhoto",
    i_face_log_processor_process_save_person_with_photo
  },
  {
    "savePersonWithPhotoAndFeature",
    i_face_log_processor_process_save_person_with_photo_and_feature
  },
  {
    "savePersonWithPhotoAndFeatureMultiFaces",
    i_face_log_processor_process_save_person_with_photo_and_feature_multi_faces
  },
  {
    "savePersonWithPhotoAndFeatureMultiImage",
    i_face_log_processor_process_save_person_with_photo_and_feature_multi_image
  },
  {
    "savePersonWithPhotoAndFeatureSaved",
    i_face_log_processor_process_save_person_with_photo_and_feature_saved
  },
  {
    "savePersons",
    i_face_log_processor_process_save_persons
  },
  {
    "savePersonsWithPhoto",
    i_face_log_processor_process_save_persons_with_photo
  },
  {
    "saveServiceConfig",
    i_face_log_processor_process_save_service_config
  },
  {
    "sdkTaskQueueOf",
    i_face_log_processor_process_sdk_task_queue_of
  },
  {
    "setPersonExpiryDate",
    i_face_log_processor_process_set_person_expiry_date
  },
  {
    "setPersonExpiryDateList",
    i_face_log_processor_process_set_person_expiry_date_list
  },
  {
    "setPersonExpiryDateTimeStr",
    i_face_log_processor_process_set_person_expiry_date_time_str
  },
  {
    "setProperties",
    i_face_log_processor_process_set_properties
  },
  {
    "setProperty",
    i_face_log_processor_process_set_property
  },
  {
    "taskQueueOf",
    i_face_log_processor_process_task_queue_of
  },
  {
    "unbindBorder",
    i_face_log_processor_process_unbind_border
  },
  {
    "unregisterDevice",
    i_face_log_processor_process_unregister_device
  },
  {
    "updateDevice",
    i_face_log_processor_process_update_device
  },
  {
    "version",
    i_face_log_processor_process_version
  },
  {
    "versionInfo",
    i_face_log_processor_process_version_info
  }
};

static gboolean
i_face_log_processor_process_add_feature (IFaceLogProcessor *self,
                                          gint32 sequence_id,
                                          ThriftProtocol *input_protocol,
                                          ThriftProtocol *output_protocol,
                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogAddFeatureArgs * args =
    g_object_new (TYPE_I_FACE_LOG_ADD_FEATURE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GByteArray * feature;
    gchar * featureVersion;
    gint personId;
    GPtrArray * faecBeans;
    Token * token;
    DuplicateRecordException * ex1 = NULL;
    ServiceRuntimeException * ex2 = NULL;
    FeatureBean * return_value;
    IFaceLogAddFeatureResult * result_struct;

    g_object_get (args,
                  "feature", &feature,
                  "featureVersion", &featureVersion,
                  "personId", &personId,
                  "faecBeans", &faecBeans,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_ADD_FEATURE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_add_feature (I_FACE_LOG_IF (self->handler),
                                        &return_value,
                                        feature,
                                        featureVersion,
                                        personId,
                                        faecBeans,
                                        token,
                                        &ex1,
                                        &ex2,
                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "addFeature",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addFeature",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ex2 != NULL)
      {
        g_object_set (result_struct,
                      "ex2", ex2,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addFeature",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.addFeature implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addFeature",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (feature != NULL)
      g_byte_array_unref (feature);
    if (featureVersion != NULL)
      g_free (featureVersion);
    if (faecBeans != NULL)
      g_ptr_array_unref (faecBeans);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_add_feature_multi (IFaceLogProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogAddFeatureMultiArgs * args =
    g_object_new (TYPE_I_FACE_LOG_ADD_FEATURE_MULTI_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GByteArray * feature;
    gchar * featureVersion;
    gint personId;
    GPtrArray * photos;
    GPtrArray * faces;
    Token * token;
    DuplicateRecordException * ex1 = NULL;
    ServiceRuntimeException * ex2 = NULL;
    FeatureBean * return_value;
    IFaceLogAddFeatureMultiResult * result_struct;

    g_object_get (args,
                  "feature", &feature,
                  "featureVersion", &featureVersion,
                  "personId", &personId,
                  "photos", &photos,
                  "faces", &faces,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_ADD_FEATURE_MULTI_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_add_feature_multi (I_FACE_LOG_IF (self->handler),
                                              &return_value,
                                              feature,
                                              featureVersion,
                                              personId,
                                              photos,
                                              faces,
                                              token,
                                              &ex1,
                                              &ex2,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "addFeatureMulti",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addFeatureMulti",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ex2 != NULL)
      {
        g_object_set (result_struct,
                      "ex2", ex2,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addFeatureMulti",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.addFeatureMulti implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addFeatureMulti",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (feature != NULL)
      g_byte_array_unref (feature);
    if (featureVersion != NULL)
      g_free (featureVersion);
    if (photos != NULL)
      g_ptr_array_unref (photos);
    if (faces != NULL)
      g_ptr_array_unref (faces);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_add_feature_with_image (IFaceLogProcessor *self,
                                                     gint32 sequence_id,
                                                     ThriftProtocol *input_protocol,
                                                     ThriftProtocol *output_protocol,
                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogAddFeatureWithImageArgs * args =
    g_object_new (TYPE_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GByteArray * feature;
    gchar * featureVersion;
    gint personId;
    gboolean asIdPhotoIfAbsent;
    GByteArray * featurePhoto;
    FaceBean * faceBean;
    Token * token;
    DuplicateRecordException * ex1 = NULL;
    ServiceRuntimeException * ex2 = NULL;
    FeatureBean * return_value;
    IFaceLogAddFeatureWithImageResult * result_struct;

    g_object_get (args,
                  "feature", &feature,
                  "featureVersion", &featureVersion,
                  "personId", &personId,
                  "asIdPhotoIfAbsent", &asIdPhotoIfAbsent,
                  "featurePhoto", &featurePhoto,
                  "faceBean", &faceBean,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_ADD_FEATURE_WITH_IMAGE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_add_feature_with_image (I_FACE_LOG_IF (self->handler),
                                                   &return_value,
                                                   feature,
                                                   featureVersion,
                                                   personId,
                                                   asIdPhotoIfAbsent,
                                                   featurePhoto,
                                                   faceBean,
                                                   token,
                                                   &ex1,
                                                   &ex2,
                                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "addFeatureWithImage",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addFeatureWithImage",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ex2 != NULL)
      {
        g_object_set (result_struct,
                      "ex2", ex2,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addFeatureWithImage",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.addFeatureWithImage implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addFeatureWithImage",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (feature != NULL)
      g_byte_array_unref (feature);
    if (featureVersion != NULL)
      g_free (featureVersion);
    if (featurePhoto != NULL)
      g_byte_array_unref (featurePhoto);
    if (faceBean != NULL)
      g_object_unref (faceBean);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_add_image (IFaceLogProcessor *self,
                                        gint32 sequence_id,
                                        ThriftProtocol *input_protocol,
                                        ThriftProtocol *output_protocol,
                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogAddImageArgs * args =
    g_object_new (TYPE_I_FACE_LOG_ADD_IMAGE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GByteArray * imageData;
    gint deviceId;
    FaceBean * faceBean;
    gint personId;
    Token * token;
    DuplicateRecordException * ex1 = NULL;
    ServiceRuntimeException * ex2 = NULL;
    ImageBean * return_value;
    IFaceLogAddImageResult * result_struct;

    g_object_get (args,
                  "imageData", &imageData,
                  "deviceId", &deviceId,
                  "faceBean", &faceBean,
                  "personId", &personId,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_ADD_IMAGE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_add_image (I_FACE_LOG_IF (self->handler),
                                      &return_value,
                                      imageData,
                                      deviceId,
                                      faceBean,
                                      personId,
                                      token,
                                      &ex1,
                                      &ex2,
                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "addImage",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addImage",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ex2 != NULL)
      {
        g_object_set (result_struct,
                      "ex2", ex2,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addImage",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.addImage implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addImage",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (imageData != NULL)
      g_byte_array_unref (imageData);
    if (faceBean != NULL)
      g_object_unref (faceBean);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_add_log (IFaceLogProcessor *self,
                                      gint32 sequence_id,
                                      ThriftProtocol *input_protocol,
                                      ThriftProtocol *output_protocol,
                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogAddLogArgs * args =
    g_object_new (TYPE_I_FACE_LOG_ADD_LOG_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    LogBean * logBean;
    Token * token;
    DuplicateRecordException * ex1 = NULL;
    ServiceRuntimeException * ex2 = NULL;
    IFaceLogAddLogResult * result_struct;

    g_object_get (args,
                  "logBean", &logBean,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_ADD_LOG_RESULT, NULL);

    if (i_face_log_handler_add_log (I_FACE_LOG_IF (self->handler),
                                    logBean,
                                    token,
                                    &ex1,
                                    &ex2,
                                    error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "addLog",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addLog",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ex2 != NULL)
      {
        g_object_set (result_struct,
                      "ex2", ex2,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addLog",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.addLog implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addLog",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (logBean != NULL)
      g_object_unref (logBean);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_add_log_full (IFaceLogProcessor *self,
                                           gint32 sequence_id,
                                           ThriftProtocol *input_protocol,
                                           ThriftProtocol *output_protocol,
                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogAddLogFullArgs * args =
    g_object_new (TYPE_I_FACE_LOG_ADD_LOG_FULL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    LogBean * logBean;
    FaceBean * faceBean;
    GByteArray * featureImage;
    Token * token;
    DuplicateRecordException * ex1 = NULL;
    ServiceRuntimeException * ex2 = NULL;
    IFaceLogAddLogFullResult * result_struct;

    g_object_get (args,
                  "logBean", &logBean,
                  "faceBean", &faceBean,
                  "featureImage", &featureImage,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_ADD_LOG_FULL_RESULT, NULL);

    if (i_face_log_handler_add_log_full (I_FACE_LOG_IF (self->handler),
                                         logBean,
                                         faceBean,
                                         featureImage,
                                         token,
                                         &ex1,
                                         &ex2,
                                         error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "addLogFull",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addLogFull",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ex2 != NULL)
      {
        g_object_set (result_struct,
                      "ex2", ex2,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addLogFull",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.addLogFull implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addLogFull",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (logBean != NULL)
      g_object_unref (logBean);
    if (faceBean != NULL)
      g_object_unref (faceBean);
    if (featureImage != NULL)
      g_byte_array_unref (featureImage);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_add_logs (IFaceLogProcessor *self,
                                       gint32 sequence_id,
                                       ThriftProtocol *input_protocol,
                                       ThriftProtocol *output_protocol,
                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogAddLogsArgs * args =
    g_object_new (TYPE_I_FACE_LOG_ADD_LOGS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * beans;
    Token * token;
    DuplicateRecordException * ex1 = NULL;
    ServiceRuntimeException * ex2 = NULL;
    IFaceLogAddLogsResult * result_struct;

    g_object_get (args,
                  "beans", &beans,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_ADD_LOGS_RESULT, NULL);

    if (i_face_log_handler_add_logs (I_FACE_LOG_IF (self->handler),
                                     beans,
                                     token,
                                     &ex1,
                                     &ex2,
                                     error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "addLogs",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addLogs",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ex2 != NULL)
      {
        g_object_set (result_struct,
                      "ex2", ex2,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addLogs",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.addLogs implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addLogs",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (beans != NULL)
      g_ptr_array_unref (beans);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_add_logs_full (IFaceLogProcessor *self,
                                            gint32 sequence_id,
                                            ThriftProtocol *input_protocol,
                                            ThriftProtocol *output_protocol,
                                            GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogAddLogsFullArgs * args =
    g_object_new (TYPE_I_FACE_LOG_ADD_LOGS_FULL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * logBeans;
    GPtrArray * faceBeans;
    GPtrArray * featureImages;
    Token * token;
    DuplicateRecordException * ex1 = NULL;
    ServiceRuntimeException * ex2 = NULL;
    IFaceLogAddLogsFullResult * result_struct;

    g_object_get (args,
                  "logBeans", &logBeans,
                  "faceBeans", &faceBeans,
                  "featureImages", &featureImages,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_ADD_LOGS_FULL_RESULT, NULL);

    if (i_face_log_handler_add_logs_full (I_FACE_LOG_IF (self->handler),
                                          logBeans,
                                          faceBeans,
                                          featureImages,
                                          token,
                                          &ex1,
                                          &ex2,
                                          error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "addLogsFull",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addLogsFull",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ex2 != NULL)
      {
        g_object_set (result_struct,
                      "ex2", ex2,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addLogsFull",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.addLogsFull implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "addLogsFull",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (logBeans != NULL)
      g_ptr_array_unref (logBeans);
    if (faceBeans != NULL)
      g_ptr_array_unref (faceBeans);
    if (featureImages != NULL)
      g_ptr_array_unref (featureImages);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_apply_ack_channel (IFaceLogProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogApplyAckChannelArgs * args =
    g_object_new (TYPE_I_FACE_LOG_APPLY_ACK_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gchar * return_value;
    IFaceLogApplyAckChannelResult * result_struct;

    g_object_get (args,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_APPLY_ACK_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_apply_ack_channel (I_FACE_LOG_IF (self->handler),
                                              &return_value,
                                              token,
                                              &ex1,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_free (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "applyAckChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "applyAckChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.applyAckChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "applyAckChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_apply_ack_channel_with_duration (IFaceLogProcessor *self,
                                                              gint32 sequence_id,
                                                              ThriftProtocol *input_protocol,
                                                              ThriftProtocol *output_protocol,
                                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogApplyAckChannelWithDurationArgs * args =
    g_object_new (TYPE_I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint duration;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gchar * return_value;
    IFaceLogApplyAckChannelWithDurationResult * result_struct;

    g_object_get (args,
                  "duration", &duration,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_APPLY_ACK_CHANNEL_WITH_DURATION_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_apply_ack_channel_with_duration (I_FACE_LOG_IF (self->handler),
                                                            &return_value,
                                                            duration,
                                                            token,
                                                            &ex1,
                                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_free (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "applyAckChannelWithDuration",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "applyAckChannelWithDuration",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.applyAckChannelWithDuration implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "applyAckChannelWithDuration",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_apply_cmd_sn (IFaceLogProcessor *self,
                                           gint32 sequence_id,
                                           ThriftProtocol *input_protocol,
                                           ThriftProtocol *output_protocol,
                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogApplyCmdSnArgs * args =
    g_object_new (TYPE_I_FACE_LOG_APPLY_CMD_SN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogApplyCmdSnResult * result_struct;

    g_object_get (args,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_APPLY_CMD_SN_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_apply_cmd_sn (I_FACE_LOG_IF (self->handler),
                                         (gint32 *)&return_value,
                                         token,
                                         &ex1,
                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "applyCmdSn",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "applyCmdSn",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.applyCmdSn implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "applyCmdSn",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_apply_person_token (IFaceLogProcessor *self,
                                                 gint32 sequence_id,
                                                 ThriftProtocol *input_protocol,
                                                 ThriftProtocol *output_protocol,
                                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogApplyPersonTokenArgs * args =
    g_object_new (TYPE_I_FACE_LOG_APPLY_PERSON_TOKEN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personId;
    gchar * password;
    gboolean isMd5;
    ServiceSecurityException * ex1 = NULL;
    ServiceRuntimeException * ex2 = NULL;
    Token * return_value;
    IFaceLogApplyPersonTokenResult * result_struct;

    g_object_get (args,
                  "personId", &personId,
                  "password", &password,
                  "isMd5", &isMd5,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_APPLY_PERSON_TOKEN_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_apply_person_token (I_FACE_LOG_IF (self->handler),
                                               &return_value,
                                               personId,
                                               password,
                                               isMd5,
                                               &ex1,
                                               &ex2,
                                               error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "applyPersonToken",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "applyPersonToken",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ex2 != NULL)
      {
        g_object_set (result_struct,
                      "ex2", ex2,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "applyPersonToken",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.applyPersonToken implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "applyPersonToken",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (password != NULL)
      g_free (password);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_apply_root_token (IFaceLogProcessor *self,
                                               gint32 sequence_id,
                                               ThriftProtocol *input_protocol,
                                               ThriftProtocol *output_protocol,
                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogApplyRootTokenArgs * args =
    g_object_new (TYPE_I_FACE_LOG_APPLY_ROOT_TOKEN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * password;
    gboolean isMd5;
    ServiceSecurityException * ex1 = NULL;
    ServiceRuntimeException * ex2 = NULL;
    Token * return_value;
    IFaceLogApplyRootTokenResult * result_struct;

    g_object_get (args,
                  "password", &password,
                  "isMd5", &isMd5,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_APPLY_ROOT_TOKEN_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_apply_root_token (I_FACE_LOG_IF (self->handler),
                                             &return_value,
                                             password,
                                             isMd5,
                                             &ex1,
                                             &ex2,
                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "applyRootToken",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "applyRootToken",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ex2 != NULL)
      {
        g_object_set (result_struct,
                      "ex2", ex2,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "applyRootToken",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.applyRootToken implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "applyRootToken",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (password != NULL)
      g_free (password);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_apply_user_token (IFaceLogProcessor *self,
                                               gint32 sequence_id,
                                               ThriftProtocol *input_protocol,
                                               ThriftProtocol *output_protocol,
                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogApplyUserTokenArgs * args =
    g_object_new (TYPE_I_FACE_LOG_APPLY_USER_TOKEN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint userid;
    gchar * password;
    gboolean isMd5;
    ServiceSecurityException * ex1 = NULL;
    ServiceRuntimeException * ex2 = NULL;
    Token * return_value;
    IFaceLogApplyUserTokenResult * result_struct;

    g_object_get (args,
                  "userid", &userid,
                  "password", &password,
                  "isMd5", &isMd5,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_APPLY_USER_TOKEN_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_apply_user_token (I_FACE_LOG_IF (self->handler),
                                             &return_value,
                                             userid,
                                             password,
                                             isMd5,
                                             &ex1,
                                             &ex2,
                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "applyUserToken",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "applyUserToken",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ex2 != NULL)
      {
        g_object_set (result_struct,
                      "ex2", ex2,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "applyUserToken",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.applyUserToken implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "applyUserToken",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (password != NULL)
      g_free (password);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_bind_border (IFaceLogProcessor *self,
                                          gint32 sequence_id,
                                          ThriftProtocol *input_protocol,
                                          ThriftProtocol *output_protocol,
                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogBindBorderArgs * args =
    g_object_new (TYPE_I_FACE_LOG_BIND_BORDER_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personGroupId;
    gint deviceGroupId;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    IFaceLogBindBorderResult * result_struct;

    g_object_get (args,
                  "personGroupId", &personGroupId,
                  "deviceGroupId", &deviceGroupId,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_BIND_BORDER_RESULT, NULL);

    if (i_face_log_handler_bind_border (I_FACE_LOG_IF (self->handler),
                                        personGroupId,
                                        deviceGroupId,
                                        token,
                                        &ex1,
                                        error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "bindBorder",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "bindBorder",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.bindBorder implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "bindBorder",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_child_list_for_device_group (IFaceLogProcessor *self,
                                                          gint32 sequence_id,
                                                          ThriftProtocol *input_protocol,
                                                          ThriftProtocol *output_protocol,
                                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogChildListForDeviceGroupArgs * args =
    g_object_new (TYPE_I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint deviceGroupId;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogChildListForDeviceGroupResult * result_struct;

    g_object_get (args,
                  "deviceGroupId", &deviceGroupId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_CHILD_LIST_FOR_DEVICE_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_child_list_for_device_group (I_FACE_LOG_IF (self->handler),
                                                        &return_value,
                                                        deviceGroupId,
                                                        &ex1,
                                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "childListForDeviceGroup",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "childListForDeviceGroup",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.childListForDeviceGroup implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "childListForDeviceGroup",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_child_list_for_person_group (IFaceLogProcessor *self,
                                                          gint32 sequence_id,
                                                          ThriftProtocol *input_protocol,
                                                          ThriftProtocol *output_protocol,
                                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogChildListForPersonGroupArgs * args =
    g_object_new (TYPE_I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personGroupId;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogChildListForPersonGroupResult * result_struct;

    g_object_get (args,
                  "personGroupId", &personGroupId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_CHILD_LIST_FOR_PERSON_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_child_list_for_person_group (I_FACE_LOG_IF (self->handler),
                                                        &return_value,
                                                        personGroupId,
                                                        &ex1,
                                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "childListForPersonGroup",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "childListForPersonGroup",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.childListForPersonGroup implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "childListForPersonGroup",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_count_device_by_where (IFaceLogProcessor *self,
                                                    gint32 sequence_id,
                                                    ThriftProtocol *input_protocol,
                                                    ThriftProtocol *output_protocol,
                                                    GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogCountDeviceByWhereArgs * args =
    g_object_new (TYPE_I_FACE_LOG_COUNT_DEVICE_BY_WHERE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * where;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogCountDeviceByWhereResult * result_struct;

    g_object_get (args,
                  "where", &where,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_COUNT_DEVICE_BY_WHERE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_count_device_by_where (I_FACE_LOG_IF (self->handler),
                                                  (gint32 *)&return_value,
                                                  where,
                                                  &ex1,
                                                  error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "countDeviceByWhere",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "countDeviceByWhere",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.countDeviceByWhere implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "countDeviceByWhere",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (where != NULL)
      g_free (where);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_count_device_group_by_where (IFaceLogProcessor *self,
                                                          gint32 sequence_id,
                                                          ThriftProtocol *input_protocol,
                                                          ThriftProtocol *output_protocol,
                                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogCountDeviceGroupByWhereArgs * args =
    g_object_new (TYPE_I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * where;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogCountDeviceGroupByWhereResult * result_struct;

    g_object_get (args,
                  "where", &where,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_COUNT_DEVICE_GROUP_BY_WHERE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_count_device_group_by_where (I_FACE_LOG_IF (self->handler),
                                                        (gint32 *)&return_value,
                                                        where,
                                                        &ex1,
                                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "countDeviceGroupByWhere",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "countDeviceGroupByWhere",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.countDeviceGroupByWhere implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "countDeviceGroupByWhere",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (where != NULL)
      g_free (where);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_count_log_by_where (IFaceLogProcessor *self,
                                                 gint32 sequence_id,
                                                 ThriftProtocol *input_protocol,
                                                 ThriftProtocol *output_protocol,
                                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogCountLogByWhereArgs * args =
    g_object_new (TYPE_I_FACE_LOG_COUNT_LOG_BY_WHERE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * where;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogCountLogByWhereResult * result_struct;

    g_object_get (args,
                  "where", &where,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_COUNT_LOG_BY_WHERE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_count_log_by_where (I_FACE_LOG_IF (self->handler),
                                               (gint32 *)&return_value,
                                               where,
                                               &ex1,
                                               error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "countLogByWhere",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "countLogByWhere",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.countLogByWhere implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "countLogByWhere",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (where != NULL)
      g_free (where);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_count_log_light_by_verify_time (IFaceLogProcessor *self,
                                                             gint32 sequence_id,
                                                             ThriftProtocol *input_protocol,
                                                             ThriftProtocol *output_protocol,
                                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogCountLogLightByVerifyTimeArgs * args =
    g_object_new (TYPE_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint64 timestamp;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogCountLogLightByVerifyTimeResult * result_struct;

    g_object_get (args,
                  "timestamp", &timestamp,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_count_log_light_by_verify_time (I_FACE_LOG_IF (self->handler),
                                                           (gint32 *)&return_value,
                                                           timestamp,
                                                           &ex1,
                                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "countLogLightByVerifyTime",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "countLogLightByVerifyTime",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.countLogLightByVerifyTime implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "countLogLightByVerifyTime",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_count_log_light_by_verify_time_timestr (IFaceLogProcessor *self,
                                                                     gint32 sequence_id,
                                                                     ThriftProtocol *input_protocol,
                                                                     ThriftProtocol *output_protocol,
                                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogCountLogLightByVerifyTimeTimestrArgs * args =
    g_object_new (TYPE_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * timestamp;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogCountLogLightByVerifyTimeTimestrResult * result_struct;

    g_object_get (args,
                  "timestamp", &timestamp,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_COUNT_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_count_log_light_by_verify_time_timestr (I_FACE_LOG_IF (self->handler),
                                                                   (gint32 *)&return_value,
                                                                   timestamp,
                                                                   &ex1,
                                                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "countLogLightByVerifyTimeTimestr",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "countLogLightByVerifyTimeTimestr",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.countLogLightByVerifyTimeTimestr implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "countLogLightByVerifyTimeTimestr",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (timestamp != NULL)
      g_free (timestamp);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_count_log_light_by_where (IFaceLogProcessor *self,
                                                       gint32 sequence_id,
                                                       ThriftProtocol *input_protocol,
                                                       ThriftProtocol *output_protocol,
                                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogCountLogLightByWhereArgs * args =
    g_object_new (TYPE_I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * where;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogCountLogLightByWhereResult * result_struct;

    g_object_get (args,
                  "where", &where,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_COUNT_LOG_LIGHT_BY_WHERE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_count_log_light_by_where (I_FACE_LOG_IF (self->handler),
                                                     (gint32 *)&return_value,
                                                     where,
                                                     &ex1,
                                                     error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "countLogLightByWhere",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "countLogLightByWhere",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.countLogLightByWhere implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "countLogLightByWhere",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (where != NULL)
      g_free (where);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_count_person_by_where (IFaceLogProcessor *self,
                                                    gint32 sequence_id,
                                                    ThriftProtocol *input_protocol,
                                                    ThriftProtocol *output_protocol,
                                                    GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogCountPersonByWhereArgs * args =
    g_object_new (TYPE_I_FACE_LOG_COUNT_PERSON_BY_WHERE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * where;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogCountPersonByWhereResult * result_struct;

    g_object_get (args,
                  "where", &where,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_COUNT_PERSON_BY_WHERE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_count_person_by_where (I_FACE_LOG_IF (self->handler),
                                                  (gint32 *)&return_value,
                                                  where,
                                                  &ex1,
                                                  error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "countPersonByWhere",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "countPersonByWhere",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.countPersonByWhere implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "countPersonByWhere",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (where != NULL)
      g_free (where);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_count_person_group_by_where (IFaceLogProcessor *self,
                                                          gint32 sequence_id,
                                                          ThriftProtocol *input_protocol,
                                                          ThriftProtocol *output_protocol,
                                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogCountPersonGroupByWhereArgs * args =
    g_object_new (TYPE_I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * where;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogCountPersonGroupByWhereResult * result_struct;

    g_object_get (args,
                  "where", &where,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_COUNT_PERSON_GROUP_BY_WHERE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_count_person_group_by_where (I_FACE_LOG_IF (self->handler),
                                                        (gint32 *)&return_value,
                                                        where,
                                                        &ex1,
                                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "countPersonGroupByWhere",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "countPersonGroupByWhere",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.countPersonGroupByWhere implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "countPersonGroupByWhere",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (where != NULL)
      g_free (where);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_delete_all_features_by_person_id (IFaceLogProcessor *self,
                                                               gint32 sequence_id,
                                                               ThriftProtocol *input_protocol,
                                                               ThriftProtocol *output_protocol,
                                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogDeleteAllFeaturesByPersonIdArgs * args =
    g_object_new (TYPE_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personId;
    gboolean deleteImage;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogDeleteAllFeaturesByPersonIdResult * result_struct;

    g_object_get (args,
                  "personId", &personId,
                  "deleteImage", &deleteImage,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_DELETE_ALL_FEATURES_BY_PERSON_ID_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_delete_all_features_by_person_id (I_FACE_LOG_IF (self->handler),
                                                             (gint32 *)&return_value,
                                                             personId,
                                                             deleteImage,
                                                             token,
                                                             &ex1,
                                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "deleteAllFeaturesByPersonId",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteAllFeaturesByPersonId",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.deleteAllFeaturesByPersonId implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteAllFeaturesByPersonId",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_delete_device_group (IFaceLogProcessor *self,
                                                  gint32 sequence_id,
                                                  ThriftProtocol *input_protocol,
                                                  ThriftProtocol *output_protocol,
                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogDeleteDeviceGroupArgs * args =
    g_object_new (TYPE_I_FACE_LOG_DELETE_DEVICE_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint deviceGroupId;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogDeleteDeviceGroupResult * result_struct;

    g_object_get (args,
                  "deviceGroupId", &deviceGroupId,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_DELETE_DEVICE_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_delete_device_group (I_FACE_LOG_IF (self->handler),
                                                (gint32 *)&return_value,
                                                deviceGroupId,
                                                token,
                                                &ex1,
                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "deleteDeviceGroup",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteDeviceGroup",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.deleteDeviceGroup implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteDeviceGroup",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_delete_feature (IFaceLogProcessor *self,
                                             gint32 sequence_id,
                                             ThriftProtocol *input_protocol,
                                             ThriftProtocol *output_protocol,
                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogDeleteFeatureArgs * args =
    g_object_new (TYPE_I_FACE_LOG_DELETE_FEATURE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * featureMd5;
    gboolean deleteImage;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogDeleteFeatureResult * result_struct;

    g_object_get (args,
                  "featureMd5", &featureMd5,
                  "deleteImage", &deleteImage,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_DELETE_FEATURE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_delete_feature (I_FACE_LOG_IF (self->handler),
                                           &return_value,
                                           featureMd5,
                                           deleteImage,
                                           token,
                                           &ex1,
                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "deleteFeature",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteFeature",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.deleteFeature implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteFeature",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (featureMd5 != NULL)
      g_free (featureMd5);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_delete_group_permit_on_device_group (IFaceLogProcessor *self,
                                                                  gint32 sequence_id,
                                                                  ThriftProtocol *input_protocol,
                                                                  ThriftProtocol *output_protocol,
                                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogDeleteGroupPermitOnDeviceGroupArgs * args =
    g_object_new (TYPE_I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint deviceGroupId;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogDeleteGroupPermitOnDeviceGroupResult * result_struct;

    g_object_get (args,
                  "deviceGroupId", &deviceGroupId,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_DELETE_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_delete_group_permit_on_device_group (I_FACE_LOG_IF (self->handler),
                                                                (gint32 *)&return_value,
                                                                deviceGroupId,
                                                                token,
                                                                &ex1,
                                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "deleteGroupPermitOnDeviceGroup",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteGroupPermitOnDeviceGroup",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.deleteGroupPermitOnDeviceGroup implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteGroupPermitOnDeviceGroup",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_delete_image (IFaceLogProcessor *self,
                                           gint32 sequence_id,
                                           ThriftProtocol *input_protocol,
                                           ThriftProtocol *output_protocol,
                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogDeleteImageArgs * args =
    g_object_new (TYPE_I_FACE_LOG_DELETE_IMAGE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * imageMd5;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogDeleteImageResult * result_struct;

    g_object_get (args,
                  "imageMd5", &imageMd5,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_DELETE_IMAGE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_delete_image (I_FACE_LOG_IF (self->handler),
                                         (gint32 *)&return_value,
                                         imageMd5,
                                         token,
                                         &ex1,
                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "deleteImage",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteImage",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.deleteImage implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deleteImage",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (imageMd5 != NULL)
      g_free (imageMd5);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_delete_permit_by_id (IFaceLogProcessor *self,
                                                  gint32 sequence_id,
                                                  ThriftProtocol *input_protocol,
                                                  ThriftProtocol *output_protocol,
                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogDeletePermitByIdArgs * args =
    g_object_new (TYPE_I_FACE_LOG_DELETE_PERMIT_BY_ID_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint deviceGroupId;
    gint personGroupId;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogDeletePermitByIdResult * result_struct;

    g_object_get (args,
                  "deviceGroupId", &deviceGroupId,
                  "personGroupId", &personGroupId,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_DELETE_PERMIT_BY_ID_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_delete_permit_by_id (I_FACE_LOG_IF (self->handler),
                                                (gint32 *)&return_value,
                                                deviceGroupId,
                                                personGroupId,
                                                token,
                                                &ex1,
                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "deletePermitById",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deletePermitById",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.deletePermitById implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deletePermitById",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_delete_person (IFaceLogProcessor *self,
                                            gint32 sequence_id,
                                            ThriftProtocol *input_protocol,
                                            ThriftProtocol *output_protocol,
                                            GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogDeletePersonArgs * args =
    g_object_new (TYPE_I_FACE_LOG_DELETE_PERSON_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personId;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogDeletePersonResult * result_struct;

    g_object_get (args,
                  "personId", &personId,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_DELETE_PERSON_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_delete_person (I_FACE_LOG_IF (self->handler),
                                          (gint32 *)&return_value,
                                          personId,
                                          token,
                                          &ex1,
                                          error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "deletePerson",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deletePerson",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.deletePerson implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deletePerson",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_delete_person_by_papers_num (IFaceLogProcessor *self,
                                                          gint32 sequence_id,
                                                          ThriftProtocol *input_protocol,
                                                          ThriftProtocol *output_protocol,
                                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogDeletePersonByPapersNumArgs * args =
    g_object_new (TYPE_I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * papersNum;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogDeletePersonByPapersNumResult * result_struct;

    g_object_get (args,
                  "papersNum", &papersNum,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_DELETE_PERSON_BY_PAPERS_NUM_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_delete_person_by_papers_num (I_FACE_LOG_IF (self->handler),
                                                        (gint32 *)&return_value,
                                                        papersNum,
                                                        token,
                                                        &ex1,
                                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "deletePersonByPapersNum",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deletePersonByPapersNum",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.deletePersonByPapersNum implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deletePersonByPapersNum",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (papersNum != NULL)
      g_free (papersNum);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_delete_person_group (IFaceLogProcessor *self,
                                                  gint32 sequence_id,
                                                  ThriftProtocol *input_protocol,
                                                  ThriftProtocol *output_protocol,
                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogDeletePersonGroupArgs * args =
    g_object_new (TYPE_I_FACE_LOG_DELETE_PERSON_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personGroupId;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogDeletePersonGroupResult * result_struct;

    g_object_get (args,
                  "personGroupId", &personGroupId,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_DELETE_PERSON_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_delete_person_group (I_FACE_LOG_IF (self->handler),
                                                (gint32 *)&return_value,
                                                personGroupId,
                                                token,
                                                &ex1,
                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "deletePersonGroup",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deletePersonGroup",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.deletePersonGroup implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deletePersonGroup",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_delete_person_group_permit (IFaceLogProcessor *self,
                                                         gint32 sequence_id,
                                                         ThriftProtocol *input_protocol,
                                                         ThriftProtocol *output_protocol,
                                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogDeletePersonGroupPermitArgs * args =
    g_object_new (TYPE_I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personGroupId;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogDeletePersonGroupPermitResult * result_struct;

    g_object_get (args,
                  "personGroupId", &personGroupId,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_DELETE_PERSON_GROUP_PERMIT_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_delete_person_group_permit (I_FACE_LOG_IF (self->handler),
                                                       (gint32 *)&return_value,
                                                       personGroupId,
                                                       token,
                                                       &ex1,
                                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "deletePersonGroupPermit",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deletePersonGroupPermit",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.deletePersonGroupPermit implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deletePersonGroupPermit",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_delete_persons (IFaceLogProcessor *self,
                                             gint32 sequence_id,
                                             ThriftProtocol *input_protocol,
                                             ThriftProtocol *output_protocol,
                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogDeletePersonsArgs * args =
    g_object_new (TYPE_I_FACE_LOG_DELETE_PERSONS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GArray * personIdList;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogDeletePersonsResult * result_struct;

    g_object_get (args,
                  "personIdList", &personIdList,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_DELETE_PERSONS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_delete_persons (I_FACE_LOG_IF (self->handler),
                                           (gint32 *)&return_value,
                                           personIdList,
                                           token,
                                           &ex1,
                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "deletePersons",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deletePersons",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.deletePersons implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deletePersons",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (personIdList != NULL)
      g_array_unref (personIdList);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_delete_persons_by_papers_num (IFaceLogProcessor *self,
                                                           gint32 sequence_id,
                                                           ThriftProtocol *input_protocol,
                                                           ThriftProtocol *output_protocol,
                                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogDeletePersonsByPapersNumArgs * args =
    g_object_new (TYPE_I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * papersNumlist;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogDeletePersonsByPapersNumResult * result_struct;

    g_object_get (args,
                  "papersNumlist", &papersNumlist,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_DELETE_PERSONS_BY_PAPERS_NUM_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_delete_persons_by_papers_num (I_FACE_LOG_IF (self->handler),
                                                         (gint32 *)&return_value,
                                                         papersNumlist,
                                                         token,
                                                         &ex1,
                                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "deletePersonsByPapersNum",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deletePersonsByPapersNum",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.deletePersonsByPapersNum implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "deletePersonsByPapersNum",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (papersNumlist != NULL)
      g_ptr_array_unref (papersNumlist);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_disable_person (IFaceLogProcessor *self,
                                             gint32 sequence_id,
                                             ThriftProtocol *input_protocol,
                                             ThriftProtocol *output_protocol,
                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogDisablePersonArgs * args =
    g_object_new (TYPE_I_FACE_LOG_DISABLE_PERSON_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personId;
    gint moveToGroupId;
    gboolean deletePhoto;
    gboolean deleteFeature;
    gboolean deleteLog;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    IFaceLogDisablePersonResult * result_struct;

    g_object_get (args,
                  "personId", &personId,
                  "moveToGroupId", &moveToGroupId,
                  "deletePhoto", &deletePhoto,
                  "deleteFeature", &deleteFeature,
                  "deleteLog", &deleteLog,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_DISABLE_PERSON_RESULT, NULL);

    if (i_face_log_handler_disable_person (I_FACE_LOG_IF (self->handler),
                                           personId,
                                           moveToGroupId,
                                           deletePhoto,
                                           deleteFeature,
                                           deleteLog,
                                           token,
                                           &ex1,
                                           error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "disablePerson",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "disablePerson",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.disablePerson implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "disablePerson",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_disable_person_list (IFaceLogProcessor *self,
                                                  gint32 sequence_id,
                                                  ThriftProtocol *input_protocol,
                                                  ThriftProtocol *output_protocol,
                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogDisablePersonListArgs * args =
    g_object_new (TYPE_I_FACE_LOG_DISABLE_PERSON_LIST_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GArray * personIdList;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    IFaceLogDisablePersonListResult * result_struct;

    g_object_get (args,
                  "personIdList", &personIdList,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_DISABLE_PERSON_LIST_RESULT, NULL);

    if (i_face_log_handler_disable_person_list (I_FACE_LOG_IF (self->handler),
                                                personIdList,
                                                token,
                                                &ex1,
                                                error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "disablePersonList",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "disablePersonList",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.disablePersonList implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "disablePersonList",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (personIdList != NULL)
      g_array_unref (personIdList);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_exists_device (IFaceLogProcessor *self,
                                            gint32 sequence_id,
                                            ThriftProtocol *input_protocol,
                                            ThriftProtocol *output_protocol,
                                            GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogExistsDeviceArgs * args =
    g_object_new (TYPE_I_FACE_LOG_EXISTS_DEVICE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint id;
    ServiceRuntimeException * ex1 = NULL;
    gboolean return_value;
    IFaceLogExistsDeviceResult * result_struct;

    g_object_get (args,
                  "id", &id,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_EXISTS_DEVICE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_exists_device (I_FACE_LOG_IF (self->handler),
                                          &return_value,
                                          id,
                                          &ex1,
                                          error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "existsDevice",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "existsDevice",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.existsDevice implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "existsDevice",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_exists_feature (IFaceLogProcessor *self,
                                             gint32 sequence_id,
                                             ThriftProtocol *input_protocol,
                                             ThriftProtocol *output_protocol,
                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogExistsFeatureArgs * args =
    g_object_new (TYPE_I_FACE_LOG_EXISTS_FEATURE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * md5;
    ServiceRuntimeException * ex1 = NULL;
    gboolean return_value;
    IFaceLogExistsFeatureResult * result_struct;

    g_object_get (args,
                  "md5", &md5,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_EXISTS_FEATURE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_exists_feature (I_FACE_LOG_IF (self->handler),
                                           &return_value,
                                           md5,
                                           &ex1,
                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "existsFeature",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "existsFeature",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.existsFeature implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "existsFeature",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (md5 != NULL)
      g_free (md5);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_exists_image (IFaceLogProcessor *self,
                                           gint32 sequence_id,
                                           ThriftProtocol *input_protocol,
                                           ThriftProtocol *output_protocol,
                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogExistsImageArgs * args =
    g_object_new (TYPE_I_FACE_LOG_EXISTS_IMAGE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * md5;
    ServiceRuntimeException * ex1 = NULL;
    gboolean return_value;
    IFaceLogExistsImageResult * result_struct;

    g_object_get (args,
                  "md5", &md5,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_EXISTS_IMAGE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_exists_image (I_FACE_LOG_IF (self->handler),
                                         &return_value,
                                         md5,
                                         &ex1,
                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "existsImage",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "existsImage",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.existsImage implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "existsImage",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (md5 != NULL)
      g_free (md5);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_exists_person (IFaceLogProcessor *self,
                                            gint32 sequence_id,
                                            ThriftProtocol *input_protocol,
                                            ThriftProtocol *output_protocol,
                                            GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogExistsPersonArgs * args =
    g_object_new (TYPE_I_FACE_LOG_EXISTS_PERSON_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint persionId;
    ServiceRuntimeException * ex1 = NULL;
    gboolean return_value;
    IFaceLogExistsPersonResult * result_struct;

    g_object_get (args,
                  "persionId", &persionId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_EXISTS_PERSON_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_exists_person (I_FACE_LOG_IF (self->handler),
                                          &return_value,
                                          persionId,
                                          &ex1,
                                          error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "existsPerson",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "existsPerson",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.existsPerson implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "existsPerson",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_device (IFaceLogProcessor *self,
                                         gint32 sequence_id,
                                         ThriftProtocol *input_protocol,
                                         ThriftProtocol *output_protocol,
                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetDeviceArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_DEVICE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint deviceId;
    ServiceRuntimeException * ex1 = NULL;
    DeviceBean * return_value;
    IFaceLogGetDeviceResult * result_struct;

    g_object_get (args,
                  "deviceId", &deviceId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_DEVICE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_device (I_FACE_LOG_IF (self->handler),
                                       &return_value,
                                       deviceId,
                                       &ex1,
                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getDevice",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDevice",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getDevice implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDevice",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_device_by_mac (IFaceLogProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetDeviceByMacArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_DEVICE_BY_MAC_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * mac;
    ServiceRuntimeException * ex1 = NULL;
    DeviceBean * return_value;
    IFaceLogGetDeviceByMacResult * result_struct;

    g_object_get (args,
                  "mac", &mac,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_DEVICE_BY_MAC_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_device_by_mac (I_FACE_LOG_IF (self->handler),
                                              &return_value,
                                              mac,
                                              &ex1,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getDeviceByMac",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDeviceByMac",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getDeviceByMac implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDeviceByMac",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (mac != NULL)
      g_free (mac);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_device_group (IFaceLogProcessor *self,
                                               gint32 sequence_id,
                                               ThriftProtocol *input_protocol,
                                               ThriftProtocol *output_protocol,
                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetDeviceGroupArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_DEVICE_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint deviceGroupId;
    ServiceRuntimeException * ex1 = NULL;
    DeviceGroupBean * return_value;
    IFaceLogGetDeviceGroupResult * result_struct;

    g_object_get (args,
                  "deviceGroupId", &deviceGroupId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_DEVICE_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_device_group (I_FACE_LOG_IF (self->handler),
                                             &return_value,
                                             deviceGroupId,
                                             &ex1,
                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getDeviceGroup",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDeviceGroup",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getDeviceGroup implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDeviceGroup",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_device_groups (IFaceLogProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetDeviceGroupsArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_DEVICE_GROUPS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GArray * groupIdList;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogGetDeviceGroupsResult * result_struct;

    g_object_get (args,
                  "groupIdList", &groupIdList,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_DEVICE_GROUPS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_device_groups (I_FACE_LOG_IF (self->handler),
                                              &return_value,
                                              groupIdList,
                                              &ex1,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getDeviceGroups",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDeviceGroups",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getDeviceGroups implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDeviceGroups",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (groupIdList != NULL)
      g_array_unref (groupIdList);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_device_groups_belongs (IFaceLogProcessor *self,
                                                        gint32 sequence_id,
                                                        ThriftProtocol *input_protocol,
                                                        ThriftProtocol *output_protocol,
                                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetDeviceGroupsBelongsArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint deviceId;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogGetDeviceGroupsBelongsResult * result_struct;

    g_object_get (args,
                  "deviceId", &deviceId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_DEVICE_GROUPS_BELONGS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_device_groups_belongs (I_FACE_LOG_IF (self->handler),
                                                      &return_value,
                                                      deviceId,
                                                      &ex1,
                                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getDeviceGroupsBelongs",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDeviceGroupsBelongs",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getDeviceGroupsBelongs implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDeviceGroupsBelongs",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_device_groups_permit (IFaceLogProcessor *self,
                                                       gint32 sequence_id,
                                                       ThriftProtocol *input_protocol,
                                                       ThriftProtocol *output_protocol,
                                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetDeviceGroupsPermitArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personGroupId;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogGetDeviceGroupsPermitResult * result_struct;

    g_object_get (args,
                  "personGroupId", &personGroupId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_DEVICE_GROUPS_PERMIT_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_device_groups_permit (I_FACE_LOG_IF (self->handler),
                                                     &return_value,
                                                     personGroupId,
                                                     &ex1,
                                                     error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getDeviceGroupsPermit",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDeviceGroupsPermit",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getDeviceGroupsPermit implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDeviceGroupsPermit",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_device_groups_permitted_by (IFaceLogProcessor *self,
                                                             gint32 sequence_id,
                                                             ThriftProtocol *input_protocol,
                                                             ThriftProtocol *output_protocol,
                                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetDeviceGroupsPermittedByArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personGroupId;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogGetDeviceGroupsPermittedByResult * result_struct;

    g_object_get (args,
                  "personGroupId", &personGroupId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_DEVICE_GROUPS_PERMITTED_BY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_device_groups_permitted_by (I_FACE_LOG_IF (self->handler),
                                                           &return_value,
                                                           personGroupId,
                                                           &ex1,
                                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getDeviceGroupsPermittedBy",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDeviceGroupsPermittedBy",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getDeviceGroupsPermittedBy implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDeviceGroupsPermittedBy",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_device_id_of_feature (IFaceLogProcessor *self,
                                                       gint32 sequence_id,
                                                       ThriftProtocol *input_protocol,
                                                       ThriftProtocol *output_protocol,
                                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetDeviceIdOfFeatureArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * featureMd5;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogGetDeviceIdOfFeatureResult * result_struct;

    g_object_get (args,
                  "featureMd5", &featureMd5,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_DEVICE_ID_OF_FEATURE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_device_id_of_feature (I_FACE_LOG_IF (self->handler),
                                                     (gint32 *)&return_value,
                                                     featureMd5,
                                                     &ex1,
                                                     error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getDeviceIdOfFeature",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDeviceIdOfFeature",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getDeviceIdOfFeature implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDeviceIdOfFeature",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (featureMd5 != NULL)
      g_free (featureMd5);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_devices (IFaceLogProcessor *self,
                                          gint32 sequence_id,
                                          ThriftProtocol *input_protocol,
                                          ThriftProtocol *output_protocol,
                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetDevicesArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_DEVICES_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GArray * idList;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogGetDevicesResult * result_struct;

    g_object_get (args,
                  "idList", &idList,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_DEVICES_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_devices (I_FACE_LOG_IF (self->handler),
                                        &return_value,
                                        idList,
                                        &ex1,
                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getDevices",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDevices",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getDevices implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDevices",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (idList != NULL)
      g_array_unref (idList);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_devices_of_group (IFaceLogProcessor *self,
                                                   gint32 sequence_id,
                                                   ThriftProtocol *input_protocol,
                                                   ThriftProtocol *output_protocol,
                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetDevicesOfGroupArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_DEVICES_OF_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint deviceGroupId;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogGetDevicesOfGroupResult * result_struct;

    g_object_get (args,
                  "deviceGroupId", &deviceGroupId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_DEVICES_OF_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_devices_of_group (I_FACE_LOG_IF (self->handler),
                                                 &return_value,
                                                 deviceGroupId,
                                                 &ex1,
                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getDevicesOfGroup",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDevicesOfGroup",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getDevicesOfGroup implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getDevicesOfGroup",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_face (IFaceLogProcessor *self,
                                       gint32 sequence_id,
                                       ThriftProtocol *input_protocol,
                                       ThriftProtocol *output_protocol,
                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetFaceArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_FACE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint faceId;
    ServiceRuntimeException * ex1 = NULL;
    FaceBean * return_value;
    IFaceLogGetFaceResult * result_struct;

    g_object_get (args,
                  "faceId", &faceId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_FACE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_face (I_FACE_LOG_IF (self->handler),
                                     &return_value,
                                     faceId,
                                     &ex1,
                                     error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getFace",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFace",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getFace implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFace",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_feature (IFaceLogProcessor *self,
                                          gint32 sequence_id,
                                          ThriftProtocol *input_protocol,
                                          ThriftProtocol *output_protocol,
                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetFeatureArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_FEATURE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * md5;
    ServiceRuntimeException * ex1 = NULL;
    FeatureBean * return_value;
    IFaceLogGetFeatureResult * result_struct;

    g_object_get (args,
                  "md5", &md5,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_FEATURE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_feature (I_FACE_LOG_IF (self->handler),
                                        &return_value,
                                        md5,
                                        &ex1,
                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getFeature",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFeature",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getFeature implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFeature",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (md5 != NULL)
      g_free (md5);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_feature_bytes (IFaceLogProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetFeatureBytesArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_FEATURE_BYTES_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * md5;
    ServiceRuntimeException * ex1 = NULL;
    GByteArray * return_value;
    IFaceLogGetFeatureBytesResult * result_struct;

    g_object_get (args,
                  "md5", &md5,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_FEATURE_BYTES_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_feature_bytes (I_FACE_LOG_IF (self->handler),
                                              &return_value,
                                              md5,
                                              &ex1,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_byte_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getFeatureBytes",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFeatureBytes",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getFeatureBytes implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFeatureBytes",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (md5 != NULL)
      g_free (md5);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_features (IFaceLogProcessor *self,
                                           gint32 sequence_id,
                                           ThriftProtocol *input_protocol,
                                           ThriftProtocol *output_protocol,
                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetFeaturesArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_FEATURES_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * md5;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogGetFeaturesResult * result_struct;

    g_object_get (args,
                  "md5", &md5,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_FEATURES_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_features (I_FACE_LOG_IF (self->handler),
                                         &return_value,
                                         md5,
                                         &ex1,
                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getFeatures",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFeatures",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getFeatures implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFeatures",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (md5 != NULL)
      g_ptr_array_unref (md5);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_features_by_person_id_and_sdk_version (IFaceLogProcessor *self,
                                                                        gint32 sequence_id,
                                                                        ThriftProtocol *input_protocol,
                                                                        ThriftProtocol *output_protocol,
                                                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetFeaturesByPersonIdAndSdkVersionArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personId;
    gchar * sdkVersion;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogGetFeaturesByPersonIdAndSdkVersionResult * result_struct;

    g_object_get (args,
                  "personId", &personId,
                  "sdkVersion", &sdkVersion,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_FEATURES_BY_PERSON_ID_AND_SDK_VERSION_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_features_by_person_id_and_sdk_version (I_FACE_LOG_IF (self->handler),
                                                                      &return_value,
                                                                      personId,
                                                                      sdkVersion,
                                                                      &ex1,
                                                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getFeaturesByPersonIdAndSdkVersion",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFeaturesByPersonIdAndSdkVersion",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getFeaturesByPersonIdAndSdkVersion implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFeaturesByPersonIdAndSdkVersion",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (sdkVersion != NULL)
      g_free (sdkVersion);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_features_of_person (IFaceLogProcessor *self,
                                                     gint32 sequence_id,
                                                     ThriftProtocol *input_protocol,
                                                     ThriftProtocol *output_protocol,
                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetFeaturesOfPersonArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_FEATURES_OF_PERSON_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personId;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogGetFeaturesOfPersonResult * result_struct;

    g_object_get (args,
                  "personId", &personId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_FEATURES_OF_PERSON_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_features_of_person (I_FACE_LOG_IF (self->handler),
                                                   &return_value,
                                                   personId,
                                                   &ex1,
                                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getFeaturesOfPerson",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFeaturesOfPerson",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getFeaturesOfPerson implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFeaturesOfPerson",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_features_permitted_on_device (IFaceLogProcessor *self,
                                                               gint32 sequence_id,
                                                               ThriftProtocol *input_protocol,
                                                               ThriftProtocol *output_protocol,
                                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetFeaturesPermittedOnDeviceArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_FEATURES_PERMITTED_ON_DEVICE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint deviceId;
    gboolean ignoreSchedule;
    gchar * sdkVersion;
    GPtrArray * excludeFeatureIds;
    gint64 timestamp;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogGetFeaturesPermittedOnDeviceResult * result_struct;

    g_object_get (args,
                  "deviceId", &deviceId,
                  "ignoreSchedule", &ignoreSchedule,
                  "sdkVersion", &sdkVersion,
                  "excludeFeatureIds", &excludeFeatureIds,
                  "timestamp", &timestamp,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_FEATURES_PERMITTED_ON_DEVICE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_features_permitted_on_device (I_FACE_LOG_IF (self->handler),
                                                             &return_value,
                                                             deviceId,
                                                             ignoreSchedule,
                                                             sdkVersion,
                                                             excludeFeatureIds,
                                                             timestamp,
                                                             &ex1,
                                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getFeaturesPermittedOnDevice",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFeaturesPermittedOnDevice",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getFeaturesPermittedOnDevice implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getFeaturesPermittedOnDevice",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (sdkVersion != NULL)
      g_free (sdkVersion);
    if (excludeFeatureIds != NULL)
      g_ptr_array_unref (excludeFeatureIds);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_group_permit (IFaceLogProcessor *self,
                                               gint32 sequence_id,
                                               ThriftProtocol *input_protocol,
                                               ThriftProtocol *output_protocol,
                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetGroupPermitArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_GROUP_PERMIT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint deviceId;
    gint personGroupId;
    ServiceRuntimeException * ex1 = NULL;
    PermitBean * return_value;
    IFaceLogGetGroupPermitResult * result_struct;

    g_object_get (args,
                  "deviceId", &deviceId,
                  "personGroupId", &personGroupId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_GROUP_PERMIT_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_group_permit (I_FACE_LOG_IF (self->handler),
                                             &return_value,
                                             deviceId,
                                             personGroupId,
                                             &ex1,
                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getGroupPermit",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getGroupPermit",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getGroupPermit implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getGroupPermit",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_group_permit_on_device_group (IFaceLogProcessor *self,
                                                               gint32 sequence_id,
                                                               ThriftProtocol *input_protocol,
                                                               ThriftProtocol *output_protocol,
                                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetGroupPermitOnDeviceGroupArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint deviceGroupId;
    gint personGroupId;
    ServiceRuntimeException * ex1 = NULL;
    PermitBean * return_value;
    IFaceLogGetGroupPermitOnDeviceGroupResult * result_struct;

    g_object_get (args,
                  "deviceGroupId", &deviceGroupId,
                  "personGroupId", &personGroupId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_GROUP_PERMIT_ON_DEVICE_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_group_permit_on_device_group (I_FACE_LOG_IF (self->handler),
                                                             &return_value,
                                                             deviceGroupId,
                                                             personGroupId,
                                                             &ex1,
                                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getGroupPermitOnDeviceGroup",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getGroupPermitOnDeviceGroup",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getGroupPermitOnDeviceGroup implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getGroupPermitOnDeviceGroup",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_group_permits (IFaceLogProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetGroupPermitsArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_GROUP_PERMITS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint deviceId;
    GArray * personGroupIdList;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogGetGroupPermitsResult * result_struct;

    g_object_get (args,
                  "deviceId", &deviceId,
                  "personGroupIdList", &personGroupIdList,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_GROUP_PERMITS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_group_permits (I_FACE_LOG_IF (self->handler),
                                              &return_value,
                                              deviceId,
                                              personGroupIdList,
                                              &ex1,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getGroupPermits",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getGroupPermits",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getGroupPermits implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getGroupPermits",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (personGroupIdList != NULL)
      g_array_unref (personGroupIdList);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_image (IFaceLogProcessor *self,
                                        gint32 sequence_id,
                                        ThriftProtocol *input_protocol,
                                        ThriftProtocol *output_protocol,
                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetImageArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_IMAGE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * imageMD5;
    ServiceRuntimeException * ex1 = NULL;
    ImageBean * return_value;
    IFaceLogGetImageResult * result_struct;

    g_object_get (args,
                  "imageMD5", &imageMD5,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_IMAGE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_image (I_FACE_LOG_IF (self->handler),
                                      &return_value,
                                      imageMD5,
                                      &ex1,
                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getImage",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getImage",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getImage implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getImage",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (imageMD5 != NULL)
      g_free (imageMD5);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_image_bytes (IFaceLogProcessor *self,
                                              gint32 sequence_id,
                                              ThriftProtocol *input_protocol,
                                              ThriftProtocol *output_protocol,
                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetImageBytesArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_IMAGE_BYTES_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * imageMD5;
    ServiceRuntimeException * ex1 = NULL;
    GByteArray * return_value;
    IFaceLogGetImageBytesResult * result_struct;

    g_object_get (args,
                  "imageMD5", &imageMD5,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_IMAGE_BYTES_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_image_bytes (I_FACE_LOG_IF (self->handler),
                                            &return_value,
                                            imageMD5,
                                            &ex1,
                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_byte_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getImageBytes",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getImageBytes",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getImageBytes implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getImageBytes",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (imageMD5 != NULL)
      g_free (imageMD5);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_images_associated_by_feature (IFaceLogProcessor *self,
                                                               gint32 sequence_id,
                                                               ThriftProtocol *input_protocol,
                                                               ThriftProtocol *output_protocol,
                                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetImagesAssociatedByFeatureArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * featureMd5;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogGetImagesAssociatedByFeatureResult * result_struct;

    g_object_get (args,
                  "featureMd5", &featureMd5,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_IMAGES_ASSOCIATED_BY_FEATURE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_images_associated_by_feature (I_FACE_LOG_IF (self->handler),
                                                             &return_value,
                                                             featureMd5,
                                                             &ex1,
                                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getImagesAssociatedByFeature",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getImagesAssociatedByFeature",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getImagesAssociatedByFeature implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getImagesAssociatedByFeature",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (featureMd5 != NULL)
      g_free (featureMd5);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_log_beans_by_person_id (IFaceLogProcessor *self,
                                                         gint32 sequence_id,
                                                         ThriftProtocol *input_protocol,
                                                         ThriftProtocol *output_protocol,
                                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetLogBeansByPersonIdArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personId;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogGetLogBeansByPersonIdResult * result_struct;

    g_object_get (args,
                  "personId", &personId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_LOG_BEANS_BY_PERSON_ID_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_log_beans_by_person_id (I_FACE_LOG_IF (self->handler),
                                                       &return_value,
                                                       personId,
                                                       &ex1,
                                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getLogBeansByPersonId",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getLogBeansByPersonId",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getLogBeansByPersonId implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getLogBeansByPersonId",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_person (IFaceLogProcessor *self,
                                         gint32 sequence_id,
                                         ThriftProtocol *input_protocol,
                                         ThriftProtocol *output_protocol,
                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetPersonArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_PERSON_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personId;
    ServiceRuntimeException * ex1 = NULL;
    PersonBean * return_value;
    IFaceLogGetPersonResult * result_struct;

    g_object_get (args,
                  "personId", &personId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_PERSON_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_person (I_FACE_LOG_IF (self->handler),
                                       &return_value,
                                       personId,
                                       &ex1,
                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPerson",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPerson",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getPerson implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPerson",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_person_by_mobile_phone (IFaceLogProcessor *self,
                                                         gint32 sequence_id,
                                                         ThriftProtocol *input_protocol,
                                                         ThriftProtocol *output_protocol,
                                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetPersonByMobilePhoneArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_PERSON_BY_MOBILE_PHONE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * mobilePhone;
    ServiceRuntimeException * ex1 = NULL;
    PersonBean * return_value;
    IFaceLogGetPersonByMobilePhoneResult * result_struct;

    g_object_get (args,
                  "mobilePhone", &mobilePhone,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_PERSON_BY_MOBILE_PHONE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_person_by_mobile_phone (I_FACE_LOG_IF (self->handler),
                                                       &return_value,
                                                       mobilePhone,
                                                       &ex1,
                                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPersonByMobilePhone",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonByMobilePhone",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getPersonByMobilePhone implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonByMobilePhone",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (mobilePhone != NULL)
      g_free (mobilePhone);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_person_by_papers_num (IFaceLogProcessor *self,
                                                       gint32 sequence_id,
                                                       ThriftProtocol *input_protocol,
                                                       ThriftProtocol *output_protocol,
                                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetPersonByPapersNumArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * papersNum;
    ServiceRuntimeException * ex1 = NULL;
    PersonBean * return_value;
    IFaceLogGetPersonByPapersNumResult * result_struct;

    g_object_get (args,
                  "papersNum", &papersNum,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_PERSON_BY_PAPERS_NUM_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_person_by_papers_num (I_FACE_LOG_IF (self->handler),
                                                     &return_value,
                                                     papersNum,
                                                     &ex1,
                                                     error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPersonByPapersNum",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonByPapersNum",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getPersonByPapersNum implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonByPapersNum",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (papersNum != NULL)
      g_free (papersNum);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_person_group (IFaceLogProcessor *self,
                                               gint32 sequence_id,
                                               ThriftProtocol *input_protocol,
                                               ThriftProtocol *output_protocol,
                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetPersonGroupArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_PERSON_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personGroupId;
    ServiceRuntimeException * ex1 = NULL;
    PersonGroupBean * return_value;
    IFaceLogGetPersonGroupResult * result_struct;

    g_object_get (args,
                  "personGroupId", &personGroupId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_PERSON_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_person_group (I_FACE_LOG_IF (self->handler),
                                             &return_value,
                                             personGroupId,
                                             &ex1,
                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPersonGroup",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonGroup",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getPersonGroup implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonGroup",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_person_groups (IFaceLogProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetPersonGroupsArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_PERSON_GROUPS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GArray * groupIdList;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogGetPersonGroupsResult * result_struct;

    g_object_get (args,
                  "groupIdList", &groupIdList,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_PERSON_GROUPS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_person_groups (I_FACE_LOG_IF (self->handler),
                                              &return_value,
                                              groupIdList,
                                              &ex1,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPersonGroups",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonGroups",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getPersonGroups implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonGroups",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (groupIdList != NULL)
      g_array_unref (groupIdList);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_person_groups_belongs (IFaceLogProcessor *self,
                                                        gint32 sequence_id,
                                                        ThriftProtocol *input_protocol,
                                                        ThriftProtocol *output_protocol,
                                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetPersonGroupsBelongsArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personId;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogGetPersonGroupsBelongsResult * result_struct;

    g_object_get (args,
                  "personId", &personId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_PERSON_GROUPS_BELONGS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_person_groups_belongs (I_FACE_LOG_IF (self->handler),
                                                      &return_value,
                                                      personId,
                                                      &ex1,
                                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPersonGroupsBelongs",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonGroupsBelongs",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getPersonGroupsBelongs implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonGroupsBelongs",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_person_groups_permitted_by (IFaceLogProcessor *self,
                                                             gint32 sequence_id,
                                                             ThriftProtocol *input_protocol,
                                                             ThriftProtocol *output_protocol,
                                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetPersonGroupsPermittedByArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint deviceGroupId;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogGetPersonGroupsPermittedByResult * result_struct;

    g_object_get (args,
                  "deviceGroupId", &deviceGroupId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_PERSON_GROUPS_PERMITTED_BY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_person_groups_permitted_by (I_FACE_LOG_IF (self->handler),
                                                           &return_value,
                                                           deviceGroupId,
                                                           &ex1,
                                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPersonGroupsPermittedBy",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonGroupsPermittedBy",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getPersonGroupsPermittedBy implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonGroupsPermittedBy",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_person_permit (IFaceLogProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetPersonPermitArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_PERSON_PERMIT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint deviceId;
    gint personId;
    ServiceRuntimeException * ex1 = NULL;
    PermitBean * return_value;
    IFaceLogGetPersonPermitResult * result_struct;

    g_object_get (args,
                  "deviceId", &deviceId,
                  "personId", &personId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_PERSON_PERMIT_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_person_permit (I_FACE_LOG_IF (self->handler),
                                              &return_value,
                                              deviceId,
                                              personId,
                                              &ex1,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPersonPermit",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonPermit",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getPersonPermit implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonPermit",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_person_permits (IFaceLogProcessor *self,
                                                 gint32 sequence_id,
                                                 ThriftProtocol *input_protocol,
                                                 ThriftProtocol *output_protocol,
                                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetPersonPermitsArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_PERSON_PERMITS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint deviceId;
    GArray * personIdList;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogGetPersonPermitsResult * result_struct;

    g_object_get (args,
                  "deviceId", &deviceId,
                  "personIdList", &personIdList,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_PERSON_PERMITS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_person_permits (I_FACE_LOG_IF (self->handler),
                                               &return_value,
                                               deviceId,
                                               personIdList,
                                               &ex1,
                                               error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPersonPermits",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonPermits",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getPersonPermits implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonPermits",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (personIdList != NULL)
      g_array_unref (personIdList);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_persons (IFaceLogProcessor *self,
                                          gint32 sequence_id,
                                          ThriftProtocol *input_protocol,
                                          ThriftProtocol *output_protocol,
                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetPersonsArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_PERSONS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GArray * idList;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogGetPersonsResult * result_struct;

    g_object_get (args,
                  "idList", &idList,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_PERSONS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_persons (I_FACE_LOG_IF (self->handler),
                                        &return_value,
                                        idList,
                                        &ex1,
                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPersons",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersons",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getPersons implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersons",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (idList != NULL)
      g_array_unref (idList);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_persons_of_group (IFaceLogProcessor *self,
                                                   gint32 sequence_id,
                                                   ThriftProtocol *input_protocol,
                                                   ThriftProtocol *output_protocol,
                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetPersonsOfGroupArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_PERSONS_OF_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personGroupId;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogGetPersonsOfGroupResult * result_struct;

    g_object_get (args,
                  "personGroupId", &personGroupId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_PERSONS_OF_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_persons_of_group (I_FACE_LOG_IF (self->handler),
                                                 &return_value,
                                                 personGroupId,
                                                 &ex1,
                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPersonsOfGroup",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonsOfGroup",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getPersonsOfGroup implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonsOfGroup",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_persons_permitted_on_device (IFaceLogProcessor *self,
                                                              gint32 sequence_id,
                                                              ThriftProtocol *input_protocol,
                                                              ThriftProtocol *output_protocol,
                                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetPersonsPermittedOnDeviceArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_PERSONS_PERMITTED_ON_DEVICE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint deviceId;
    gboolean ignoreSchedule;
    GArray * excludePersonIds;
    gint64 timestamp;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogGetPersonsPermittedOnDeviceResult * result_struct;

    g_object_get (args,
                  "deviceId", &deviceId,
                  "ignoreSchedule", &ignoreSchedule,
                  "excludePersonIds", &excludePersonIds,
                  "timestamp", &timestamp,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_PERSONS_PERMITTED_ON_DEVICE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_persons_permitted_on_device (I_FACE_LOG_IF (self->handler),
                                                            &return_value,
                                                            deviceId,
                                                            ignoreSchedule,
                                                            excludePersonIds,
                                                            timestamp,
                                                            &ex1,
                                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getPersonsPermittedOnDevice",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonsPermittedOnDevice",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getPersonsPermittedOnDevice implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getPersonsPermittedOnDevice",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (excludePersonIds != NULL)
      g_array_unref (excludePersonIds);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_properties (IFaceLogProcessor *self,
                                             gint32 sequence_id,
                                             ThriftProtocol *input_protocol,
                                             ThriftProtocol *output_protocol,
                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetPropertiesArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_PROPERTIES_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * prefix;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    GHashTable * return_value;
    IFaceLogGetPropertiesResult * result_struct;

    g_object_get (args,
                  "prefix", &prefix,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_PROPERTIES_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_properties (I_FACE_LOG_IF (self->handler),
                                           &return_value,
                                           prefix,
                                           token,
                                           &ex1,
                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_hash_table_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getProperties",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getProperties",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getProperties implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getProperties",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (prefix != NULL)
      g_free (prefix);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_property (IFaceLogProcessor *self,
                                           gint32 sequence_id,
                                           ThriftProtocol *input_protocol,
                                           ThriftProtocol *output_protocol,
                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetPropertyArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_PROPERTY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * key;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gchar * return_value;
    IFaceLogGetPropertyResult * result_struct;

    g_object_get (args,
                  "key", &key,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_PROPERTY_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_property (I_FACE_LOG_IF (self->handler),
                                         &return_value,
                                         key,
                                         token,
                                         &ex1,
                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_free (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getProperty",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getProperty",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getProperty implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getProperty",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (key != NULL)
      g_free (key);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_redis_parameters (IFaceLogProcessor *self,
                                                   gint32 sequence_id,
                                                   ThriftProtocol *input_protocol,
                                                   ThriftProtocol *output_protocol,
                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetRedisParametersArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_REDIS_PARAMETERS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    GHashTable * return_value;
    IFaceLogGetRedisParametersResult * result_struct;

    g_object_get (args,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_REDIS_PARAMETERS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_redis_parameters (I_FACE_LOG_IF (self->handler),
                                                 &return_value,
                                                 token,
                                                 &ex1,
                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_hash_table_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getRedisParameters",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRedisParameters",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getRedisParameters implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getRedisParameters",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_service_config (IFaceLogProcessor *self,
                                                 gint32 sequence_id,
                                                 ThriftProtocol *input_protocol,
                                                 ThriftProtocol *output_protocol,
                                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetServiceConfigArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_SERVICE_CONFIG_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    GHashTable * return_value;
    IFaceLogGetServiceConfigResult * result_struct;

    g_object_get (args,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_SERVICE_CONFIG_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_service_config (I_FACE_LOG_IF (self->handler),
                                               &return_value,
                                               token,
                                               &ex1,
                                               error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_hash_table_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getServiceConfig",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getServiceConfig",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getServiceConfig implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getServiceConfig",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_sub_device_group (IFaceLogProcessor *self,
                                                   gint32 sequence_id,
                                                   ThriftProtocol *input_protocol,
                                                   ThriftProtocol *output_protocol,
                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetSubDeviceGroupArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_SUB_DEVICE_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint deviceGroupId;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogGetSubDeviceGroupResult * result_struct;

    g_object_get (args,
                  "deviceGroupId", &deviceGroupId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_SUB_DEVICE_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_sub_device_group (I_FACE_LOG_IF (self->handler),
                                                 &return_value,
                                                 deviceGroupId,
                                                 &ex1,
                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getSubDeviceGroup",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getSubDeviceGroup",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getSubDeviceGroup implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getSubDeviceGroup",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_get_sub_person_group (IFaceLogProcessor *self,
                                                   gint32 sequence_id,
                                                   ThriftProtocol *input_protocol,
                                                   ThriftProtocol *output_protocol,
                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogGetSubPersonGroupArgs * args =
    g_object_new (TYPE_I_FACE_LOG_GET_SUB_PERSON_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personGroupId;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogGetSubPersonGroupResult * result_struct;

    g_object_get (args,
                  "personGroupId", &personGroupId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_GET_SUB_PERSON_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_get_sub_person_group (I_FACE_LOG_IF (self->handler),
                                                 &return_value,
                                                 personGroupId,
                                                 &ex1,
                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "getSubPersonGroup",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getSubPersonGroup",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.getSubPersonGroup implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "getSubPersonGroup",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_is_disable (IFaceLogProcessor *self,
                                         gint32 sequence_id,
                                         ThriftProtocol *input_protocol,
                                         ThriftProtocol *output_protocol,
                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogIsDisableArgs * args =
    g_object_new (TYPE_I_FACE_LOG_IS_DISABLE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personId;
    ServiceRuntimeException * ex1 = NULL;
    gboolean return_value;
    IFaceLogIsDisableResult * result_struct;

    g_object_get (args,
                  "personId", &personId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_IS_DISABLE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_is_disable (I_FACE_LOG_IF (self->handler),
                                       &return_value,
                                       personId,
                                       &ex1,
                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "isDisable",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isDisable",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.isDisable implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isDisable",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_is_local (IFaceLogProcessor *self,
                                       gint32 sequence_id,
                                       ThriftProtocol *input_protocol,
                                       ThriftProtocol *output_protocol,
                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogIsLocalArgs * args =
    g_object_new (TYPE_I_FACE_LOG_IS_LOCAL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    ServiceRuntimeException * ex1 = NULL;
    gboolean return_value;
    IFaceLogIsLocalResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_IS_LOCAL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_is_local (I_FACE_LOG_IF (self->handler),
                                     &return_value,
                                     &ex1,
                                     error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "isLocal",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isLocal",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.isLocal implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isLocal",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_is_valid_ack_channel (IFaceLogProcessor *self,
                                                   gint32 sequence_id,
                                                   ThriftProtocol *input_protocol,
                                                   ThriftProtocol *output_protocol,
                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogIsValidAckChannelArgs * args =
    g_object_new (TYPE_I_FACE_LOG_IS_VALID_ACK_CHANNEL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * ackChannel;
    ServiceRuntimeException * ex1 = NULL;
    gboolean return_value;
    IFaceLogIsValidAckChannelResult * result_struct;

    g_object_get (args,
                  "ackChannel", &ackChannel,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_IS_VALID_ACK_CHANNEL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_is_valid_ack_channel (I_FACE_LOG_IF (self->handler),
                                                 &return_value,
                                                 ackChannel,
                                                 &ex1,
                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "isValidAckChannel",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isValidAckChannel",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.isValidAckChannel implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isValidAckChannel",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (ackChannel != NULL)
      g_free (ackChannel);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_is_valid_cmd_sn (IFaceLogProcessor *self,
                                              gint32 sequence_id,
                                              ThriftProtocol *input_protocol,
                                              ThriftProtocol *output_protocol,
                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogIsValidCmdSnArgs * args =
    g_object_new (TYPE_I_FACE_LOG_IS_VALID_CMD_SN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint cmdSn;
    ServiceRuntimeException * ex1 = NULL;
    gboolean return_value;
    IFaceLogIsValidCmdSnResult * result_struct;

    g_object_get (args,
                  "cmdSn", &cmdSn,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_IS_VALID_CMD_SN_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_is_valid_cmd_sn (I_FACE_LOG_IF (self->handler),
                                            &return_value,
                                            cmdSn,
                                            &ex1,
                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "isValidCmdSn",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isValidCmdSn",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.isValidCmdSn implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isValidCmdSn",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_is_valid_device_token (IFaceLogProcessor *self,
                                                    gint32 sequence_id,
                                                    ThriftProtocol *input_protocol,
                                                    ThriftProtocol *output_protocol,
                                                    GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogIsValidDeviceTokenArgs * args =
    g_object_new (TYPE_I_FACE_LOG_IS_VALID_DEVICE_TOKEN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gboolean return_value;
    IFaceLogIsValidDeviceTokenResult * result_struct;

    g_object_get (args,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_IS_VALID_DEVICE_TOKEN_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_is_valid_device_token (I_FACE_LOG_IF (self->handler),
                                                  &return_value,
                                                  token,
                                                  &ex1,
                                                  error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "isValidDeviceToken",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isValidDeviceToken",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.isValidDeviceToken implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isValidDeviceToken",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_is_valid_password (IFaceLogProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogIsValidPasswordArgs * args =
    g_object_new (TYPE_I_FACE_LOG_IS_VALID_PASSWORD_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * userId;
    gchar * password;
    gboolean isMd5;
    ServiceRuntimeException * ex1 = NULL;
    gboolean return_value;
    IFaceLogIsValidPasswordResult * result_struct;

    g_object_get (args,
                  "userId", &userId,
                  "password", &password,
                  "isMd5", &isMd5,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_IS_VALID_PASSWORD_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_is_valid_password (I_FACE_LOG_IF (self->handler),
                                              &return_value,
                                              userId,
                                              password,
                                              isMd5,
                                              &ex1,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "isValidPassword",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isValidPassword",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.isValidPassword implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isValidPassword",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (userId != NULL)
      g_free (userId);
    if (password != NULL)
      g_free (password);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_is_valid_person_token (IFaceLogProcessor *self,
                                                    gint32 sequence_id,
                                                    ThriftProtocol *input_protocol,
                                                    ThriftProtocol *output_protocol,
                                                    GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogIsValidPersonTokenArgs * args =
    g_object_new (TYPE_I_FACE_LOG_IS_VALID_PERSON_TOKEN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gboolean return_value;
    IFaceLogIsValidPersonTokenResult * result_struct;

    g_object_get (args,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_IS_VALID_PERSON_TOKEN_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_is_valid_person_token (I_FACE_LOG_IF (self->handler),
                                                  &return_value,
                                                  token,
                                                  &ex1,
                                                  error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "isValidPersonToken",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isValidPersonToken",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.isValidPersonToken implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isValidPersonToken",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_is_valid_root_token (IFaceLogProcessor *self,
                                                  gint32 sequence_id,
                                                  ThriftProtocol *input_protocol,
                                                  ThriftProtocol *output_protocol,
                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogIsValidRootTokenArgs * args =
    g_object_new (TYPE_I_FACE_LOG_IS_VALID_ROOT_TOKEN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gboolean return_value;
    IFaceLogIsValidRootTokenResult * result_struct;

    g_object_get (args,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_IS_VALID_ROOT_TOKEN_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_is_valid_root_token (I_FACE_LOG_IF (self->handler),
                                                &return_value,
                                                token,
                                                &ex1,
                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "isValidRootToken",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isValidRootToken",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.isValidRootToken implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isValidRootToken",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_is_valid_token (IFaceLogProcessor *self,
                                             gint32 sequence_id,
                                             ThriftProtocol *input_protocol,
                                             ThriftProtocol *output_protocol,
                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogIsValidTokenArgs * args =
    g_object_new (TYPE_I_FACE_LOG_IS_VALID_TOKEN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gboolean return_value;
    IFaceLogIsValidTokenResult * result_struct;

    g_object_get (args,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_IS_VALID_TOKEN_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_is_valid_token (I_FACE_LOG_IF (self->handler),
                                           &return_value,
                                           token,
                                           &ex1,
                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "isValidToken",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isValidToken",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.isValidToken implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isValidToken",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_is_valid_user_token (IFaceLogProcessor *self,
                                                  gint32 sequence_id,
                                                  ThriftProtocol *input_protocol,
                                                  ThriftProtocol *output_protocol,
                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogIsValidUserTokenArgs * args =
    g_object_new (TYPE_I_FACE_LOG_IS_VALID_USER_TOKEN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gboolean return_value;
    IFaceLogIsValidUserTokenResult * result_struct;

    g_object_get (args,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_IS_VALID_USER_TOKEN_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_is_valid_user_token (I_FACE_LOG_IF (self->handler),
                                                &return_value,
                                                token,
                                                &ex1,
                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "isValidUserToken",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isValidUserToken",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.isValidUserToken implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "isValidUserToken",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_list_of_parent_for_device_group (IFaceLogProcessor *self,
                                                              gint32 sequence_id,
                                                              ThriftProtocol *input_protocol,
                                                              ThriftProtocol *output_protocol,
                                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogListOfParentForDeviceGroupArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint deviceGroupId;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogListOfParentForDeviceGroupResult * result_struct;

    g_object_get (args,
                  "deviceGroupId", &deviceGroupId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LIST_OF_PARENT_FOR_DEVICE_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_list_of_parent_for_device_group (I_FACE_LOG_IF (self->handler),
                                                            &return_value,
                                                            deviceGroupId,
                                                            &ex1,
                                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "listOfParentForDeviceGroup",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listOfParentForDeviceGroup",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.listOfParentForDeviceGroup implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listOfParentForDeviceGroup",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_list_of_parent_for_person_group (IFaceLogProcessor *self,
                                                              gint32 sequence_id,
                                                              ThriftProtocol *input_protocol,
                                                              ThriftProtocol *output_protocol,
                                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogListOfParentForPersonGroupArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personGroupId;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogListOfParentForPersonGroupResult * result_struct;

    g_object_get (args,
                  "personGroupId", &personGroupId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LIST_OF_PARENT_FOR_PERSON_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_list_of_parent_for_person_group (I_FACE_LOG_IF (self->handler),
                                                            &return_value,
                                                            personGroupId,
                                                            &ex1,
                                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "listOfParentForPersonGroup",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listOfParentForPersonGroup",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.listOfParentForPersonGroup implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "listOfParentForPersonGroup",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_all_person (IFaceLogProcessor *self,
                                              gint32 sequence_id,
                                              ThriftProtocol *input_protocol,
                                              ThriftProtocol *output_protocol,
                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadAllPersonArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_ALL_PERSON_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogLoadAllPersonResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_ALL_PERSON_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_all_person (I_FACE_LOG_IF (self->handler),
                                            &return_value,
                                            &ex1,
                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadAllPerson",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadAllPerson",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadAllPerson implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadAllPerson",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_device_by_where (IFaceLogProcessor *self,
                                                   gint32 sequence_id,
                                                   ThriftProtocol *input_protocol,
                                                   ThriftProtocol *output_protocol,
                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadDeviceByWhereArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * where;
    gint startRow;
    gint numRows;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogLoadDeviceByWhereResult * result_struct;

    g_object_get (args,
                  "where", &where,
                  "startRow", &startRow,
                  "numRows", &numRows,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_DEVICE_BY_WHERE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_device_by_where (I_FACE_LOG_IF (self->handler),
                                                 &return_value,
                                                 where,
                                                 startRow,
                                                 numRows,
                                                 &ex1,
                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadDeviceByWhere",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadDeviceByWhere",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadDeviceByWhere implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadDeviceByWhere",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (where != NULL)
      g_free (where);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_device_group_by_where (IFaceLogProcessor *self,
                                                         gint32 sequence_id,
                                                         ThriftProtocol *input_protocol,
                                                         ThriftProtocol *output_protocol,
                                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadDeviceGroupByWhereArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * where;
    gint startRow;
    gint numRows;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogLoadDeviceGroupByWhereResult * result_struct;

    g_object_get (args,
                  "where", &where,
                  "startRow", &startRow,
                  "numRows", &numRows,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_DEVICE_GROUP_BY_WHERE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_device_group_by_where (I_FACE_LOG_IF (self->handler),
                                                       &return_value,
                                                       where,
                                                       startRow,
                                                       numRows,
                                                       &ex1,
                                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadDeviceGroupByWhere",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadDeviceGroupByWhere",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadDeviceGroupByWhere implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadDeviceGroupByWhere",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (where != NULL)
      g_free (where);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_device_group_id_by_where (IFaceLogProcessor *self,
                                                            gint32 sequence_id,
                                                            ThriftProtocol *input_protocol,
                                                            ThriftProtocol *output_protocol,
                                                            GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadDeviceGroupIdByWhereArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * where;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogLoadDeviceGroupIdByWhereResult * result_struct;

    g_object_get (args,
                  "where", &where,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_DEVICE_GROUP_ID_BY_WHERE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_device_group_id_by_where (I_FACE_LOG_IF (self->handler),
                                                          &return_value,
                                                          where,
                                                          &ex1,
                                                          error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadDeviceGroupIdByWhere",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadDeviceGroupIdByWhere",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadDeviceGroupIdByWhere implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadDeviceGroupIdByWhere",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (where != NULL)
      g_free (where);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_device_id_by_where (IFaceLogProcessor *self,
                                                      gint32 sequence_id,
                                                      ThriftProtocol *input_protocol,
                                                      ThriftProtocol *output_protocol,
                                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadDeviceIdByWhereArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * where;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogLoadDeviceIdByWhereResult * result_struct;

    g_object_get (args,
                  "where", &where,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_DEVICE_ID_BY_WHERE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_device_id_by_where (I_FACE_LOG_IF (self->handler),
                                                    &return_value,
                                                    where,
                                                    &ex1,
                                                    error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadDeviceIdByWhere",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadDeviceIdByWhere",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadDeviceIdByWhere implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadDeviceIdByWhere",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (where != NULL)
      g_free (where);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_distinct_integer_column (IFaceLogProcessor *self,
                                                           gint32 sequence_id,
                                                           ThriftProtocol *input_protocol,
                                                           ThriftProtocol *output_protocol,
                                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadDistinctIntegerColumnArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_DISTINCT_INTEGER_COLUMN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * table;
    gchar * column;
    gchar * where;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogLoadDistinctIntegerColumnResult * result_struct;

    g_object_get (args,
                  "table", &table,
                  "column", &column,
                  "where", &where,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_DISTINCT_INTEGER_COLUMN_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_distinct_integer_column (I_FACE_LOG_IF (self->handler),
                                                         &return_value,
                                                         table,
                                                         column,
                                                         where,
                                                         &ex1,
                                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadDistinctIntegerColumn",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadDistinctIntegerColumn",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadDistinctIntegerColumn implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadDistinctIntegerColumn",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (table != NULL)
      g_free (table);
    if (column != NULL)
      g_free (column);
    if (where != NULL)
      g_free (where);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_distinct_string_column (IFaceLogProcessor *self,
                                                          gint32 sequence_id,
                                                          ThriftProtocol *input_protocol,
                                                          ThriftProtocol *output_protocol,
                                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadDistinctStringColumnArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_DISTINCT_STRING_COLUMN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * table;
    gchar * column;
    gchar * where;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogLoadDistinctStringColumnResult * result_struct;

    g_object_get (args,
                  "table", &table,
                  "column", &column,
                  "where", &where,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_DISTINCT_STRING_COLUMN_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_distinct_string_column (I_FACE_LOG_IF (self->handler),
                                                        &return_value,
                                                        table,
                                                        column,
                                                        where,
                                                        &ex1,
                                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadDistinctStringColumn",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadDistinctStringColumn",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadDistinctStringColumn implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadDistinctStringColumn",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (table != NULL)
      g_free (table);
    if (column != NULL)
      g_free (column);
    if (where != NULL)
      g_free (where);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_feature_md5_by_update (IFaceLogProcessor *self,
                                                         gint32 sequence_id,
                                                         ThriftProtocol *input_protocol,
                                                         ThriftProtocol *output_protocol,
                                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadFeatureMd5ByUpdateArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint64 timestamp;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogLoadFeatureMd5ByUpdateResult * result_struct;

    g_object_get (args,
                  "timestamp", &timestamp,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_feature_md5_by_update (I_FACE_LOG_IF (self->handler),
                                                       &return_value,
                                                       timestamp,
                                                       &ex1,
                                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadFeatureMd5ByUpdate",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadFeatureMd5ByUpdate",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadFeatureMd5ByUpdate implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadFeatureMd5ByUpdate",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_feature_md5_by_update_time_str (IFaceLogProcessor *self,
                                                                  gint32 sequence_id,
                                                                  ThriftProtocol *input_protocol,
                                                                  ThriftProtocol *output_protocol,
                                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadFeatureMd5ByUpdateTimeStrArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * timestamp;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogLoadFeatureMd5ByUpdateTimeStrResult * result_struct;

    g_object_get (args,
                  "timestamp", &timestamp,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_FEATURE_MD5_BY_UPDATE_TIME_STR_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_feature_md5_by_update_time_str (I_FACE_LOG_IF (self->handler),
                                                                &return_value,
                                                                timestamp,
                                                                &ex1,
                                                                error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadFeatureMd5ByUpdateTimeStr",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadFeatureMd5ByUpdateTimeStr",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadFeatureMd5ByUpdateTimeStr implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadFeatureMd5ByUpdateTimeStr",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (timestamp != NULL)
      g_free (timestamp);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_log_by_where (IFaceLogProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadLogByWhereArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_LOG_BY_WHERE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * where;
    gint startRow;
    gint numRows;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogLoadLogByWhereResult * result_struct;

    g_object_get (args,
                  "where", &where,
                  "startRow", &startRow,
                  "numRows", &numRows,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_LOG_BY_WHERE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_log_by_where (I_FACE_LOG_IF (self->handler),
                                              &return_value,
                                              where,
                                              startRow,
                                              numRows,
                                              &ex1,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadLogByWhere",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadLogByWhere",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadLogByWhere implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadLogByWhere",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (where != NULL)
      g_free (where);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_log_light_by_verify_time (IFaceLogProcessor *self,
                                                            gint32 sequence_id,
                                                            ThriftProtocol *input_protocol,
                                                            ThriftProtocol *output_protocol,
                                                            GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadLogLightByVerifyTimeArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint64 timestamp;
    gint startRow;
    gint numRows;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogLoadLogLightByVerifyTimeResult * result_struct;

    g_object_get (args,
                  "timestamp", &timestamp,
                  "startRow", &startRow,
                  "numRows", &numRows,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_log_light_by_verify_time (I_FACE_LOG_IF (self->handler),
                                                          &return_value,
                                                          timestamp,
                                                          startRow,
                                                          numRows,
                                                          &ex1,
                                                          error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadLogLightByVerifyTime",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadLogLightByVerifyTime",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadLogLightByVerifyTime implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadLogLightByVerifyTime",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_log_light_by_verify_time_timestr (IFaceLogProcessor *self,
                                                                    gint32 sequence_id,
                                                                    ThriftProtocol *input_protocol,
                                                                    ThriftProtocol *output_protocol,
                                                                    GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadLogLightByVerifyTimeTimestrArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * timestamp;
    gint startRow;
    gint numRows;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogLoadLogLightByVerifyTimeTimestrResult * result_struct;

    g_object_get (args,
                  "timestamp", &timestamp,
                  "startRow", &startRow,
                  "numRows", &numRows,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_LOG_LIGHT_BY_VERIFY_TIME_TIMESTR_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_log_light_by_verify_time_timestr (I_FACE_LOG_IF (self->handler),
                                                                  &return_value,
                                                                  timestamp,
                                                                  startRow,
                                                                  numRows,
                                                                  &ex1,
                                                                  error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadLogLightByVerifyTimeTimestr",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadLogLightByVerifyTimeTimestr",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadLogLightByVerifyTimeTimestr implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadLogLightByVerifyTimeTimestr",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (timestamp != NULL)
      g_free (timestamp);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_log_light_by_where (IFaceLogProcessor *self,
                                                      gint32 sequence_id,
                                                      ThriftProtocol *input_protocol,
                                                      ThriftProtocol *output_protocol,
                                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadLogLightByWhereArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * where;
    gint startRow;
    gint numRows;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogLoadLogLightByWhereResult * result_struct;

    g_object_get (args,
                  "where", &where,
                  "startRow", &startRow,
                  "numRows", &numRows,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_LOG_LIGHT_BY_WHERE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_log_light_by_where (I_FACE_LOG_IF (self->handler),
                                                    &return_value,
                                                    where,
                                                    startRow,
                                                    numRows,
                                                    &ex1,
                                                    error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadLogLightByWhere",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadLogLightByWhere",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadLogLightByWhere implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadLogLightByWhere",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (where != NULL)
      g_free (where);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_permit_by_update (IFaceLogProcessor *self,
                                                    gint32 sequence_id,
                                                    ThriftProtocol *input_protocol,
                                                    ThriftProtocol *output_protocol,
                                                    GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadPermitByUpdateArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint64 timestamp;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogLoadPermitByUpdateResult * result_struct;

    g_object_get (args,
                  "timestamp", &timestamp,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_permit_by_update (I_FACE_LOG_IF (self->handler),
                                                  &return_value,
                                                  timestamp,
                                                  &ex1,
                                                  error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadPermitByUpdate",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadPermitByUpdate",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadPermitByUpdate implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadPermitByUpdate",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_permit_by_update_timestr (IFaceLogProcessor *self,
                                                            gint32 sequence_id,
                                                            ThriftProtocol *input_protocol,
                                                            ThriftProtocol *output_protocol,
                                                            GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadPermitByUpdateTimestrArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * timestamp;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogLoadPermitByUpdateTimestrResult * result_struct;

    g_object_get (args,
                  "timestamp", &timestamp,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_PERMIT_BY_UPDATE_TIMESTR_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_permit_by_update_timestr (I_FACE_LOG_IF (self->handler),
                                                          &return_value,
                                                          timestamp,
                                                          &ex1,
                                                          error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadPermitByUpdateTimestr",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadPermitByUpdateTimestr",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadPermitByUpdateTimestr implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadPermitByUpdateTimestr",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (timestamp != NULL)
      g_free (timestamp);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_person_by_where (IFaceLogProcessor *self,
                                                   gint32 sequence_id,
                                                   ThriftProtocol *input_protocol,
                                                   ThriftProtocol *output_protocol,
                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadPersonByWhereArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_PERSON_BY_WHERE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * where;
    gint startRow;
    gint numRows;
    ServiceRuntimeException * ex1 = NULL;
    GPtrArray * return_value;
    IFaceLogLoadPersonByWhereResult * result_struct;

    g_object_get (args,
                  "where", &where,
                  "startRow", &startRow,
                  "numRows", &numRows,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_PERSON_BY_WHERE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_person_by_where (I_FACE_LOG_IF (self->handler),
                                                 &return_value,
                                                 where,
                                                 startRow,
                                                 numRows,
                                                 &ex1,
                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_ptr_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadPersonByWhere",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadPersonByWhere",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadPersonByWhere implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadPersonByWhere",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (where != NULL)
      g_free (where);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_person_group_by_where (IFaceLogProcessor *self,
                                                         gint32 sequence_id,
                                                         ThriftProtocol *input_protocol,
                                                         ThriftProtocol *output_protocol,
                                                         GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadPersonGroupByWhereArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * where;
    gint startRow;
    gint numRows;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogLoadPersonGroupByWhereResult * result_struct;

    g_object_get (args,
                  "where", &where,
                  "startRow", &startRow,
                  "numRows", &numRows,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_PERSON_GROUP_BY_WHERE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_person_group_by_where (I_FACE_LOG_IF (self->handler),
                                                       &return_value,
                                                       where,
                                                       startRow,
                                                       numRows,
                                                       &ex1,
                                                       error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadPersonGroupByWhere",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadPersonGroupByWhere",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadPersonGroupByWhere implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadPersonGroupByWhere",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (where != NULL)
      g_free (where);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_person_group_id_by_where (IFaceLogProcessor *self,
                                                            gint32 sequence_id,
                                                            ThriftProtocol *input_protocol,
                                                            ThriftProtocol *output_protocol,
                                                            GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadPersonGroupIdByWhereArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * where;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogLoadPersonGroupIdByWhereResult * result_struct;

    g_object_get (args,
                  "where", &where,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_PERSON_GROUP_ID_BY_WHERE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_person_group_id_by_where (I_FACE_LOG_IF (self->handler),
                                                          &return_value,
                                                          where,
                                                          &ex1,
                                                          error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadPersonGroupIdByWhere",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadPersonGroupIdByWhere",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadPersonGroupIdByWhere implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadPersonGroupIdByWhere",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (where != NULL)
      g_free (where);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_person_id_by_update_time (IFaceLogProcessor *self,
                                                            gint32 sequence_id,
                                                            ThriftProtocol *input_protocol,
                                                            ThriftProtocol *output_protocol,
                                                            GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadPersonIdByUpdateTimeArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint64 timestamp;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogLoadPersonIdByUpdateTimeResult * result_struct;

    g_object_get (args,
                  "timestamp", &timestamp,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_person_id_by_update_time (I_FACE_LOG_IF (self->handler),
                                                          &return_value,
                                                          timestamp,
                                                          &ex1,
                                                          error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadPersonIdByUpdateTime",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadPersonIdByUpdateTime",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadPersonIdByUpdateTime implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadPersonIdByUpdateTime",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_person_id_by_update_time_time_str (IFaceLogProcessor *self,
                                                                     gint32 sequence_id,
                                                                     ThriftProtocol *input_protocol,
                                                                     ThriftProtocol *output_protocol,
                                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadPersonIdByUpdateTimeTimeStrArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * timestamp;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogLoadPersonIdByUpdateTimeTimeStrResult * result_struct;

    g_object_get (args,
                  "timestamp", &timestamp,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_PERSON_ID_BY_UPDATE_TIME_TIME_STR_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_person_id_by_update_time_time_str (I_FACE_LOG_IF (self->handler),
                                                                   &return_value,
                                                                   timestamp,
                                                                   &ex1,
                                                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadPersonIdByUpdateTimeTimeStr",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadPersonIdByUpdateTimeTimeStr",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadPersonIdByUpdateTimeTimeStr implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadPersonIdByUpdateTimeTimeStr",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (timestamp != NULL)
      g_free (timestamp);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_person_id_by_where (IFaceLogProcessor *self,
                                                      gint32 sequence_id,
                                                      ThriftProtocol *input_protocol,
                                                      ThriftProtocol *output_protocol,
                                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadPersonIdByWhereArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * where;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogLoadPersonIdByWhereResult * result_struct;

    g_object_get (args,
                  "where", &where,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_PERSON_ID_BY_WHERE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_person_id_by_where (I_FACE_LOG_IF (self->handler),
                                                    &return_value,
                                                    where,
                                                    &ex1,
                                                    error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadPersonIdByWhere",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadPersonIdByWhere",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadPersonIdByWhere implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadPersonIdByWhere",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (where != NULL)
      g_free (where);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_updated_persons (IFaceLogProcessor *self,
                                                   gint32 sequence_id,
                                                   ThriftProtocol *input_protocol,
                                                   ThriftProtocol *output_protocol,
                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadUpdatedPersonsArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_UPDATED_PERSONS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint64 timestamp;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogLoadUpdatedPersonsResult * result_struct;

    g_object_get (args,
                  "timestamp", &timestamp,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_UPDATED_PERSONS_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_updated_persons (I_FACE_LOG_IF (self->handler),
                                                 &return_value,
                                                 timestamp,
                                                 &ex1,
                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadUpdatedPersons",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadUpdatedPersons",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadUpdatedPersons implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadUpdatedPersons",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_load_updated_persons_timestr (IFaceLogProcessor *self,
                                                           gint32 sequence_id,
                                                           ThriftProtocol *input_protocol,
                                                           ThriftProtocol *output_protocol,
                                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogLoadUpdatedPersonsTimestrArgs * args =
    g_object_new (TYPE_I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * timestamp;
    ServiceRuntimeException * ex1 = NULL;
    GArray * return_value;
    IFaceLogLoadUpdatedPersonsTimestrResult * result_struct;

    g_object_get (args,
                  "timestamp", &timestamp,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_LOAD_UPDATED_PERSONS_TIMESTR_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_load_updated_persons_timestr (I_FACE_LOG_IF (self->handler),
                                                         &return_value,
                                                         timestamp,
                                                         &ex1,
                                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_array_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "loadUpdatedPersonsTimestr",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadUpdatedPersonsTimestr",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.loadUpdatedPersonsTimestr implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "loadUpdatedPersonsTimestr",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (timestamp != NULL)
      g_free (timestamp);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_offline (IFaceLogProcessor *self,
                                      gint32 sequence_id,
                                      ThriftProtocol *input_protocol,
                                      ThriftProtocol *output_protocol,
                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogOfflineArgs * args =
    g_object_new (TYPE_I_FACE_LOG_OFFLINE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Token * token;
    ServiceSecurityException * ex1 = NULL;
    ServiceRuntimeException * ex2 = NULL;
    IFaceLogOfflineResult * result_struct;

    g_object_get (args,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_OFFLINE_RESULT, NULL);

    if (i_face_log_handler_offline (I_FACE_LOG_IF (self->handler),
                                    token,
                                    &ex1,
                                    &ex2,
                                    error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "offline",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "offline",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ex2 != NULL)
      {
        g_object_set (result_struct,
                      "ex2", ex2,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "offline",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.offline implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "offline",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_online (IFaceLogProcessor *self,
                                     gint32 sequence_id,
                                     ThriftProtocol *input_protocol,
                                     ThriftProtocol *output_protocol,
                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogOnlineArgs * args =
    g_object_new (TYPE_I_FACE_LOG_ONLINE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    DeviceBean * device;
    ServiceSecurityException * ex1 = NULL;
    ServiceRuntimeException * ex2 = NULL;
    Token * return_value;
    IFaceLogOnlineResult * result_struct;

    g_object_get (args,
                  "device", &device,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_ONLINE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_online (I_FACE_LOG_IF (self->handler),
                                   &return_value,
                                   device,
                                   &ex1,
                                   &ex2,
                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "online",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "online",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ex2 != NULL)
      {
        g_object_set (result_struct,
                      "ex2", ex2,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "online",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.online implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "online",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (device != NULL)
      g_object_unref (device);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_register_device (IFaceLogProcessor *self,
                                              gint32 sequence_id,
                                              ThriftProtocol *input_protocol,
                                              ThriftProtocol *output_protocol,
                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogRegisterDeviceArgs * args =
    g_object_new (TYPE_I_FACE_LOG_REGISTER_DEVICE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    DeviceBean * newDevice;
    ServiceSecurityException * ex1 = NULL;
    ServiceRuntimeException * ex2 = NULL;
    DeviceBean * return_value;
    IFaceLogRegisterDeviceResult * result_struct;

    g_object_get (args,
                  "newDevice", &newDevice,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_REGISTER_DEVICE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_register_device (I_FACE_LOG_IF (self->handler),
                                            &return_value,
                                            newDevice,
                                            &ex1,
                                            &ex2,
                                            error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "registerDevice",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "registerDevice",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ex2 != NULL)
      {
        g_object_set (result_struct,
                      "ex2", ex2,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "registerDevice",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.registerDevice implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "registerDevice",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (newDevice != NULL)
      g_object_unref (newDevice);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_release_person_token (IFaceLogProcessor *self,
                                                   gint32 sequence_id,
                                                   ThriftProtocol *input_protocol,
                                                   ThriftProtocol *output_protocol,
                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogReleasePersonTokenArgs * args =
    g_object_new (TYPE_I_FACE_LOG_RELEASE_PERSON_TOKEN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Token * token;
    ServiceSecurityException * ex1 = NULL;
    ServiceRuntimeException * ex2 = NULL;
    IFaceLogReleasePersonTokenResult * result_struct;

    g_object_get (args,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_RELEASE_PERSON_TOKEN_RESULT, NULL);

    if (i_face_log_handler_release_person_token (I_FACE_LOG_IF (self->handler),
                                                 token,
                                                 &ex1,
                                                 &ex2,
                                                 error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "releasePersonToken",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "releasePersonToken",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ex2 != NULL)
      {
        g_object_set (result_struct,
                      "ex2", ex2,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "releasePersonToken",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.releasePersonToken implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "releasePersonToken",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_release_root_token (IFaceLogProcessor *self,
                                                 gint32 sequence_id,
                                                 ThriftProtocol *input_protocol,
                                                 ThriftProtocol *output_protocol,
                                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogReleaseRootTokenArgs * args =
    g_object_new (TYPE_I_FACE_LOG_RELEASE_ROOT_TOKEN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Token * token;
    ServiceSecurityException * ex1 = NULL;
    ServiceRuntimeException * ex2 = NULL;
    IFaceLogReleaseRootTokenResult * result_struct;

    g_object_get (args,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_RELEASE_ROOT_TOKEN_RESULT, NULL);

    if (i_face_log_handler_release_root_token (I_FACE_LOG_IF (self->handler),
                                               token,
                                               &ex1,
                                               &ex2,
                                               error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "releaseRootToken",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "releaseRootToken",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ex2 != NULL)
      {
        g_object_set (result_struct,
                      "ex2", ex2,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "releaseRootToken",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.releaseRootToken implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "releaseRootToken",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_release_user_token (IFaceLogProcessor *self,
                                                 gint32 sequence_id,
                                                 ThriftProtocol *input_protocol,
                                                 ThriftProtocol *output_protocol,
                                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogReleaseUserTokenArgs * args =
    g_object_new (TYPE_I_FACE_LOG_RELEASE_USER_TOKEN_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Token * token;
    ServiceSecurityException * ex1 = NULL;
    ServiceRuntimeException * ex2 = NULL;
    IFaceLogReleaseUserTokenResult * result_struct;

    g_object_get (args,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_RELEASE_USER_TOKEN_RESULT, NULL);

    if (i_face_log_handler_release_user_token (I_FACE_LOG_IF (self->handler),
                                               token,
                                               &ex1,
                                               &ex2,
                                               error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "releaseUserToken",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "releaseUserToken",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ex2 != NULL)
      {
        g_object_set (result_struct,
                      "ex2", ex2,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "releaseUserToken",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.releaseUserToken implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "releaseUserToken",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_replace_feature (IFaceLogProcessor *self,
                                              gint32 sequence_id,
                                              ThriftProtocol *input_protocol,
                                              ThriftProtocol *output_protocol,
                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogReplaceFeatureArgs * args =
    g_object_new (TYPE_I_FACE_LOG_REPLACE_FEATURE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personId;
    gchar * featureMd5;
    gboolean deleteOldFeatureImage;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    IFaceLogReplaceFeatureResult * result_struct;

    g_object_get (args,
                  "personId", &personId,
                  "featureMd5", &featureMd5,
                  "deleteOldFeatureImage", &deleteOldFeatureImage,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_REPLACE_FEATURE_RESULT, NULL);

    if (i_face_log_handler_replace_feature (I_FACE_LOG_IF (self->handler),
                                            personId,
                                            featureMd5,
                                            deleteOldFeatureImage,
                                            token,
                                            &ex1,
                                            error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "replaceFeature",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "replaceFeature",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.replaceFeature implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "replaceFeature",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (featureMd5 != NULL)
      g_free (featureMd5);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_root_group_of_device (IFaceLogProcessor *self,
                                                   gint32 sequence_id,
                                                   ThriftProtocol *input_protocol,
                                                   ThriftProtocol *output_protocol,
                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogRootGroupOfDeviceArgs * args =
    g_object_new (TYPE_I_FACE_LOG_ROOT_GROUP_OF_DEVICE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint deviceId;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogRootGroupOfDeviceResult * result_struct;

    g_object_get (args,
                  "deviceId", &deviceId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_ROOT_GROUP_OF_DEVICE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_root_group_of_device (I_FACE_LOG_IF (self->handler),
                                                 (gint32 *)&return_value,
                                                 deviceId,
                                                 &ex1,
                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "rootGroupOfDevice",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "rootGroupOfDevice",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.rootGroupOfDevice implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "rootGroupOfDevice",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_root_group_of_person (IFaceLogProcessor *self,
                                                   gint32 sequence_id,
                                                   ThriftProtocol *input_protocol,
                                                   ThriftProtocol *output_protocol,
                                                   GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogRootGroupOfPersonArgs * args =
    g_object_new (TYPE_I_FACE_LOG_ROOT_GROUP_OF_PERSON_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personId;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogRootGroupOfPersonResult * result_struct;

    g_object_get (args,
                  "personId", &personId,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_ROOT_GROUP_OF_PERSON_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_root_group_of_person (I_FACE_LOG_IF (self->handler),
                                                 (gint32 *)&return_value,
                                                 personId,
                                                 &ex1,
                                                 error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "rootGroupOfPerson",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "rootGroupOfPerson",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.rootGroupOfPerson implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "rootGroupOfPerson",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_run_cmd (IFaceLogProcessor *self,
                                      gint32 sequence_id,
                                      ThriftProtocol *input_protocol,
                                      ThriftProtocol *output_protocol,
                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogRunCmdArgs * args =
    g_object_new (TYPE_I_FACE_LOG_RUN_CMD_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GArray * target;
    gboolean group;
    gchar * cmdpath;
    gchar * jsonArgs;
    gchar * ackChannel;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gchar * return_value;
    IFaceLogRunCmdResult * result_struct;

    g_object_get (args,
                  "target", &target,
                  "group", &group,
                  "cmdpath", &cmdpath,
                  "jsonArgs", &jsonArgs,
                  "ackChannel", &ackChannel,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_RUN_CMD_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_run_cmd (I_FACE_LOG_IF (self->handler),
                                    &return_value,
                                    target,
                                    group,
                                    cmdpath,
                                    jsonArgs,
                                    ackChannel,
                                    token,
                                    &ex1,
                                    error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_free (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "runCmd",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "runCmd",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.runCmd implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "runCmd",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (target != NULL)
      g_array_unref (target);
    if (cmdpath != NULL)
      g_free (cmdpath);
    if (jsonArgs != NULL)
      g_free (jsonArgs);
    if (ackChannel != NULL)
      g_free (ackChannel);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_run_task (IFaceLogProcessor *self,
                                       gint32 sequence_id,
                                       ThriftProtocol *input_protocol,
                                       ThriftProtocol *output_protocol,
                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogRunTaskArgs * args =
    g_object_new (TYPE_I_FACE_LOG_RUN_TASK_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * taskQueue;
    gchar * cmdpath;
    gchar * jsonArgs;
    gchar * ackChannel;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogRunTaskResult * result_struct;

    g_object_get (args,
                  "taskQueue", &taskQueue,
                  "cmdpath", &cmdpath,
                  "jsonArgs", &jsonArgs,
                  "ackChannel", &ackChannel,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_RUN_TASK_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_run_task (I_FACE_LOG_IF (self->handler),
                                     (gint32 *)&return_value,
                                     taskQueue,
                                     cmdpath,
                                     jsonArgs,
                                     ackChannel,
                                     token,
                                     &ex1,
                                     error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "runTask",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "runTask",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.runTask implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "runTask",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (taskQueue != NULL)
      g_free (taskQueue);
    if (cmdpath != NULL)
      g_free (cmdpath);
    if (jsonArgs != NULL)
      g_free (jsonArgs);
    if (ackChannel != NULL)
      g_free (ackChannel);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_save_device (IFaceLogProcessor *self,
                                          gint32 sequence_id,
                                          ThriftProtocol *input_protocol,
                                          ThriftProtocol *output_protocol,
                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogSaveDeviceArgs * args =
    g_object_new (TYPE_I_FACE_LOG_SAVE_DEVICE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    DeviceBean * deviceBean;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    DeviceBean * return_value;
    IFaceLogSaveDeviceResult * result_struct;

    g_object_get (args,
                  "deviceBean", &deviceBean,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_SAVE_DEVICE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_save_device (I_FACE_LOG_IF (self->handler),
                                        &return_value,
                                        deviceBean,
                                        token,
                                        &ex1,
                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "saveDevice",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "saveDevice",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.saveDevice implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "saveDevice",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (deviceBean != NULL)
      g_object_unref (deviceBean);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_save_device_group (IFaceLogProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogSaveDeviceGroupArgs * args =
    g_object_new (TYPE_I_FACE_LOG_SAVE_DEVICE_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    DeviceGroupBean * deviceGroupBean;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    DeviceGroupBean * return_value;
    IFaceLogSaveDeviceGroupResult * result_struct;

    g_object_get (args,
                  "deviceGroupBean", &deviceGroupBean,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_SAVE_DEVICE_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_save_device_group (I_FACE_LOG_IF (self->handler),
                                              &return_value,
                                              deviceGroupBean,
                                              token,
                                              &ex1,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "saveDeviceGroup",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "saveDeviceGroup",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.saveDeviceGroup implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "saveDeviceGroup",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (deviceGroupBean != NULL)
      g_object_unref (deviceGroupBean);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_save_permit (IFaceLogProcessor *self,
                                          gint32 sequence_id,
                                          ThriftProtocol *input_protocol,
                                          ThriftProtocol *output_protocol,
                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogSavePermitArgs * args =
    g_object_new (TYPE_I_FACE_LOG_SAVE_PERMIT_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    PermitBean * permitBean;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    PermitBean * return_value;
    IFaceLogSavePermitResult * result_struct;

    g_object_get (args,
                  "permitBean", &permitBean,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_SAVE_PERMIT_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_save_permit (I_FACE_LOG_IF (self->handler),
                                        &return_value,
                                        permitBean,
                                        token,
                                        &ex1,
                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "savePermit",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePermit",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.savePermit implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePermit",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (permitBean != NULL)
      g_object_unref (permitBean);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_save_permit_with_schedule (IFaceLogProcessor *self,
                                                        gint32 sequence_id,
                                                        ThriftProtocol *input_protocol,
                                                        ThriftProtocol *output_protocol,
                                                        GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogSavePermitWithScheduleArgs * args =
    g_object_new (TYPE_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint deviceGroupId;
    gint personGroupId;
    gchar * schedule;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    PermitBean * return_value;
    IFaceLogSavePermitWithScheduleResult * result_struct;

    g_object_get (args,
                  "deviceGroupId", &deviceGroupId,
                  "personGroupId", &personGroupId,
                  "schedule", &schedule,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_SAVE_PERMIT_WITH_SCHEDULE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_save_permit_with_schedule (I_FACE_LOG_IF (self->handler),
                                                      &return_value,
                                                      deviceGroupId,
                                                      personGroupId,
                                                      schedule,
                                                      token,
                                                      &ex1,
                                                      error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "savePermitWithSchedule",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePermitWithSchedule",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.savePermitWithSchedule implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePermitWithSchedule",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (schedule != NULL)
      g_free (schedule);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_save_person (IFaceLogProcessor *self,
                                          gint32 sequence_id,
                                          ThriftProtocol *input_protocol,
                                          ThriftProtocol *output_protocol,
                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogSavePersonArgs * args =
    g_object_new (TYPE_I_FACE_LOG_SAVE_PERSON_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    PersonBean * personBean;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    PersonBean * return_value;
    IFaceLogSavePersonResult * result_struct;

    g_object_get (args,
                  "personBean", &personBean,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_SAVE_PERSON_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_save_person (I_FACE_LOG_IF (self->handler),
                                        &return_value,
                                        personBean,
                                        token,
                                        &ex1,
                                        error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "savePerson",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePerson",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.savePerson implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePerson",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (personBean != NULL)
      g_object_unref (personBean);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_save_person_full (IFaceLogProcessor *self,
                                               gint32 sequence_id,
                                               ThriftProtocol *input_protocol,
                                               ThriftProtocol *output_protocol,
                                               GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogSavePersonFullArgs * args =
    g_object_new (TYPE_I_FACE_LOG_SAVE_PERSON_FULL_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    PersonBean * personBean;
    GByteArray * idPhoto;
    GByteArray * feature;
    gchar * featureVersion;
    GByteArray * featureImage;
    FaceBean * featureFaceBean;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    PersonBean * return_value;
    IFaceLogSavePersonFullResult * result_struct;

    g_object_get (args,
                  "personBean", &personBean,
                  "idPhoto", &idPhoto,
                  "feature", &feature,
                  "featureVersion", &featureVersion,
                  "featureImage", &featureImage,
                  "featureFaceBean", &featureFaceBean,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_SAVE_PERSON_FULL_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_save_person_full (I_FACE_LOG_IF (self->handler),
                                             &return_value,
                                             personBean,
                                             idPhoto,
                                             feature,
                                             featureVersion,
                                             featureImage,
                                             featureFaceBean,
                                             token,
                                             &ex1,
                                             error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "savePersonFull",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePersonFull",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.savePersonFull implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePersonFull",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (personBean != NULL)
      g_object_unref (personBean);
    if (idPhoto != NULL)
      g_byte_array_unref (idPhoto);
    if (feature != NULL)
      g_byte_array_unref (feature);
    if (featureVersion != NULL)
      g_free (featureVersion);
    if (featureImage != NULL)
      g_byte_array_unref (featureImage);
    if (featureFaceBean != NULL)
      g_object_unref (featureFaceBean);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_save_person_group (IFaceLogProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogSavePersonGroupArgs * args =
    g_object_new (TYPE_I_FACE_LOG_SAVE_PERSON_GROUP_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    PersonGroupBean * personGroupBean;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    PersonGroupBean * return_value;
    IFaceLogSavePersonGroupResult * result_struct;

    g_object_get (args,
                  "personGroupBean", &personGroupBean,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_SAVE_PERSON_GROUP_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_save_person_group (I_FACE_LOG_IF (self->handler),
                                              &return_value,
                                              personGroupBean,
                                              token,
                                              &ex1,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "savePersonGroup",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePersonGroup",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.savePersonGroup implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePersonGroup",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (personGroupBean != NULL)
      g_object_unref (personGroupBean);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_save_person_with_photo (IFaceLogProcessor *self,
                                                     gint32 sequence_id,
                                                     ThriftProtocol *input_protocol,
                                                     ThriftProtocol *output_protocol,
                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogSavePersonWithPhotoArgs * args =
    g_object_new (TYPE_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    PersonBean * personBean;
    GByteArray * idPhoto;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    PersonBean * return_value;
    IFaceLogSavePersonWithPhotoResult * result_struct;

    g_object_get (args,
                  "personBean", &personBean,
                  "idPhoto", &idPhoto,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_save_person_with_photo (I_FACE_LOG_IF (self->handler),
                                                   &return_value,
                                                   personBean,
                                                   idPhoto,
                                                   token,
                                                   &ex1,
                                                   error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "savePersonWithPhoto",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePersonWithPhoto",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.savePersonWithPhoto implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePersonWithPhoto",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (personBean != NULL)
      g_object_unref (personBean);
    if (idPhoto != NULL)
      g_byte_array_unref (idPhoto);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_save_person_with_photo_and_feature (IFaceLogProcessor *self,
                                                                 gint32 sequence_id,
                                                                 ThriftProtocol *input_protocol,
                                                                 ThriftProtocol *output_protocol,
                                                                 GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogSavePersonWithPhotoAndFeatureArgs * args =
    g_object_new (TYPE_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    PersonBean * personBean;
    GByteArray * idPhoto;
    FeatureBean * featureBean;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    PersonBean * return_value;
    IFaceLogSavePersonWithPhotoAndFeatureResult * result_struct;

    g_object_get (args,
                  "personBean", &personBean,
                  "idPhoto", &idPhoto,
                  "featureBean", &featureBean,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_save_person_with_photo_and_feature (I_FACE_LOG_IF (self->handler),
                                                               &return_value,
                                                               personBean,
                                                               idPhoto,
                                                               featureBean,
                                                               token,
                                                               &ex1,
                                                               error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "savePersonWithPhotoAndFeature",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePersonWithPhotoAndFeature",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.savePersonWithPhotoAndFeature implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePersonWithPhotoAndFeature",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (personBean != NULL)
      g_object_unref (personBean);
    if (idPhoto != NULL)
      g_byte_array_unref (idPhoto);
    if (featureBean != NULL)
      g_object_unref (featureBean);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_save_person_with_photo_and_feature_multi_faces (IFaceLogProcessor *self,
                                                                             gint32 sequence_id,
                                                                             ThriftProtocol *input_protocol,
                                                                             ThriftProtocol *output_protocol,
                                                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogSavePersonWithPhotoAndFeatureMultiFacesArgs * args =
    g_object_new (TYPE_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    PersonBean * personBean;
    GByteArray * idPhoto;
    GByteArray * feature;
    gchar * featureVersion;
    GPtrArray * faceBeans;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    PersonBean * return_value;
    IFaceLogSavePersonWithPhotoAndFeatureMultiFacesResult * result_struct;

    g_object_get (args,
                  "personBean", &personBean,
                  "idPhoto", &idPhoto,
                  "feature", &feature,
                  "featureVersion", &featureVersion,
                  "faceBeans", &faceBeans,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_FACES_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_save_person_with_photo_and_feature_multi_faces (I_FACE_LOG_IF (self->handler),
                                                                           &return_value,
                                                                           personBean,
                                                                           idPhoto,
                                                                           feature,
                                                                           featureVersion,
                                                                           faceBeans,
                                                                           token,
                                                                           &ex1,
                                                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "savePersonWithPhotoAndFeatureMultiFaces",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePersonWithPhotoAndFeatureMultiFaces",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.savePersonWithPhotoAndFeatureMultiFaces implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePersonWithPhotoAndFeatureMultiFaces",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (personBean != NULL)
      g_object_unref (personBean);
    if (idPhoto != NULL)
      g_byte_array_unref (idPhoto);
    if (feature != NULL)
      g_byte_array_unref (feature);
    if (featureVersion != NULL)
      g_free (featureVersion);
    if (faceBeans != NULL)
      g_ptr_array_unref (faceBeans);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_save_person_with_photo_and_feature_multi_image (IFaceLogProcessor *self,
                                                                             gint32 sequence_id,
                                                                             ThriftProtocol *input_protocol,
                                                                             ThriftProtocol *output_protocol,
                                                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogSavePersonWithPhotoAndFeatureMultiImageArgs * args =
    g_object_new (TYPE_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    PersonBean * personBean;
    GByteArray * idPhoto;
    GByteArray * feature;
    gchar * featureVersion;
    GPtrArray * photos;
    GPtrArray * faces;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    PersonBean * return_value;
    IFaceLogSavePersonWithPhotoAndFeatureMultiImageResult * result_struct;

    g_object_get (args,
                  "personBean", &personBean,
                  "idPhoto", &idPhoto,
                  "feature", &feature,
                  "featureVersion", &featureVersion,
                  "photos", &photos,
                  "faces", &faces,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_MULTI_IMAGE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_save_person_with_photo_and_feature_multi_image (I_FACE_LOG_IF (self->handler),
                                                                           &return_value,
                                                                           personBean,
                                                                           idPhoto,
                                                                           feature,
                                                                           featureVersion,
                                                                           photos,
                                                                           faces,
                                                                           token,
                                                                           &ex1,
                                                                           error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "savePersonWithPhotoAndFeatureMultiImage",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePersonWithPhotoAndFeatureMultiImage",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.savePersonWithPhotoAndFeatureMultiImage implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePersonWithPhotoAndFeatureMultiImage",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (personBean != NULL)
      g_object_unref (personBean);
    if (idPhoto != NULL)
      g_byte_array_unref (idPhoto);
    if (feature != NULL)
      g_byte_array_unref (feature);
    if (featureVersion != NULL)
      g_free (featureVersion);
    if (photos != NULL)
      g_ptr_array_unref (photos);
    if (faces != NULL)
      g_ptr_array_unref (faces);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_save_person_with_photo_and_feature_saved (IFaceLogProcessor *self,
                                                                       gint32 sequence_id,
                                                                       ThriftProtocol *input_protocol,
                                                                       ThriftProtocol *output_protocol,
                                                                       GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogSavePersonWithPhotoAndFeatureSavedArgs * args =
    g_object_new (TYPE_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    PersonBean * personBean;
    gchar * idPhotoMd5;
    gchar * featureMd5;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    PersonBean * return_value;
    IFaceLogSavePersonWithPhotoAndFeatureSavedResult * result_struct;

    g_object_get (args,
                  "personBean", &personBean,
                  "idPhotoMd5", &idPhotoMd5,
                  "featureMd5", &featureMd5,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_SAVE_PERSON_WITH_PHOTO_AND_FEATURE_SAVED_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_save_person_with_photo_and_feature_saved (I_FACE_LOG_IF (self->handler),
                                                                     &return_value,
                                                                     personBean,
                                                                     idPhotoMd5,
                                                                     featureMd5,
                                                                     token,
                                                                     &ex1,
                                                                     error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "savePersonWithPhotoAndFeatureSaved",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePersonWithPhotoAndFeatureSaved",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.savePersonWithPhotoAndFeatureSaved implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePersonWithPhotoAndFeatureSaved",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (personBean != NULL)
      g_object_unref (personBean);
    if (idPhotoMd5 != NULL)
      g_free (idPhotoMd5);
    if (featureMd5 != NULL)
      g_free (featureMd5);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_save_persons (IFaceLogProcessor *self,
                                           gint32 sequence_id,
                                           ThriftProtocol *input_protocol,
                                           ThriftProtocol *output_protocol,
                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogSavePersonsArgs * args =
    g_object_new (TYPE_I_FACE_LOG_SAVE_PERSONS_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * persons;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    IFaceLogSavePersonsResult * result_struct;

    g_object_get (args,
                  "persons", &persons,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_SAVE_PERSONS_RESULT, NULL);

    if (i_face_log_handler_save_persons (I_FACE_LOG_IF (self->handler),
                                         persons,
                                         token,
                                         &ex1,
                                         error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "savePersons",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePersons",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.savePersons implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePersons",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (persons != NULL)
      g_ptr_array_unref (persons);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_save_persons_with_photo (IFaceLogProcessor *self,
                                                      gint32 sequence_id,
                                                      ThriftProtocol *input_protocol,
                                                      ThriftProtocol *output_protocol,
                                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogSavePersonsWithPhotoArgs * args =
    g_object_new (TYPE_I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GPtrArray * photos;
    GPtrArray * persons;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gint return_value;
    IFaceLogSavePersonsWithPhotoResult * result_struct;

    g_object_get (args,
                  "photos", &photos,
                  "persons", &persons,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_SAVE_PERSONS_WITH_PHOTO_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_save_persons_with_photo (I_FACE_LOG_IF (self->handler),
                                                    (gint32 *)&return_value,
                                                    photos,
                                                    persons,
                                                    token,
                                                    &ex1,
                                                    error) == TRUE)
    {
      g_object_set (result_struct, "success", (gint)(gint32)return_value, NULL);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "savePersonsWithPhoto",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePersonsWithPhoto",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.savePersonsWithPhoto implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "savePersonsWithPhoto",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (photos != NULL)
      g_ptr_array_unref (photos);
    if (persons != NULL)
      g_ptr_array_unref (persons);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_save_service_config (IFaceLogProcessor *self,
                                                  gint32 sequence_id,
                                                  ThriftProtocol *input_protocol,
                                                  ThriftProtocol *output_protocol,
                                                  GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogSaveServiceConfigArgs * args =
    g_object_new (TYPE_I_FACE_LOG_SAVE_SERVICE_CONFIG_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    IFaceLogSaveServiceConfigResult * result_struct;

    g_object_get (args,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_SAVE_SERVICE_CONFIG_RESULT, NULL);

    if (i_face_log_handler_save_service_config (I_FACE_LOG_IF (self->handler),
                                                token,
                                                &ex1,
                                                error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "saveServiceConfig",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "saveServiceConfig",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.saveServiceConfig implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "saveServiceConfig",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_sdk_task_queue_of (IFaceLogProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogSdkTaskQueueOfArgs * args =
    g_object_new (TYPE_I_FACE_LOG_SDK_TASK_QUEUE_OF_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * task;
    gchar * sdkVersion;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gchar * return_value;
    IFaceLogSdkTaskQueueOfResult * result_struct;

    g_object_get (args,
                  "task", &task,
                  "sdkVersion", &sdkVersion,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_SDK_TASK_QUEUE_OF_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_sdk_task_queue_of (I_FACE_LOG_IF (self->handler),
                                              &return_value,
                                              task,
                                              sdkVersion,
                                              token,
                                              &ex1,
                                              error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_free (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "sdkTaskQueueOf",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "sdkTaskQueueOf",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.sdkTaskQueueOf implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "sdkTaskQueueOf",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (task != NULL)
      g_free (task);
    if (sdkVersion != NULL)
      g_free (sdkVersion);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_set_person_expiry_date (IFaceLogProcessor *self,
                                                     gint32 sequence_id,
                                                     ThriftProtocol *input_protocol,
                                                     ThriftProtocol *output_protocol,
                                                     GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogSetPersonExpiryDateArgs * args =
    g_object_new (TYPE_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personId;
    gint64 expiryDate;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    IFaceLogSetPersonExpiryDateResult * result_struct;

    g_object_get (args,
                  "personId", &personId,
                  "expiryDate", &expiryDate,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_RESULT, NULL);

    if (i_face_log_handler_set_person_expiry_date (I_FACE_LOG_IF (self->handler),
                                                   personId,
                                                   expiryDate,
                                                   token,
                                                   &ex1,
                                                   error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "setPersonExpiryDate",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setPersonExpiryDate",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.setPersonExpiryDate implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setPersonExpiryDate",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_set_person_expiry_date_list (IFaceLogProcessor *self,
                                                          gint32 sequence_id,
                                                          ThriftProtocol *input_protocol,
                                                          ThriftProtocol *output_protocol,
                                                          GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogSetPersonExpiryDateListArgs * args =
    g_object_new (TYPE_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GArray * personIdList;
    gint64 expiryDate;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    IFaceLogSetPersonExpiryDateListResult * result_struct;

    g_object_get (args,
                  "personIdList", &personIdList,
                  "expiryDate", &expiryDate,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_LIST_RESULT, NULL);

    if (i_face_log_handler_set_person_expiry_date_list (I_FACE_LOG_IF (self->handler),
                                                        personIdList,
                                                        expiryDate,
                                                        token,
                                                        &ex1,
                                                        error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "setPersonExpiryDateList",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setPersonExpiryDateList",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.setPersonExpiryDateList implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setPersonExpiryDateList",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (personIdList != NULL)
      g_array_unref (personIdList);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_set_person_expiry_date_time_str (IFaceLogProcessor *self,
                                                              gint32 sequence_id,
                                                              ThriftProtocol *input_protocol,
                                                              ThriftProtocol *output_protocol,
                                                              GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogSetPersonExpiryDateTimeStrArgs * args =
    g_object_new (TYPE_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personId;
    gchar * expiryDate;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    IFaceLogSetPersonExpiryDateTimeStrResult * result_struct;

    g_object_get (args,
                  "personId", &personId,
                  "expiryDate", &expiryDate,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_SET_PERSON_EXPIRY_DATE_TIME_STR_RESULT, NULL);

    if (i_face_log_handler_set_person_expiry_date_time_str (I_FACE_LOG_IF (self->handler),
                                                            personId,
                                                            expiryDate,
                                                            token,
                                                            &ex1,
                                                            error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "setPersonExpiryDateTimeStr",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setPersonExpiryDateTimeStr",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.setPersonExpiryDateTimeStr implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setPersonExpiryDateTimeStr",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (expiryDate != NULL)
      g_free (expiryDate);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_set_properties (IFaceLogProcessor *self,
                                             gint32 sequence_id,
                                             ThriftProtocol *input_protocol,
                                             ThriftProtocol *output_protocol,
                                             GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogSetPropertiesArgs * args =
    g_object_new (TYPE_I_FACE_LOG_SET_PROPERTIES_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    GHashTable * config;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    IFaceLogSetPropertiesResult * result_struct;

    g_object_get (args,
                  "config", &config,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_SET_PROPERTIES_RESULT, NULL);

    if (i_face_log_handler_set_properties (I_FACE_LOG_IF (self->handler),
                                           config,
                                           token,
                                           &ex1,
                                           error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "setProperties",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setProperties",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.setProperties implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setProperties",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (config != NULL)
      g_hash_table_unref (config);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_set_property (IFaceLogProcessor *self,
                                           gint32 sequence_id,
                                           ThriftProtocol *input_protocol,
                                           ThriftProtocol *output_protocol,
                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogSetPropertyArgs * args =
    g_object_new (TYPE_I_FACE_LOG_SET_PROPERTY_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * key;
    gchar * value;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    IFaceLogSetPropertyResult * result_struct;

    g_object_get (args,
                  "key", &key,
                  "value", &value,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_SET_PROPERTY_RESULT, NULL);

    if (i_face_log_handler_set_property (I_FACE_LOG_IF (self->handler),
                                         key,
                                         value,
                                         token,
                                         &ex1,
                                         error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "setProperty",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setProperty",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.setProperty implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "setProperty",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (key != NULL)
      g_free (key);
    if (value != NULL)
      g_free (value);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_task_queue_of (IFaceLogProcessor *self,
                                            gint32 sequence_id,
                                            ThriftProtocol *input_protocol,
                                            ThriftProtocol *output_protocol,
                                            GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogTaskQueueOfArgs * args =
    g_object_new (TYPE_I_FACE_LOG_TASK_QUEUE_OF_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gchar * task;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    gchar * return_value;
    IFaceLogTaskQueueOfResult * result_struct;

    g_object_get (args,
                  "task", &task,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_TASK_QUEUE_OF_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_task_queue_of (I_FACE_LOG_IF (self->handler),
                                          &return_value,
                                          task,
                                          token,
                                          &ex1,
                                          error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_free (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "taskQueueOf",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "taskQueueOf",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.taskQueueOf implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "taskQueueOf",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (task != NULL)
      g_free (task);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_unbind_border (IFaceLogProcessor *self,
                                            gint32 sequence_id,
                                            ThriftProtocol *input_protocol,
                                            ThriftProtocol *output_protocol,
                                            GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogUnbindBorderArgs * args =
    g_object_new (TYPE_I_FACE_LOG_UNBIND_BORDER_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    gint personGroupId;
    gint deviceGroupId;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    IFaceLogUnbindBorderResult * result_struct;

    g_object_get (args,
                  "personGroupId", &personGroupId,
                  "deviceGroupId", &deviceGroupId,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_UNBIND_BORDER_RESULT, NULL);

    if (i_face_log_handler_unbind_border (I_FACE_LOG_IF (self->handler),
                                          personGroupId,
                                          deviceGroupId,
                                          token,
                                          &ex1,
                                          error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "unbindBorder",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "unbindBorder",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.unbindBorder implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "unbindBorder",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_unregister_device (IFaceLogProcessor *self,
                                                gint32 sequence_id,
                                                ThriftProtocol *input_protocol,
                                                ThriftProtocol *output_protocol,
                                                GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogUnregisterDeviceArgs * args =
    g_object_new (TYPE_I_FACE_LOG_UNREGISTER_DEVICE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    Token * token;
    ServiceSecurityException * ex1 = NULL;
    ServiceRuntimeException * ex2 = NULL;
    IFaceLogUnregisterDeviceResult * result_struct;

    g_object_get (args,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_UNREGISTER_DEVICE_RESULT, NULL);

    if (i_face_log_handler_unregister_device (I_FACE_LOG_IF (self->handler),
                                              token,
                                              &ex1,
                                              &ex2,
                                              error) == TRUE)
    {
      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "unregisterDevice",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "unregisterDevice",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
if (ex2 != NULL)
      {
        g_object_set (result_struct,
                      "ex2", ex2,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "unregisterDevice",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.unregisterDevice implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "unregisterDevice",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_update_device (IFaceLogProcessor *self,
                                            gint32 sequence_id,
                                            ThriftProtocol *input_protocol,
                                            ThriftProtocol *output_protocol,
                                            GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogUpdateDeviceArgs * args =
    g_object_new (TYPE_I_FACE_LOG_UPDATE_DEVICE_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    DeviceBean * deviceBean;
    Token * token;
    ServiceRuntimeException * ex1 = NULL;
    DeviceBean * return_value;
    IFaceLogUpdateDeviceResult * result_struct;

    g_object_get (args,
                  "deviceBean", &deviceBean,
                  "token", &token,
                  NULL);

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_UPDATE_DEVICE_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_update_device (I_FACE_LOG_IF (self->handler),
                                          &return_value,
                                          deviceBean,
                                          token,
                                          &ex1,
                                          error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_object_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "updateDevice",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateDevice",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.updateDevice implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "updateDevice",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    if (deviceBean != NULL)
      g_object_unref (deviceBean);
    if (token != NULL)
      g_object_unref (token);
    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_version (IFaceLogProcessor *self,
                                      gint32 sequence_id,
                                      ThriftProtocol *input_protocol,
                                      ThriftProtocol *output_protocol,
                                      GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogVersionArgs * args =
    g_object_new (TYPE_I_FACE_LOG_VERSION_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    ServiceRuntimeException * ex1 = NULL;
    gchar * return_value;
    IFaceLogVersionResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_VERSION_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_version (I_FACE_LOG_IF (self->handler),
                                    &return_value,
                                    &ex1,
                                    error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_free (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "version",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "version",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.version implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "version",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_process_version_info (IFaceLogProcessor *self,
                                           gint32 sequence_id,
                                           ThriftProtocol *input_protocol,
                                           ThriftProtocol *output_protocol,
                                           GError **error)
{
  gboolean result = TRUE;
  ThriftTransport * transport;
  ThriftApplicationException *xception;
  IFaceLogVersionInfoArgs * args =
    g_object_new (TYPE_I_FACE_LOG_VERSION_INFO_ARGS, NULL);

  g_object_get (input_protocol, "transport", &transport, NULL);

  if ((thrift_struct_read (THRIFT_STRUCT (args), input_protocol, error) != -1) &&
      (thrift_protocol_read_message_end (input_protocol, error) != -1) &&
      (thrift_transport_read_end (transport, error) != FALSE))
  {
    ServiceRuntimeException * ex1 = NULL;
    GHashTable * return_value;
    IFaceLogVersionInfoResult * result_struct;

    g_object_unref (transport);
    g_object_get (output_protocol, "transport", &transport, NULL);

    result_struct = g_object_new (TYPE_I_FACE_LOG_VERSION_INFO_RESULT, NULL);
    g_object_get (result_struct, "success", &return_value, NULL);

    if (i_face_log_handler_version_info (I_FACE_LOG_IF (self->handler),
                                         &return_value,
                                         &ex1,
                                         error) == TRUE)
    {
      g_object_set (result_struct, "success", return_value, NULL);
      if (return_value != NULL)
        g_hash_table_unref (return_value);

      result =
        ((thrift_protocol_write_message_begin (output_protocol,
                                               "versionInfo",
                                               T_REPLY,
                                               sequence_id,
                                               error) != -1) &&
         (thrift_struct_write (THRIFT_STRUCT (result_struct),
                               output_protocol,
                               error) != -1));
    }
    else
    {
      if (ex1 != NULL)
      {
        g_object_set (result_struct,
                      "ex1", ex1,
                      NULL);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "versionInfo",
                                                 T_REPLY,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (result_struct),
                                 output_protocol,
                                 error) != -1));
      }
      else
      {
        if (*error == NULL)
          g_warning ("IFaceLog.versionInfo implementation returned FALSE "
                     "but did not set an error");

        xception =
          g_object_new (THRIFT_TYPE_APPLICATION_EXCEPTION,
                        "type",    *error != NULL ? (*error)->code :
                                   THRIFT_APPLICATION_EXCEPTION_ERROR_UNKNOWN,
                        "message", *error != NULL ? (*error)->message : NULL,
                        NULL);
        g_clear_error (error);

        result =
          ((thrift_protocol_write_message_begin (output_protocol,
                                                 "versionInfo",
                                                 T_EXCEPTION,
                                                 sequence_id,
                                                 error) != -1) &&
           (thrift_struct_write (THRIFT_STRUCT (xception),
                                 output_protocol,
                                 error) != -1));

        g_object_unref (xception);
      }
    }

    g_object_unref (result_struct);

    if (result == TRUE)
      result =
        ((thrift_protocol_write_message_end (output_protocol, error) != -1) &&
         (thrift_transport_write_end (transport, error) != FALSE) &&
         (thrift_transport_flush (transport, error) != FALSE));
  }
  else
    result = FALSE;

  g_object_unref (transport);
  g_object_unref (args);

  return result;
}

static gboolean
i_face_log_processor_dispatch_call (ThriftDispatchProcessor *dispatch_processor,
                                    ThriftProtocol *input_protocol,
                                    ThriftProtocol *output_protocol,
                                    gchar *method_name,
                                    gint32 sequence_id,
                                    GError **error)
{
  i_face_log_processor_process_function_def *process_function_def;
  gboolean dispatch_result = FALSE;

  IFaceLogProcessor *self = I_FACE_LOG_PROCESSOR (dispatch_processor);
  ThriftDispatchProcessorClass *parent_class =
    g_type_class_peek_parent (I_FACE_LOG_PROCESSOR_GET_CLASS (self));

  process_function_def = g_hash_table_lookup (self->process_map, method_name);
  if (process_function_def != NULL)
  {
    g_free (method_name);
    dispatch_result = (*process_function_def->function) (self,
                                                         sequence_id,
                                                         input_protocol,
                                                         output_protocol,
                                                         error);
  }
  else
  {
    dispatch_result = parent_class->dispatch_call (dispatch_processor,
                                                   input_protocol,
                                                   output_protocol,
                                                   method_name,
                                                   sequence_id,
                                                   error);
  }

  return dispatch_result;
}

static void
i_face_log_processor_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  IFaceLogProcessor *self = I_FACE_LOG_PROCESSOR (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_PROCESSOR_HANDLER:
      if (self->handler != NULL)
        g_object_unref (self->handler);
      self->handler = g_value_get_object (value);
      g_object_ref (self->handler);
      break;
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_processor_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  IFaceLogProcessor *self = I_FACE_LOG_PROCESSOR (object);

  switch (property_id)
  {
    case PROP_I_FACE_LOG_PROCESSOR_HANDLER:
      g_value_set_object (value, self->handler);
      break;
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
i_face_log_processor_dispose (GObject *gobject)
{
  IFaceLogProcessor *self = I_FACE_LOG_PROCESSOR (gobject);

  if (self->handler != NULL)
  {
    g_object_unref (self->handler);
    self->handler = NULL;
  }

  G_OBJECT_CLASS (i_face_log_processor_parent_class)->dispose (gobject);
}

static void
i_face_log_processor_finalize (GObject *gobject)
{
  IFaceLogProcessor *self = I_FACE_LOG_PROCESSOR (gobject);

  thrift_safe_hash_table_destroy (self->process_map);

  G_OBJECT_CLASS (i_face_log_processor_parent_class)->finalize (gobject);
}

static void
i_face_log_processor_init (IFaceLogProcessor *self)
{
  guint index;

  self->handler = NULL;
  self->process_map = g_hash_table_new (g_str_hash, g_str_equal);

  for (index = 0; index < 158; index += 1)
    g_hash_table_insert (self->process_map,
                         i_face_log_processor_process_function_defs[index].name,
                         &i_face_log_processor_process_function_defs[index]);
}

static void
i_face_log_processor_class_init (IFaceLogProcessorClass *cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftDispatchProcessorClass *dispatch_processor_class =
    THRIFT_DISPATCH_PROCESSOR_CLASS (cls);
  GParamSpec *param_spec;

  gobject_class->dispose = i_face_log_processor_dispose;
  gobject_class->finalize = i_face_log_processor_finalize;
  gobject_class->set_property = i_face_log_processor_set_property;
  gobject_class->get_property = i_face_log_processor_get_property;

  dispatch_processor_class->dispatch_call = i_face_log_processor_dispatch_call;
  cls->dispatch_call = i_face_log_processor_dispatch_call;

  param_spec = g_param_spec_object ("handler",
                                    "Service handler implementation",
                                    "The service handler implementation "
                                    "to which method calls are dispatched.",
                                    TYPE_I_FACE_LOG_HANDLER,
                                    G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_I_FACE_LOG_PROCESSOR_HANDLER,
                                   param_spec);
}
